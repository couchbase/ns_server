%% @author Couchbase <info@couchbase.com>
%% @copyright 2024-Present Couchbase, Inc.
%%
%% Use of this software is governed by the Business Source License included in
%% the file licenses/BSL-Couchbase.txt.  As of the Change Date specified in that
%% file, in accordance with the Business Source License, use of this software
%% will be governed by the Apache License, Version 2.0, included in the file
%% licenses/APL2.txt.
%%
-module(cb_cluster_secrets).

-behaviour(gen_server).

-include("ns_common.hrl").
-include_lib("ns_common/include/cut.hrl").
-include("cb_cluster_secrets.hrl").
-ifdef(TEST).
-include_lib("eunit/include/eunit.hrl").
-endif.

-define(MASTER_MONITOR_NAME, {via, leader_registry, cb_cluster_secrets_master}).
-define(RETRY_TIME, ?get_param(retry_time, 10000)).
-define(SYNC_TIMEOUT, ?get_timeout(sync, 60000)).
-define(NODE_PROC, node_monitor_process).
-define(MASTER_PROC, master_monitor_process).
-define(DEK_COUNTERS_UPDATE_TIMEOUT, ?get_timeout(counters_update, 30000)).
-define(DEK_TIMER_RETRY_TIME_S, ?get_param(dek_retry_interval, 60)).
-define(DEK_DROP_RETRY_TIME_S(Kind),
        ?get_param({dek_removal_min_interval, Kind}, 60*60*3)).
-define(MAX_DEK_NUM(Kind), ?get_param({max_dek_num, Kind}, 50)).
-define(MIN_DEK_GC_INTERVAL_S, ?get_param(min_dek_gc_interval, 60)).

-ifndef(TEST).
-define(MIN_RECHECK_ROTATION_INTERVAL, ?get_param(min_rotation_recheck_interval,
                                                  1000)).
-define(MAX_RECHECK_ROTATION_INTERVAL, ?get_param(rotation_recheck_interval,
                                                  ?SECS_IN_DAY*1000)).
-else.
-define(MIN_RECHECK_ROTATION_INTERVAL, 1000).
-define(MAX_RECHECK_ROTATION_INTERVAL, ?SECS_IN_DAY*1000).
-endif.

%% API
-export([start_link_node_monitor/0,
         start_link_master_monitor/0,
         add_new_secret/1,
         replace_secret/3,
         delete_secret/2,
         get_all/0,
         get_all/1,
         get_secret/1,
         get_secret/2,
         get_active_key_id/1,
         get_active_key_id/2,
         rotate/1,
         get_secret_by_kek_id_map/1,
         ensure_can_encrypt_dek_kind/3,
         is_allowed_usage_for_secret/3,
         is_encrypted_by_secret_manager/1,
         generate_raw_key/1,
         sync_with_all_node_monitors/0,
         new_key_id/0,
         is_valid_key_id/1,
         dek_drop_complete/1,
         is_name_unique/3,
         sanitize_chronicle_cfg/1]).

%% gen_server callbacks
-export([init/1, handle_call/3, handle_cast/2, handle_info/2,
         terminate/2]).

%% Can be called by other nodes:
-export([add_new_secret_internal/1,
         replace_secret_internal/3,
         rotate_internal/1,
         sync_with_node_monitor/0,
         delete_secret_internal/2,
         get_node_deks_info/0]).

-record(state, {proc_type :: ?NODE_PROC | ?MASTER_PROC,
                jobs :: [node_job()] | [master_job()],
                timers = #{retry_jobs => undefined,
                           rotate_keks => undefined,
                           dek_cleanup => undefined,
                           rotate_deks => undefined}
                         :: #{atom() := reference() | undefined},
                deks = #{} :: #{cb_deks:dek_kind() := deks_info()}}).

-export_type([secret_id/0, key_id/0, chronicle_snapshot/0, secret_usage/0]).

-type secret_props() ::
    #{id := secret_id(),
      name := string(),
      creation_time := calendar:datetime(),
      type := secret_type(),
      usage := [secret_usage()],
      data := autogenerated_key_data() | aws_key_data() | kmip_key_data()}.
-type secret_type() :: ?GENERATED_KEY_TYPE | ?AWSKMS_KEY_TYPE | ?KMIP_KEY_TYPE.
-type secret_usage() :: {bucket_encryption, BucketName :: string()} |
                        secrets_encryption | cb_crypto:encryption_type().
-type autogenerated_key_data() :: #{auto_rotation := boolean(),
                                    rotation_interval_in_days := pos_integer(),
                                    next_rotation_time := calendar:datetime(),
                                    last_rotation_time := calendar:datetime(),
                                    active_key_id := key_id(),
                                    keys := [kek_props()],
                                    encrypt_by := nodeSecretManager |
                                                  clusterSecret,
                                    encrypt_secret_id := secret_id() |
                                                         ?SECRET_ID_NOT_SET}.
-type kek_props() :: #{id := key_id(),
                       creation_time := calendar:datetime(),
                       key := sensitive_data()}.
-type sensitive_data() :: #{type := sensitive | encrypted,
                            data := binary(),
                            encrypted_by := undefined | {secret_id(), key_id()}}.
-type aws_key_data() :: #{key_arn := string(),
                          region := string(),
                          profile := string(),
                          config_file := string(),
                          credentials_file := string(),
                          use_imds := boolean(),
                          stored_ids :=
                            [#{id := key_id(),
                               creation_time := calendar:datetime()}],
                          last_rotation_time := calendar:datetime()}.
-type kmip_key_data() :: #{host := string(),
                           port := 1..65535,
                           key_cert_path := string(),
                           key_passphrase := sensitive_data(),
                           encryption_approach := use_get | use_encrypt_decrypt,
                           active_key := kmip_key(),
                           hist_keys := [kmip_key()],
                           encrypt_by := nodeSecretManager |
                                         clusterSecret,
                           encrypt_secret_id := secret_id() |
                                                ?SECRET_ID_NOT_SET}.
-type kmip_key() :: #{id := key_id(),
                      kmip_id := binary(),
                      creation_time := calendar:datetime()}.
-type secret_id() :: non_neg_integer().
-type key_id() :: uuid().
-type chronicle_snapshot() :: direct | map().
-type uuid() :: binary(). %% uuid as binary string
-type node_job() :: garbage_collect_keks |
                    {garbage_collect_deks, cb_deks:dek_kind()} |
                    ensure_all_keks_on_disk |
                    {maybe_update_deks, cb_deks:dek_kind()} |
                    {maybe_reencrypt_deks, cb_deks:dek_kind()}.

-type master_job() :: maybe_reencrypt_secrets | maybe_reset_deks_counters.

-type bad_encrypt_id() :: {encrypt_id, not_allowed | not_found}.
-type bad_usage_change() :: {usage, in_use}.
-type inconsistent_graph() :: {cycle, [secret_id()]} |
                              {unknown_id, secret_id()}.

-type secret_in_use() :: {used_by, #{by_config := [cb_deks:dek_kind()],
                                     by_secret := [secret_id()],
                                     by_deks := [cb_deks:dek_kind()]}}.

-type deks_info() :: #{active_id := cb_deks:dek_id() | undefined,
                       deks := [cb_deks:dek()],
                       is_enabled := boolean(),
                       deks_being_dropped := [cb_deks:dek_id() | ?NULL_DEK],
                       has_unencrypted_data := undefined | boolean(),
                       last_deks_gc_datetime := undefined | calendar:datetime(),
                       last_drop_timestamp := undefined | non_neg_integer()}.

%%%===================================================================
%%% API
%%%===================================================================

%% Starts on each cluster node
-spec start_link_node_monitor() -> {ok, pid()}.
start_link_node_monitor() ->
    gen_server:start_link({local, ?MODULE}, ?MODULE, [?NODE_PROC], []).

%% Starts on the master node only
-spec start_link_master_monitor() -> {ok, pid()}.
start_link_master_monitor() ->
    misc:start_singleton(gen_server, start_link,
                         [?MASTER_MONITOR_NAME, ?MODULE, [?MASTER_PROC], []]).

-spec get_all() -> [secret_props()].
get_all() -> get_all(direct).

-spec get_all(chronicle_snapshot()) -> [secret_props()].
get_all(Snapshot) ->
    chronicle_compat:get(Snapshot, ?CHRONICLE_SECRETS_KEY, #{default => []}).

-spec get_secret(secret_id()) -> {ok, secret_props()} | {error, not_found}.
get_secret(SecretId) -> get_secret(SecretId, direct).

-spec get_secret(secret_id(), chronicle_snapshot()) ->
                                    {ok, secret_props()} | {error, not_found}.
get_secret(SecretId, Snapshot) when is_integer(SecretId) ->
    SearchFun = fun (#{id := Id}) -> SecretId == Id end,
    case lists:search(SearchFun, get_all(Snapshot)) of
        {value, Props} ->
            {ok, Props};
        false ->
            {error, not_found}
    end.

-spec add_new_secret(secret_props()) -> {ok, secret_props()} |
                                        {error, not_supported |
                                                bad_encrypt_id() |
                                                bad_usage_change()}.
add_new_secret(Props) ->
    execute_on_master({?MODULE, add_new_secret_internal, [Props]}).

-spec add_new_secret_internal(secret_props()) ->
          {ok, secret_props()} |
          {error, not_supported |
                  bad_encrypt_id() |
                  bad_usage_change() |
                  inconsistent_graph() |
                  encryption_service:stored_key_error()}.
add_new_secret_internal(Props) ->
    CurrentDateTime = erlang:universaltime(),
    PropsWTime = Props#{creation_time => CurrentDateTime},
    RV = chronicle_compat:txn(
           fun (Txn) ->
               Snapshot = fetch_snapshot_in_txn(Txn),
               CurList = get_all(Snapshot),
               NextId = chronicle_compat:get(Snapshot, ?CHRONICLE_NEXT_ID_KEY,
                                             #{default => 0}),
               PropsWId = PropsWTime#{id => NextId},
               maybe
                   Prepared = prepare_new_secret(PropsWId),
                   {ok, FinalProps} ?= ensure_secret_encrypted_txn(Prepared,
                                                                   Snapshot),
                   NewList = [FinalProps | CurList],
                   ok ?= validate_secret_in_txn(FinalProps, #{}, Snapshot),
                   ok ?= validate_secrets_consistency(NewList),
                   {commit, [{set, ?CHRONICLE_SECRETS_KEY, NewList},
                             {set, ?CHRONICLE_NEXT_ID_KEY, NextId + 1}],
                    FinalProps}
               else
                   {error, Reason} -> {abort, {error, Reason}}
               end
            end),
    case RV of
        {ok, _, Res} ->
            sync_with_all_node_monitors(),
            {ok, Res};
        {error, _} = Error -> Error
    end.

-spec replace_secret(secret_id(), map(), fun((secret_props()) -> boolean())) ->
          {ok, secret_props()} |
          {error, not_found | bad_encrypt_id() | bad_usage_change() |
                  forbidden}.
replace_secret(Id, NewProps, IsSecretWritableFun) ->
    execute_on_master({?MODULE, replace_secret_internal,
                       [Id, NewProps, IsSecretWritableFun]}).

-spec replace_secret_internal(secret_id(), map(),
                              fun((secret_props()) -> boolean())) ->
          {ok, secret_props()} |
          {error, not_found | bad_encrypt_id() | bad_usage_change() |
                  forbidden | inconsistent_graph() |
                  encryption_service:stored_key_error() | bad_encrypt_id()}.
replace_secret_internal(Id, NewProps, IsSecretWritableFun) ->
    %% Make sure we have most recent information about which secrets are in use
    %% This is needed for verification of 'usage' modification
    maybe_reset_deks_counters(),
    Res =
        chronicle_compat:txn(
          fun (Txn) ->
              maybe
                  Snapshot = fetch_snapshot_in_txn(Txn),
                  {ok, OldProps} ?= get_secret(Id, Snapshot),
                  true ?= IsSecretWritableFun(OldProps),
                  Props = copy_static_props(OldProps, NewProps),
                  CurList = get_all(Snapshot),
                  {ok, FinalProps} ?= ensure_secret_encrypted_txn(Props,
                                                                  Snapshot),
                  NewList = replace_secret_in_list(FinalProps, CurList),
                  ok ?= validate_secret_in_txn(FinalProps, OldProps, Snapshot),
                  ok ?= validate_secrets_consistency(NewList),
                  {commit, [{set, ?CHRONICLE_SECRETS_KEY, NewList}], FinalProps}
              else
                  false ->
                      {abort, {error, forbidden}};
                  {error, _} = Err ->
                      {abort, Err}
              end
           end),
    case Res of
        {ok, _, ResProps} ->
            %% In order to make sure all keys are reencrypted by the time when
            %% the call is finished
            sync_with_all_node_monitors(),
            maybe_reencrypt_secrets(),
            {ok, ResProps};
        {error, _} = Error -> Error
    end.

-spec delete_secret(secret_id(), fun((secret_props()) -> boolean())) ->
          ok | {error, not_found | secret_in_use() | forbidden}.
delete_secret(Id, IsSecretWritableFun) ->
    execute_on_master({?MODULE, delete_secret_internal,
                       [Id, IsSecretWritableFun]}).

-spec delete_secret_internal(secret_id(), fun((secret_props()) -> boolean())) ->
          ok | {error, not_found | secret_in_use() | forbidden |
                       inconsistent_graph()}.
delete_secret_internal(Id, IsSecretWritableFun) ->
    %% Make sure we have most recent information about which secrets are in use
    maybe_reset_deks_counters(),
    RV = chronicle_compat:txn(
           fun (Txn) ->
               maybe
                   Snapshot = fetch_snapshot_in_txn(Txn),
                   {ok, #{id := Id} = Props} ?= get_secret(Id, Snapshot),
                   true ?= IsSecretWritableFun(Props),
                   ok ?= can_delete_secret(Props, Snapshot),
                   CurSecrets = get_all(Snapshot),
                   NewSecrets = lists:filter(
                                  fun (#{id := Id2}) -> Id2 /= Id end,
                                  CurSecrets),
                   true = (length(NewSecrets) + 1 == length(CurSecrets)),
                   ok ?= validate_secrets_consistency(NewSecrets),
                   {commit, [{set, ?CHRONICLE_SECRETS_KEY, NewSecrets}]}
               else
                   false -> {abort, {error, forbidden}};
                   {error, _} = Error -> {abort, Error}
               end
           end),
    case RV of
        {ok, _} ->
            sync_with_all_node_monitors(),
            ok;
        {error, Reason} ->
            {error, Reason}
    end.

%% Cipher should have type crypto:cipher() but it is not exported
-spec generate_raw_key(Cipher :: atom()) -> binary().
generate_raw_key(Cipher) ->
    #{key_length := Length} = crypto:cipher_info(Cipher),
    crypto:strong_rand_bytes(Length).

-spec rotate(secret_id()) -> ok | {error, not_found | not_supported |
                                          bad_encrypt_id()}.
rotate(Id) ->
    execute_on_master({?MODULE, rotate_internal, [Id]}).

-spec rotate_internal(secret_id()) -> ok | {error, not_found |
                                                   bad_encrypt_id()}.
rotate_internal(Id) ->
    case rotate_secret_by_id(Id) of
        ok ->
            %% In order to make sure all keys are reencrypted by
            %% the time when the call is finished
            sync_with_all_node_monitors(),
            maybe_reencrypt_secrets(),
            ok;
        {error, Reason} ->
            {error, Reason}
    end.

-spec get_active_key_id(secret_id()) -> {ok, key_id()} |
                                        {error, not_found | not_supported}.
get_active_key_id(SecretId) ->
    get_active_key_id(SecretId, direct).

-spec get_active_key_id(secret_id(), chronicle_snapshot()) ->
                                            {ok, key_id()} |
                                            {error, not_found | not_supported}.
get_active_key_id(SecretId, Snapshot) ->
    maybe
        {ok, SecretProps} ?= get_secret(SecretId, Snapshot),
        {ok, _} ?= get_active_key_id_from_secret(SecretProps)
    else
        {error, _} = Err -> Err
    end.

-spec sync_with_node_monitor() -> ok.
sync_with_node_monitor() ->
    %% Mostly needed to make sure local cb_cluster_secret has pushed all new
    %% keys to disk before we try using them.
    %% chronicle_kv:sync() makes sure we have the latest chronicle data
    %% chronicle_compat_events:sync() makes sure all notifications has been sent
    %% sync([node()]) makes sure local cb_cluster_secret has handled that
    %% notification
    ok = chronicle_kv:sync(kv, ?SYNC_TIMEOUT),
    chronicle_compat_events:sync(),
    gen_server:call(?MODULE, sync, ?SYNC_TIMEOUT).

-spec ensure_can_encrypt_dek_kind(secret_id(), cb_deks:dek_kind(),
                                  chronicle_snapshot()) ->
          ok | {error, not_allowed | not_found}.
ensure_can_encrypt_dek_kind(SecretId, DekKind, Snapshot) ->
    maybe
        {ok, SecretProps} ?= get_secret(SecretId, Snapshot),
        true ?= can_secret_props_encrypt_dek_kind(SecretProps, DekKind),
        ok
    else
        false -> {error, not_allowed};
        {error, not_found} -> {error, not_found}
    end.

-spec is_allowed_usage_for_secret(secret_id(), secret_usage(),
                                  chronicle_snapshot()) ->
          ok | {error, not_allowed | not_found}.
is_allowed_usage_for_secret(SecretId, Usage, Snapshot) ->
    maybe
        {ok, #{usage := AllowedUsages}} ?= get_secret(SecretId, Snapshot),
        true ?= is_allowed([Usage], AllowedUsages),
        ok
    else
        false -> {error, not_allowed};
        {error, not_found} -> {error, not_found}
    end.

-spec is_encrypted_by_secret_manager(secret_props()) -> boolean().
is_encrypted_by_secret_manager(#{type := ?GENERATED_KEY_TYPE,
                                 data := #{encrypt_by := nodeSecretManager}}) ->
    true;
is_encrypted_by_secret_manager(#{type := ?GENERATED_KEY_TYPE,
                                 data := #{keys := Keys}}) ->
    lists:any(fun (#{key := #{encrypted_by := EB}}) -> EB == undefined end,
              Keys);
is_encrypted_by_secret_manager(#{type := ?KMIP_KEY_TYPE,
                                 data := #{encrypt_by := nodeSecretManager}}) ->
    true;
is_encrypted_by_secret_manager(#{}) ->
    false.

-spec get_secret_by_kek_id_map(chronicle_snapshot()) ->
                                                    #{key_id() := secret_id()}.
get_secret_by_kek_id_map(Snapshot) ->
    maps:from_list(lists:flatmap(
                     fun (#{id := Id} = S) ->
                         [{KeyId, Id} ||  KeyId <- get_all_keys_from_props(S)]
                     end, get_all(Snapshot))).

-spec get_node_deks_info() -> #{cb_deks:dek_kind() := [cb_deks:dek()]} | retry.
get_node_deks_info() ->
    gen_server:call(?MODULE, get_node_deks_info, ?DEK_COUNTERS_UPDATE_TIMEOUT).

-spec new_key_id() -> key_id().
new_key_id() ->
    Id = misc:uuid_v4(),
    true = is_valid_key_id(Id),
    Id.

-spec is_valid_key_id(binary()) -> boolean().
is_valid_key_id(Bin) -> misc:is_valid_v4uuid(Bin).

-spec dek_drop_complete(cb_deks:dek_kind()) -> ok.
dek_drop_complete(DekKind) ->
    ?MODULE ! {dek_drop_complete, DekKind},
    ok.

-spec is_name_unique(secret_id(), string(), chronicle_snapshot()) -> boolean().
is_name_unique(Id, Name, Snapshot) ->
    lists:all(fun (#{id := Id2}) when Id == Id2 -> true;
                  (#{name := Name2}) -> Name /= Name2
              end, get_all(Snapshot)).

-spec sanitize_chronicle_cfg([secret_props()]) -> [term()].
sanitize_chronicle_cfg(Value) ->
    lists:map(fun sanitize_secret/1, Value).

%%%===================================================================
%%% gen_server callbacks
%%%===================================================================

init([Type]) ->
    Self = self(),
    EventFilter =
        fun (?CHRONICLE_SECRETS_KEY = K) -> {true, {config_change, K}};
            (Key) ->
                case Type == ?NODE_PROC andalso
                     cb_deks:dek_chronicle_keys_filter(Key) of
                    false -> false;
                    List -> {true, {dek_settings_updated, List}}
                end
        end,
    chronicle_compat_events:subscribe(
      fun (Key) ->
          case EventFilter(Key) of
              false -> ok;
              {true, M} -> Self ! M
          end
      end),
    Jobs = case Type of
               ?MASTER_PROC ->
                   [maybe_reencrypt_secrets,
                    maybe_reset_deks_counters];
               ?NODE_PROC ->
                    Kinds = cb_deks:dek_kinds_list(),
                    lists:flatmap(fun (K) ->
                                      [{maybe_update_deks, K},
                                       {garbage_collect_deks, K}]
                                  end, Kinds) ++
                   [garbage_collect_keks,
                    ensure_all_keks_on_disk] ++
                   [{maybe_reencrypt_deks, K} || K <- Kinds]
           end,
    {ok, functools:chain(#state{proc_type = Type, jobs = Jobs},
                         [run_jobs(_),
                          restart_dek_cleanup_timer(_),
                          restart_rotation_timer(_)])}.

handle_call({call, {M, F, A} = MFA}, _From,
            #state{proc_type = ?MASTER_PROC} = State) ->
    try
        ?log_debug("Calling ~p", [MFA]),
        {reply, {succ, erlang:apply(M, F, A)}, restart_rotation_timer(State)}
    catch
        C:E:ST ->
            ?log_warning("Call ~p failed: ~p:~p~n~p", [MFA, C, E, ST]),
            {reply, {exception, {C, E, ST}}, restart_rotation_timer(State)}
    end;

handle_call(sync, _From, #state{proc_type = ?NODE_PROC} = State) ->
    {reply, ok, State};

handle_call(get_node_deks_info, _From,
            #state{proc_type = ?NODE_PROC} = State) ->
    ?log_debug("Received get_node_deks_info request..."),
    NewState = run_jobs(State), %% Run jobs to make sure all deks are up to date
    maybe
        [] ?= NewState#state.jobs,
        StripKeyMaterial =
            fun (Keys) ->
                lists:map(fun (#{type := 'raw-aes-gcm', info := Info} = K) ->
                              K#{info => maps:remove(key, Info)}
                          end, Keys)
            end,

        %% Run gc for deks; it is usefull in case if a compaction has been run
        %% recently.
        NewState2 = maps:fold(fun (Kind, _, Acc) ->
                                  maybe_garbage_collect_deks(Kind, false, Acc)
                              end, NewState, NewState#state.deks),
        #state{deks = Deks} = NewState2,
        Res = maps:map(fun (_K, #{deks := Keys}) -> StripKeyMaterial(Keys) end,
                       Deks),
        {reply, Res, NewState2}
    else
        [_ | _] ->
            %% There are still unfinished jobs. That means deks in our state
            %% can be not up to date (dek might exist on disk, but this
            %% process hasn't read it yet). Since this function is used
            %% in final checks before kek removal, it should not return
            %% {ok, _} reuslt in this case
            {reply, retry, NewState}
    end;

handle_call(Request, _From, State) ->
    ?log_warning("Unhandled call: ~p", [Request]),
    {noreply, State}.

handle_cast(Msg, State) ->
    ?log_warning("Unhandled cast: ~p", [Msg]),
    {noreply, State}.

handle_info({config_change, ?CHRONICLE_SECRETS_KEY} = Msg,
            #state{proc_type = ?NODE_PROC, deks = Deks} = State) ->
    ?log_debug("Secrets in chronicle have changed..."),
    misc:flush(Msg),
    Kinds = maps:keys(Deks),
    NewJobs = [garbage_collect_keks,       %% Removal of generated keks and AWS
               ensure_all_keks_on_disk] ++ %% Adding keks + AWS key change
              [{maybe_reencrypt_deks, K} || K <- Kinds], %% Keks rotation
    {noreply, add_and_run_jobs(NewJobs, State)};

handle_info({config_change, ?CHRONICLE_SECRETS_KEY} = Msg,
            #state{proc_type = ?MASTER_PROC} = State) ->
    ?log_debug("Secrets in chronicle have changed..."),
    misc:flush(Msg),
    NewJobs = [maybe_reencrypt_secrets], %% Modififcation of encryptBy or
                                         %% rotation of secret that encrypts
                                         %% other secrets
    {noreply, add_and_run_jobs(NewJobs, State)};

handle_info({config_change, _}, State) ->
    {noreply, State};

handle_info({dek_settings_updated, KindList},
            #state{proc_type = ?NODE_PROC} = State) ->
    ?log_debug("Dek settings updated for ~p", [KindList]),
    NewState = functools:chain(
                 State,
                 [add_and_run_jobs(
                    [{maybe_update_deks, Kind} || Kind <- KindList] ++
                    [{maybe_reencrypt_deks, Kind} || Kind <- KindList],
                    _),
                  %% We should restart these timers because rotation settings
                  %% can change
                  restart_dek_rotation_timer(_),
                  restart_dek_cleanup_timer(_)]),
    {noreply, NewState};

handle_info({timer, retry_jobs}, State) ->
    ?log_debug("Retrying jobs"),
    misc:flush({timer, retry_jobs}),
    {noreply, run_jobs(State)};

handle_info({timer, rotate_keks}, #state{proc_type = ?MASTER_PROC} = State) ->
    ?log_debug("Rotate keks timer"),
    misc:flush({timer, rotate_keks}),
    CurTime = calendar:universal_time(),
    %% Intentionally update next_rotation time first, and run rotations after.
    %% Reason: in case of a crash during rotation we don't want to retry.
    %% Rotation generates keys. If we get stuck in a loop, we can generate
    %% too many keys which can lead to unpredictable results.
    IdsToRotate = update_secrets(update_next_rotation_time(CurTime, _)),
    lists:foreach(
      fun (Id) ->
          try
              ok = rotate_secret_by_id(Id)
          catch
              C:E:ST ->
                  ?log_error("Secret #~p rotation crashed: ~p:~p~n~p",
                             [Id, C, E, ST])
          end
      end, IdsToRotate),
    {noreply, restart_rotation_timer(State)};

handle_info({timer, dek_cleanup} = Msg, #state{proc_type = ?NODE_PROC,
                                               deks = DeksInfo} = State) ->
    ?log_debug("DEK cleanup timer"),
    misc:flush(Msg),
    DeksToDropFun =
        fun (Kind, StateAcc) ->
            case deks_to_drop(Kind, StateAcc) of
                [] -> {[], StateAcc};
                [_|_] ->
                    %% It is possible that these deks are already not being used
                    %% so try garbage collecting them first (as it is a
                    %% cheaper thing to do), and only if it doesn't help,
                    %% perform the drop keys precedure (which is expensive for
                    %% buckets)
                    NewStateAcc = maybe_garbage_collect_deks(Kind, false,
                                                             StateAcc),
                    {deks_to_drop(Kind, NewStateAcc), NewStateAcc}
            end
        end,
    NewState =
        maps:fold(
          fun (Kind, _KindDeks, StateAcc) ->
              {ToDrop, NewStateAcc} = DeksToDropFun(Kind, StateAcc),
              initiate_deks_drop(Kind, ToDrop, NewStateAcc)
          end, State, DeksInfo),
    {noreply, restart_dek_cleanup_timer(NewState)};

handle_info({dek_drop_complete, Kind} = Msg,
            #state{proc_type = ?NODE_PROC} = State) ->
    ?log_debug("Dek drop complete: ~p", [Kind]),
    misc:flush(Msg),
    {noreply, add_and_run_jobs([{garbage_collect_deks, Kind}], State)};

handle_info({timer, rotate_deks} = Msg, #state{proc_type = ?NODE_PROC,
                                               deks = Deks} = State) ->
    ?log_debug("Rotate DEKs timer"),
    misc:flush(Msg),
    CurDT = calendar:universal_time(),
    NewJobs = maps:fold(fun (Kind, KindDeks, Acc) ->
                            Snapshot = deks_config_snapshot(Kind),
                            case dek_rotation_needed(Kind, KindDeks, CurDT,
                                                     Snapshot) of
                                true ->
                                    ?log_debug("Dek rotation needed for ~p",
                                               [Kind]),
                                    [{maybe_update_deks, Kind} | Acc];
                                false -> Acc
                            end
                        end, [], Deks),
    {noreply, restart_dek_rotation_timer(add_and_run_jobs(NewJobs, State))};

handle_info(Info, State) ->
    ?log_warning("Unhandled info: ~p", [Info]),
    {noreply, State}.

terminate(_Reason, _State) ->
    ok.

%%%===================================================================
%%% Internal functions
%%%===================================================================

-spec rotate_secret_by_id(secret_id()) -> ok | {error, not_found |
                                                       bad_encrypt_id()}.
rotate_secret_by_id(Id) ->
    ?log_info("Rotating secret #~b", [Id]),
    case get_secret(Id) of
        {ok, SecretProps} ->
            rotate_secret(SecretProps);
        {error, Reason} ->
            ?log_error("Secret #~p rotation failed: ~p", [Id, Reason]),
            {error, Reason}
    end.

-spec rotate_secret(secret_props()) -> ok | {error, not_found |
                                                    bad_encrypt_id() |
                                                    inconsistent_graph() |
                                                    not_supported}.
rotate_secret(#{id := Id, type := ?GENERATED_KEY_TYPE}) ->
    maybe
        NewKey = generate_key(erlang:universaltime()),
        ok ?= add_active_key(Id, NewKey, _UpdateRotationTime = true),
        ok
    else
        {ok, #{}} ->
            ?log_info("Secret #~p rotation failed: not_supported", [Id]),
            {error, not_supported};
        {error, Reason} ->
            ?log_error("Secret #~p rotation failed: ~p", [Id, Reason]),
            {error, Reason}
    end;
rotate_secret(#{id := Id, type := ?AWSKMS_KEY_TYPE}) ->
    RV = chronicle_kv:transaction(
           kv, [?CHRONICLE_SECRETS_KEY],
           fun (Snapshot) ->
               maybe
                   {ok, #{type := ?AWSKMS_KEY_TYPE,
                          data := #{stored_ids := StoredIds} = Data} = Props} ?=
                       get_secret(Id, Snapshot),

                   Time = calendar:universal_time(),
                   NewStoredIds = [#{id => new_key_id(),
                                     creation_time => Time} | StoredIds],
                   NewData = Data#{stored_ids => NewStoredIds},
                   Updated = functools:chain(
                               Props,
                               [_#{data => NewData},
                                set_last_rotation_time_in_props(_, Time),
                                replace_secret_in_list(_,
                                                       get_all(Snapshot))]),
                   true = is_list(Updated),
                   ok ?= validate_secrets_consistency(Updated),
                   {commit, [{set, ?CHRONICLE_SECRETS_KEY, Updated}]}
               else
                   {error, _} = Error ->
                       {abort, Error}
               end
           end),
    case RV of
        {ok, _} -> ok;
        {error, Reason} -> {error, Reason}
    end;
rotate_secret(#{type := ?KMIP_KEY_TYPE}) ->
    {error, not_supported}.

-spec generate_key(Creation :: calendar:datetime()) -> kek_props().
generate_key(CreationDateTime) ->
    Key = generate_raw_key(?ENVELOP_CIPHER),
    #{id => new_key_id(),
      creation_time => CreationDateTime,
      key => #{type => sensitive, data => Key, encrypted_by => undefined}}.

-spec set_active_key_in_props(secret_props(), key_id()) -> secret_props().
set_active_key_in_props(#{type := ?GENERATED_KEY_TYPE,
                          data := Data} = SecretProps,
                        KeyId) ->
    SecretProps#{data => Data#{active_key_id => KeyId}}.

-spec set_keys_in_props(secret_props(), [kek_props()]) -> secret_props().
set_keys_in_props(#{type := ?GENERATED_KEY_TYPE, data := Data} = SecretProps,
                  Keys) ->
    SecretProps#{data => Data#{keys => Keys}}.

-spec copy_static_props(secret_props(), secret_props()) -> secret_props().
%% Copies properties that secret can never change
copy_static_props(#{type := Type, id := Id,
                    creation_time := CreationDT} = OldSecretProps,
                  #{type := Type} = NewSecretProps) ->
    NewSecretProps2 = NewSecretProps#{id => Id, creation_time => CreationDT},
    case NewSecretProps2 of
        #{type := ?GENERATED_KEY_TYPE} ->
            #{data := #{active_key_id := OldActiveId, keys := Keys} = OldData} =
                OldSecretProps,
            LastRotationTime = maps:get(last_rotation_time, OldData, undefined),
            functools:chain(
              NewSecretProps2,
              [set_keys_in_props(_, Keys),
               set_active_key_in_props(_, OldActiveId),
               set_last_rotation_time_in_props(_, LastRotationTime)]);
        #{type := ?AWSKMS_KEY_TYPE} ->
            #{data := #{stored_ids := StoredIds} = OldData} = OldSecretProps,
            LastRotationTime = maps:get(last_rotation_time, OldData, undefined),
            #{data := NewData} = NewSecretProps2,
            set_last_rotation_time_in_props(
              NewSecretProps2#{data => NewData#{stored_ids => StoredIds}},
              LastRotationTime);
        #{type := ?KMIP_KEY_TYPE} ->
            #{data := #{active_key := OldActive, hist_keys := HistKeys}} =
                OldSecretProps,
            #{data := #{active_key := Active} = NewData} = NewSecretProps2,
            #{id := OldActiveId,
              kmip_id := OldKmipId,
              creation_time := OldCT} = OldActive,
            #{kmip_id := NewKmipId} = Active,
            {NewFound, HistKeysCleaned} =
                misc:partitionmap(fun (#{kmip_id := I} = E)
                                                      when I == NewKmipId ->
                                          {left, E};
                                      (#{} = E) ->
                                          {right, E}
                                  end, HistKeys),

            {NewActive, NewHistKeys} =
                case {NewKmipId == OldKmipId, NewFound} of
                    {true, _} ->
                        %% New active is not actually new
                        %% Copy id and creation date from existing active key
                        {Active#{id => OldActiveId, creation_time => OldCT},
                         HistKeys};
                    {false, []} ->
                        %% We have absolutely new active key
                        %% Generate new uuid for it and set now as its creation
                        %% time
                        {Active#{id => new_key_id(),
                                 creation_time => erlang:universaltime()},
                         [OldActive | HistKeys]};
                    {false, [PrevNew]} ->
                        %% New active key doesn't match current active key,
                        %% but it is present in history keys.
                        %% Restore the existing key as active by copying its id
                        %% and creation date and remove it from the list of
                        %% history keys)
                        ExistingKeyId = maps:get(id, PrevNew),
                        ExistingKeyCT = maps:get(creation_time, PrevNew),
                        {Active#{id => ExistingKeyId,
                                 creation_time => ExistingKeyCT},
                         [OldActive | HistKeysCleaned]}
                end,
            #{key_passphrase := HiddenKP} = NewData,
            KP = #{type => sensitive,
                   data => ?UNHIDE(HiddenKP),
                   encrypted_by => undefined},
            NewSecretProps2#{data => NewData#{active_key => NewActive,
                                              hist_keys => NewHistKeys,
                                              key_passphrase => KP}};
        _ ->
            NewSecretProps2
    end.

-spec replace_secret_in_list(secret_props(), [secret_props()]) ->
                                                      [secret_props()] | false.
replace_secret_in_list(NewProps, List) ->
    Id = maps:get(id, NewProps),
    ReplaceFun = fun Replace([], _Acc) -> false;
                     Replace([Next | Rest], Acc) ->
                         case maps:get(id, Next) of
                             Id -> lists:reverse([NewProps | Acc], Rest);
                             _ -> Replace(Rest, [Next | Acc])
                         end
                 end,
    ReplaceFun(List, []).

-spec add_active_key(secret_id(), kek_props(), boolean()) ->
                        ok | {error, not_found | inconsistent_graph() |
                                     encryption_service:stored_key_error() |
                                     bad_encrypt_id()}.
add_active_key(Id, #{id := KekId} = Kek,
               true = _UpdateRotationTime) ->
    RV = chronicle_kv:transaction(
           kv, [?CHRONICLE_SECRETS_KEY],
           fun (Snapshot) ->
               maybe
                   {ok, #{type := ?GENERATED_KEY_TYPE,
                          data := SecretData} = SecretProps} ?=
                       get_secret(Id, Snapshot),
                   #{keys := CurKeks} = SecretData,
                   Time = calendar:universal_time(),
                   Updated = functools:chain(
                               SecretProps,
                               [set_keys_in_props(_, [Kek | CurKeks]),
                                set_active_key_in_props(_, KekId),
                                set_last_rotation_time_in_props(_, Time)]),
                   {ok, FinalProps} ?= ensure_secret_encrypted_txn(Updated,
                                                                   Snapshot),
                   NewList = replace_secret_in_list(FinalProps,
                                                    get_all(Snapshot)),
                   true = is_list(NewList),
                   ok ?= validate_secrets_consistency(NewList),
                   {commit, [{set, ?CHRONICLE_SECRETS_KEY, NewList}]}
               else
                   {error, _} = Error ->
                       {abort, Error}
               end
           end),

    case RV of
        {ok, _} -> ok;
        {error, Reason} -> {error, Reason}
    end.

-spec ensure_all_keks_on_disk() -> ok | {error, list()}.
ensure_all_keks_on_disk() ->
    RV = lists:map(fun (#{id := Id,
                          type := ?GENERATED_KEY_TYPE} = SecretProps)  ->
                           {Id, ensure_generated_keks_on_disk(SecretProps)};
                       (#{id := Id, type := ?AWSKMS_KEY_TYPE} = SecretProps) ->
                           {Id, ensure_aws_kek_on_disk(SecretProps)};
                       (#{id := Id, type := ?KMIP_KEY_TYPE} = SecretProps) ->
                           {Id, ensure_kmip_kek_on_disk(SecretProps)};
                       (#{id := Id}) ->
                           {Id, ok}
                   end, get_all()),
    misc:many_to_one_result(RV).

-spec ensure_generated_keks_on_disk(secret_props()) -> ok | {error, list()}.
ensure_generated_keks_on_disk(#{type := ?GENERATED_KEY_TYPE, id := SecretId,
                                data := #{keys := Keys}}) ->
    ?log_debug("Ensure all keys are on disk for secret ~p "
               "(number of keys to check: ~b)", [SecretId, length(Keys)]),
    Res = lists:map(fun (#{id := Id} = K) ->
                        {Id, ensure_kek_on_disk(K)}
                    end, Keys),
    misc:many_to_one_result(Res).

-spec ensure_kek_on_disk(kek_props()) -> ok | {error, _}.
ensure_kek_on_disk(#{id := Id,
                     key := #{type := sensitive, data := Key,
                              encrypted_by := undefined},
                     creation_time := CreationTime}) ->
    encryption_service:store_kek(Id, Key, _IsEncrypted = false, undefined,
                                 CreationTime);
ensure_kek_on_disk(#{id := Id,
                     key := #{type := encrypted, data := Key,
                              encrypted_by := {_ESecretId, EKekId}},
                     creation_time := CreationTime}) ->
    encryption_service:store_kek(Id, Key, _IsEncrypted = true, EKekId,
                                 CreationTime).

-spec ensure_aws_kek_on_disk(secret_props()) -> ok | {error, _}.
ensure_aws_kek_on_disk(#{data := Data}) ->
    #{stored_ids := StoredIds, key_arn := KeyArn, region := Region,
      profile := Profile, config_file := ConfigFile,
      credentials_file := CredsFile, use_imds := UseIMDS} = Data,

    Res = lists:map(
            fun (#{id := Id, creation_time := CreationTime}) ->
                {Id, encryption_service:store_awskey(Id, KeyArn, Region,
                                                     Profile, CredsFile,
                                                     ConfigFile, UseIMDS,
                                                     CreationTime)}
            end, StoredIds),
    misc:many_to_one_result(Res).

-spec ensure_kmip_kek_on_disk(secret_props()) -> ok | {error, _}.
ensure_kmip_kek_on_disk(#{data := #{active_key := ActiveKey,
                                    hist_keys := OtherKeys,
                                    host := Host,
                                    port := Port,
                                    key_cert_path := KeyPath,
                                    key_passphrase := Pass,
                                    encryption_approach := Appr}}) ->
    {PassData, KekId} =
        case Pass of
            #{type := sensitive, data := D, encrypted_by := undefined} ->
                {D, undefined};
            #{type := encrypted, data := D, encrypted_by := {_, KId}} ->
                {D, KId}
        end,
    Params = [{host, iolist_to_binary(Host)}, {port, Port},
              {keyCertPath, iolist_to_binary(KeyPath)},
              {keyPassphrase, base64:encode(PassData)},
              {encryptionApproach, Appr}],
    Res = lists:map(
            fun (#{id := Id, kmip_id := KmipId,
                   creation_time := CreationTime}) ->
                {Id, encryption_service:store_kmip_key(
                       Id, [{kmipId, KmipId} | Params], KekId, CreationTime)}
            end, [ActiveKey | OtherKeys]),
    misc:many_to_one_result(Res).

-spec garbage_collect_keks() -> ok.
garbage_collect_keks() ->
    AllKekIds = all_kek_ids(),
    ?log_debug("keks gc: All existing keks: ~p", [AllKekIds]),
    case encryption_service:garbage_collect_keks(AllKekIds) of
        {ok, _} -> ok;
        {error, _} = Error -> Error
    end.

-spec all_kek_ids() -> [key_id()].
all_kek_ids() ->
    lists:flatmap(get_all_keys_from_props(_), get_all()).

-spec prepare_new_secret(secret_props()) -> secret_props().
prepare_new_secret(#{type := ?GENERATED_KEY_TYPE,
                     creation_time := CurrentTime} = Props) ->
    %% Creating new auto-generated key
    #{id := KekId} = KeyProps = generate_key(CurrentTime),
    functools:chain(Props, [set_keys_in_props(_, [KeyProps]),
                            set_active_key_in_props(_, KekId)]);
prepare_new_secret(#{type := ?AWSKMS_KEY_TYPE, data := Data,
                     creation_time := CT} = Props) ->
    Props#{data => Data#{stored_ids => [#{id => new_key_id(),
                                          creation_time => CT}]}};
prepare_new_secret(#{type := ?KMIP_KEY_TYPE, data := Data,
                     creation_time := CT} = Props) ->
    #{active_key := AK, key_passphrase := HiddenKP} = Data,
    KP = #{type => sensitive,
           data => ?UNHIDE(HiddenKP),
           encrypted_by => undefined},
    Props#{data => Data#{active_key => AK#{id => new_key_id(),
                                           creation_time => CT},
                         key_passphrase => KP,
                         hist_keys => []}}.

-spec maybe_update_deks(cb_deks:dek_kind(), #state{}) ->
          {ok, #state{}} | {error, #state{}, term()}.
maybe_update_deks(Kind, #state{deks = CurDeks} = OldState) ->
    Snapshot = deks_config_snapshot(Kind),
    case call_dek_callback(encryption_method_callback, Kind, [Snapshot]) of
        {succ, {ok, EncrMethod}} ->
            %% Read DEKs if we don't have them yet
            State = #state{deks = AllDeks} =
                case maps:find(Kind, CurDeks) of
                    {ok, _} -> OldState;
                    error -> read_deks(Kind, OldState)
                end,

            #{Kind := #{active_id := ActiveId,
                        is_enabled := WasEnabled,
                        deks := Deks} = KindDeks} = AllDeks,

            CurDT = calendar:universal_time(),
            ShouldRotate = dek_rotation_needed(Kind, KindDeks, CurDT, Snapshot),

            %% Check current encryption settings and push actual active key to
            %% dek users
            case WasEnabled of

                %% On disk it is enabled but in config it is disabled:
                true when EncrMethod == disabled ->
                    ok = cb_deks:set_active(Kind, ActiveId, false),
                    NewState = read_deks(Kind, State),
                    call_set_active_cb(Kind, NewState);

                %% It is enabled on disk and in config:
                true when not ShouldRotate ->
                    %% We should push it even when nothing changes in order to
                    %% handle the scenario when we crash between
                    %% cb_deks:set_active and SetActiveCB
                    call_set_active_cb(Kind, State);

                %% It is disabled on disk and in config:
                false when EncrMethod == disabled ->
                    %% We should push it even when nothing changes in order to
                    %% handle the scenario when we crash between
                    %% cb_deks:set_active and SetActiveCB
                    call_set_active_cb(Kind, State);

                %% On disk it is disabled but in config it is enabled
                %% and we already have a dek
                false when is_binary(ActiveId) and not ShouldRotate ->
                    ok = cb_deks:set_active(Kind, ActiveId, true),
                    NewState = read_deks(Kind, State),
                    call_set_active_cb(Kind, NewState);

                %% On disk it is disabled but in config it is enabled
                %% or rotation is needed
                V when (V == false) orelse ShouldRotate ->
                    %% There is no active dek currently, but encryption is on,
                    %% we should generate a new dek
                    case generate_new_dek(Kind, Deks, EncrMethod, Snapshot) of
                        ok ->
                            NewState = read_deks(Kind, State),
                            call_set_active_cb(Kind, NewState);
                        %% Too many DEKs and encryption is being enabled
                        %% We could not create new DEK, but should still
                        %% enable the encryption
                        %% Note that ActiveId can't be undefined because
                        %% we know there are too many deks.
                        %% It should be ok to return ok if set_active_cb
                        %% succeeds.
                        {error, too_many_deks} when V == false ->
                            true = is_binary(ActiveId),
                            ok = cb_deks:set_active(Kind, ActiveId, true),
                            NewState = read_deks(Kind, State),
                            call_set_active_cb(Kind, NewState);
                        %% This just a dek rotation attempt. No need to call
                        %% cb_deks:set_active because nothing changes.
                        {error, too_many_deks} ->
                            NewState = maybe_garbage_collect_deks(Kind, false,
                                                                  State),
                            %% We will retry anyway because of rotate_deks timer
                            {ok, NewState};
                        {error, Reason} ->
                            {error, State, Reason}
                    end
            end;
        {succ, {error, not_found}} ->
            %% This entity doesn't exist anymore, nothing to do here
            %% We assume that DEKs are removed before that (for example, for
            %% buckets they are removed when the bucket dir is removed)
            %% Just make sure we don't monitor those DEKs anymore.
            %% Note that bucket can exist globally, but can be missing at this
            %% specific node.
            {ok, OldState#state{deks = maps:remove(Kind, CurDeks)}}
    end.

-spec maybe_garbage_collect_deks(cb_deks:dek_kind(), boolean(), #state{}) ->
          #state{}.
maybe_garbage_collect_deks(Kind, Force, #state{deks = DeksInfo} = State) ->
    ShouldRun =
        case maps:find(Kind, DeksInfo) of
            {ok, #{last_deks_gc_datetime := undefined}} ->
                true;
            {ok, #{last_deks_gc_datetime := DT}} ->
                %% The goal is to not call it too often
                Deadline = misc:datetime_add(DT, ?MIN_DEK_GC_INTERVAL_S),
                calendar:universal_time() > Deadline;
            error ->
                false
        end,
    case ShouldRun orelse Force of
        true ->
            case garbage_collect_deks(Kind, State) of
                {ok, NewState} -> NewState;
                {error, NewState, Error} ->
                    ?log_error("Garbage collecting DEKs failed: ~p", [Error]),
                    add_jobs([{garbage_collect_deks, Kind}], NewState)
            end;
        false ->
            State
    end.

%% Remove DEKs that are not being used anymore
%% Also update has_unencrypted_data in state
-spec garbage_collect_deks(cb_deks:dek_kind(), #state{}) ->
          {ok, #state{}} | {error, #state{}, term()}.
garbage_collect_deks(Kind, #state{deks = DeksInfo} = State) ->
    ?log_debug("Garbage collecting ~p DEKs", [Kind]),
    case maps:find(Kind, DeksInfo) of
        %% Note: we can't skip this phase even when we don't have deks
        %% (or have only one dek), because we need to update
        %% "has_unencrypted_data" info anyway
        {ok, #{} = KindDeks} ->
            case call_dek_callback(get_ids_in_use_callback, Kind, []) of
                {succ, {ok, IdList}} ->
                    UniqIdList = lists:uniq(IdList),
                    NewKindDeks = KindDeks#{has_unencrypted_data =>
                                            lists:member(?NULL_DEK, UniqIdList),
                                            last_deks_gc_datetime =>
                                            calendar:universal_time()},
                    NewState = State#state{deks = DeksInfo#{
                                                    Kind => NewKindDeks}},
                    CleanedIdList = lists:delete(?NULL_DEK, UniqIdList),
                    retire_unused_deks(Kind, CleanedIdList, NewState);
                {succ, {error, not_found}} ->
                    %% The entity that uses deks does not exist.
                    %% Ignoring it here because we assume that deks will
                    %% be removed by maybe_update_deks
                    {ok, State};
                {succ, {error, Reason}} ->
                    {error, State, Reason};
                {except, {_, E, _}} ->
                    {error, State, E}
            end;
        error ->
            {ok, State}
    end.

-spec retire_unused_deks(cb_deks:dek_kind(), [cb_deks:dek_id()], #state{}) ->
          {ok, #state{}} | {error, #state{}, term()}.
retire_unused_deks(Kind, DekIdsInUse0, State) ->
    case maybe_reset_active_file(Kind, DekIdsInUse0, State) of
        {ok, DekIdsInUse, NewState} ->
            case encryption_service:garbage_collect_keys(Kind, DekIdsInUse) of
                {ok, []} ->
                    {ok, NewState};
                {ok, _} ->
                    case cb_crypto:reset_dek_cache(Kind, cleanup) of
                        {ok, _} ->
                            {ok, read_deks(Kind, NewState)};
                        {error, Reason} ->
                            {error, NewState, Reason}
                    end;
                {error, Reason} ->
                    {error, NewState, Reason}
            end;
        {error, Reason} ->
            {error, State, Reason}
    end.

-spec maybe_reset_active_file(cb_deks:dek_kind(), [cb_deks:dek_id()],
                              #state{}) ->
          {ok, [cb_deks:dek_id()], #state{}} | {error, term()}.
%% Resets the active key file before active key removal
maybe_reset_active_file(Kind, DekIdsInUse, #state{deks = DeksInfo} = State) ->
    #{Kind := #{active_id := ActiveId, is_enabled := IsEnabled}} = DeksInfo,
    case lists:member(ActiveId, DekIdsInUse) of
        false when IsEnabled ->
            true = is_binary(ActiveId),
            ?log_error("Attempt to remove active dek ~p for ~p "
                       "while encryption is on", [ActiveId, Kind]),
            {ok, [ActiveId | DekIdsInUse], State};
        false when ActiveId == undefined ->
            {ok, DekIdsInUse, State};
        false ->
            %% This is ok to remove active dek because encryption is off
            %% and that key is not used anymore. We should remove it
            %% from "active" file though.
            maybe
                ok ?= cb_deks:set_active(Kind, undefined, false),
                {ok, _} ?= cb_crypto:reset_dek_cache(Kind, cleanup),
                {ok, DekIdsInUse, read_deks(Kind, State)}
            end;
        true ->
            {ok, DekIdsInUse, State}
    end.

-spec call_set_active_cb(cb_deks:dek_kind(), #state{}) ->
          {ok, #state{}} | {error, #state{}, term()}.
call_set_active_cb(Kind, #state{deks = AllDeks} = State) ->
    #{Kind := #{active_id := ActiveId,
                deks := Keys,
                is_enabled := IsEnabled}} = AllDeks,
    NewActiveKey =
        case IsEnabled of
            true ->
                {value, ActiveKey} = lists:search(fun (#{id := Id}) ->
                                                        Id == ActiveId
                                                  end, Keys),
                ActiveKey;
            false -> undefined
        end,
    case cb_crypto:reset_dek_cache(Kind, {new_active, NewActiveKey}) of
        {ok, _} ->
            case call_dek_callback(set_active_key_callback, Kind,
                                   [NewActiveKey]) of
                {succ, ok} ->
                    {ok, maybe_garbage_collect_deks(Kind, true, State)};
                {succ, {ok, DekIdsInUse}} ->
                    retire_unused_deks(Kind, DekIdsInUse, State);
                {succ, {error, Reason}} ->
                    {error, State, Reason};
                {except, {_, E, _}} ->
                    {error, State, E}
            end;
        {error, Reason} ->
            {error, State, Reason}
    end.

call_dek_callback(CallbackName, Kind, Args) ->
    #{CallbackName := CB} = cb_deks:dek_config(Kind),
    try erlang:apply(CB, Args) of
        RV ->
            ?log_debug("~p for ~p returned: ~0p", [CallbackName, Kind, RV]),
            {succ, RV}
    catch
        C:E:ST ->
            ?log_error("~p for ~p crash ~p:~p~n~p",
                       [CallbackName, Kind, C, E, ST]),
            {except, {C, E, ST}}
    end.

-spec read_deks(cb_deks:dek_kind(), #state{}) -> #state{}.
read_deks(Kind, #state{deks = AllDeks} = State) ->
    {ok, {ActiveDek, DekIds, Info}} = cb_deks:list(Kind),
    IsEnabled = case Info of
                    true -> true;
                    false -> false;
                    undefined -> false
                end,
    {ok, Deks} = cb_deks:read(Kind, DekIds),
    CurKindDeks = maps:get(Kind, AllDeks, #{}),
    CurDeksDropped = maps:get(deks_being_dropped, CurKindDeks, []),
    CurDeksDroppedCleaned = (CurDeksDropped -- (CurDeksDropped -- DekIds))
                            -- [?NULL_DEK || not IsEnabled],
    CurLastDropTS = maps:get(last_drop_timestamp, CurKindDeks, undefined),
    CurHasUnencrData = maps:get(has_unencrypted_data, CurKindDeks, undefined),
    GCDeksDT = maps:get(last_deks_gc_datetime, CurKindDeks, undefined),
    KindDeks = #{active_id => ActiveDek,
                 deks => Deks,
                 is_enabled => IsEnabled,
                 deks_being_dropped => CurDeksDroppedCleaned,
                 last_drop_timestamp => CurLastDropTS,
                 has_unencrypted_data => CurHasUnencrData,
                 last_deks_gc_datetime => GCDeksDT},
    functools:chain(State#state{deks = AllDeks#{Kind => KindDeks}},
                    [restart_dek_cleanup_timer(_),
                     restart_dek_rotation_timer(_)]).

-spec generate_new_dek(cb_deks:dek_kind(),
                       [cb_deks:dek()],
                       cb_deks:encryption_method(),
                       chronicle_snapshot()) -> ok | {error, _}.
generate_new_dek(Kind, CurrentDeks, EncryptionMethod, Snapshot) ->
    %% Rotation is needed but if there are too many deks already
    %% we should not generate new deks (something is wrong)
    CurrentDekNum = length(CurrentDeks),
    case CurrentDekNum < ?MAX_DEK_NUM(Kind) of
        true ->
            maybe
                ?log_debug("Generating new ~p dek, encryption is ~p...",
                           [Kind, EncryptionMethod]),
                {ok, DekId} ?= cb_deks:generate_new(Kind, EncryptionMethod,
                                                    Snapshot),
                ok ?= cb_deks:set_active(Kind, DekId, true),
                ok
            end;
        false ->
            ?log_error("Skip ~p DEK creation/rotation: "
                       "too many DEKs (~p)", [Kind, CurrentDekNum]),
            {error, too_many_deks}
    end.

-spec maybe_reencrypt_deks(cb_deks:dek_kind(), #state{}) ->
          {ok, #state{}} | {error, #state{}, term()}.
maybe_reencrypt_deks(Kind, #state{deks = Deks} = State) ->
    maybe
        {ok, #{deks := Keys}} ?= maps:find(Kind, Deks),
        Snapshot = deks_config_snapshot(Kind),
        {succ, {ok, EncrMethod}} ?= call_dek_callback(
                                      encryption_method_callback,
                                      Kind,
                                      [Snapshot]),
        RV = cb_deks:maybe_reencrypt_deks(Kind, Keys, EncrMethod, Snapshot),
        ?log_debug("Maybe reencrypt dek for ~p ~p ~p. Result: ~p",
                   [Kind, Keys, EncrMethod, RV]),
        case RV of
            no_change ->
                {ok, State};
            {changed, Errors} ->
                NewState = read_deks(Kind, State),
                case Errors of
                    [] -> {ok, NewState};
                    _ -> {error, NewState, Errors}
                end;
            {error, Error} ->
                {error, State, Error}
        end
    else
        error ->
            {ok, State};
        {succ, {error, not_found}} ->
            {ok, State}
    end.

-spec deks_config_snapshot(cb_deks:dek_kind()) -> chronicle_snapshot().
deks_config_snapshot(Kind) ->
    DekKeys = maps:get(chronicle_txn_keys, cb_deks:dek_config(Kind)),
    {ok, {Snapshot, _}} = chronicle_kv:get_snapshot(kv,
                                                    [?CHRONICLE_SECRETS_KEY |
                                                     DekKeys]),
    Snapshot.

-spec get_all_keys_from_props(secret_props()) -> [key_id()].
get_all_keys_from_props(#{type := ?GENERATED_KEY_TYPE,
                          data := #{keys := Keys}}) ->
    lists:map(fun (#{id := Id}) -> Id end, Keys);
get_all_keys_from_props(#{type := ?AWSKMS_KEY_TYPE,
                          data := #{stored_ids := StoredIds}}) ->
    lists:map(fun (#{id := Id}) -> Id end, StoredIds);
get_all_keys_from_props(#{type := ?KMIP_KEY_TYPE,
                          data := #{active_key := AK, hist_keys := Keys}}) ->
    lists:map(fun (#{id := Id}) -> Id end, [AK | Keys]).

-spec validate_secret_in_txn(secret_props(), #{} | secret_props(),
                             chronicle_snapshot()) ->
                                            ok | {error, bad_encrypt_id() |
                                                         bad_usage_change()}.
validate_secret_in_txn(NewProps, PrevProps, Snapshot) ->
    maybe
        ok ?= validate_secrets_encryption_usage_change(NewProps, PrevProps,
                                                       Snapshot),
        ok ?= validate_dek_related_usage_change(NewProps, PrevProps, Snapshot),
        ok ?= validate_encryption_secret_id(NewProps, Snapshot),
        ok ?= validate_for_config_encryption(NewProps, Snapshot),
        ok ?= validate_name_uniqueness(NewProps, Snapshot)
    end.

-spec execute_on_master({module(), atom(), [term()]}) -> term().
execute_on_master({_, _, _} = MFA) ->
    misc:wait_for_global_name(cb_cluster_secrets_master),
    case gen_server:call(?MASTER_MONITOR_NAME, {call, MFA}, 60000) of
        {succ, Res} -> Res;
        {exception, {C, E, ST}} -> erlang:raise(C, E, ST)
    end.

-spec can_delete_secret(secret_props(), chronicle_snapshot()) ->
                                            ok | {error, secret_in_use()}.
can_delete_secret(#{id := Id}, Snapshot) ->
    %% Places where this secret is used directly in encryption configuration
    EncryptionConfigUsages =
        lists:filtermap(
          fun (Kind) ->
               case call_dek_callback(encryption_method_callback, Kind,
                                      [Snapshot]) of
                  {succ, {ok, {secret, Id}}} ->
                      {true, Kind};
                  {succ, {ok, _}} ->
                      false;
                  {succ, {error, not_found}} ->
                      false
              end
          end, cb_deks:dek_kinds_list(Snapshot)),
    %% Places where this secret is used for encryption of another secrets
    Secrets = get_secrets_used_by_secret_id(Id, Snapshot),
    %% Places where this secret is used to encrypt deks (such deks can exist
    %% even if encryption is disabled for this entity)
    Deks = get_dek_kinds_used_by_secret_id(Id, Snapshot),
    SecretNames =
        lists:map(fun (SId) ->
                      {ok, #{name := SName}} = get_secret(SId, Snapshot),
                      SName
                  end, Secrets),

    case length(EncryptionConfigUsages) + length(SecretNames) + length(Deks) of
        0 -> ok;
        _ ->
            M = #{by_config => EncryptionConfigUsages,
                  by_secrets => SecretNames,
                  by_deks => Deks},
            {error, {used_by, M}}
    end.

-spec get_secrets_used_by_secret_id(secret_id(), chronicle_snapshot()) ->
                                                                [secret_id()].
get_secrets_used_by_secret_id(SecretId, Snapshot) ->
    lists:filtermap(
      fun (#{id := Id} = Props) ->
          case lists:member(SecretId, get_secrets_that_encrypt_props(Props)) of
              true -> {true, Id};
              false -> false
          end
      end, get_all(Snapshot)).

-spec get_secrets_that_encrypt_props(secret_props()) -> [secret_id()].
get_secrets_that_encrypt_props(#{type := ?GENERATED_KEY_TYPE,
                                 data := #{keys := Keys} = Data}) ->
    L = case Data of
            #{encrypt_by := clusterSecret, encrypt_secret_id := Id} -> [Id];
            #{} -> []
        end ++
        lists:filtermap(
          fun (#{key := #{encrypted_by := {Id, _}}}) -> {true, Id};
              (#{key := #{encrypted_by := undefined}}) -> false
          end, Keys),
    lists:uniq(L);
get_secrets_that_encrypt_props(#{type := ?AWSKMS_KEY_TYPE}) ->
    [];
get_secrets_that_encrypt_props(#{type := ?KMIP_KEY_TYPE,
                                 data := #{key_passphrase := KP} = Data}) ->
    L = case Data of
            #{encrypt_by := clusterSecret, encrypt_secret_id := Id} -> [Id];
            #{} -> []
        end ++
        case KP of
            #{encrypted_by := {Id, _}} -> [Id];
            #{encrypted_by := undefined} -> []
        end,
    lists:uniq(L).

-spec get_dek_kinds_used_by_secret_id(secret_id(), chronicle_snapshot()) ->
                                                        [cb_deks:dek_kind()].
get_dek_kinds_used_by_secret_id(Id, Snapshot) ->
    Map = chronicle_compat:get(Snapshot,
                               ?CHRONICLE_DEK_COUNTERS_KEY,
                               #{default => #{}}),
    maps:keys(maps:get({secret, Id}, Map, #{})).

-spec get_active_key_id_from_secret(secret_props()) -> {ok, key_id()} |
                                                       {error, not_supported}.
get_active_key_id_from_secret(#{type := ?GENERATED_KEY_TYPE,
                                data := #{active_key_id := Id}}) ->
    {ok, Id};
get_active_key_id_from_secret(#{type := ?AWSKMS_KEY_TYPE,
                                data := #{stored_ids := [#{id := Id} | _]}}) ->
    {ok, Id};
get_active_key_id_from_secret(#{type := ?KMIP_KEY_TYPE,
                                data := #{active_key := #{id := Id}}}) ->
    {ok, Id};
get_active_key_id_from_secret(#{}) ->
    {error, not_supported}.

-spec maybe_reencrypt_secrets() -> ok.
maybe_reencrypt_secrets() ->
    RV = chronicle_kv:transaction(
           kv, [?CHRONICLE_SECRETS_KEY],
           fun (Snapshot) ->
               All = get_all(Snapshot),
               KeksMap =
                   maps:from_list(
                     lists:filtermap(
                       fun (#{id := Id} = P) ->
                           maybe
                               {ok, KekId} ?= get_active_key_id_from_secret(P),
                               {true, {Id, KekId}}
                           else
                               {error, not_supported} ->
                                   false
                           end
                       end, All)),
               GetKekId = fun (SId) -> {ok, maps:get(SId, KeksMap)} end,
               {Changed, Unchanged} =
                   misc:partitionmap(
                     fun (Secret) ->
                         case maybe_reencrypt_secret_txn(Secret, GetKekId) of
                             {true, NewSecret} -> {left, NewSecret};
                             false -> {right, Secret}
                         end
                     end, All),
               case Changed of
                   [] -> {abort, no_change};
                   [_ | _] ->
                       NewSecretsList = Changed ++ Unchanged,
                       %% In theory reencryption should never lead to any
                       %% cycles in graph, but we still should check it
                       ok = validate_secrets_consistency(NewSecretsList),
                       {commit, [{set, ?CHRONICLE_SECRETS_KEY, NewSecretsList}]}
               end
           end),
    case RV of
        {ok, _} ->
            sync_with_node_monitor(),
            ok;
        no_change -> ok
    end.

-spec ensure_secret_encrypted_txn(secret_props(), chronicle_snapshot()) ->
          {ok, secret_props()} |
          {error, encryption_service:stored_key_error() | bad_encrypt_id()}.
ensure_secret_encrypted_txn(Props, Snapshot) ->
    GetKekId = get_active_key_id(_, Snapshot),
    case maybe_reencrypt_secret_txn(Props, GetKekId) of
        {true, NewProps} -> {ok, NewProps};
        false -> {ok, Props};
        {error, _} = Error -> Error
    end.

-spec maybe_reencrypt_secret_txn(secret_props(),
                                 fun ((secret_id()) -> key_id())) ->
          false | {true, secret_props()} |
          {error, encryption_service:stored_key_error() | bad_encrypt_id()}.
maybe_reencrypt_secret_txn(#{type := ?GENERATED_KEY_TYPE} = Secret, GetKekId) ->
    #{data := #{keys := Keys} = Data} = Secret,
    case maybe_reencrypt_keks(Keys, Secret, GetKekId) of
        {ok, NewKeks} -> {true, Secret#{data => Data#{keys => NewKeks}}};
        no_change -> false;
        {error, _} = Error -> Error
    end;
maybe_reencrypt_secret_txn(#{type := ?KMIP_KEY_TYPE} = Secret, GetKekId) ->
    #{data := Data} = Secret,
    Pass = maps:get(key_passphrase, Data),
    EncryptBy = maps:get(encrypt_by, Data, undefined),
    SecretId = maps:get(encrypt_secret_id, Data, undefined),

    case maybe_reencrypt_data(Pass, EncryptBy, SecretId, GetKekId) of
        {ok, NewPass} ->
            {true, Secret#{data => Data#{key_passphrase => NewPass}}};
        no_change ->
            false;
        {error, E} ->
            {error, E}
    end;
maybe_reencrypt_secret_txn(#{}, _) ->
    false.

-spec maybe_reencrypt_keks([kek_props()], secret_props(),
                           fun ((secret_id()) -> key_id())) ->
          {ok, [kek_props()]} | no_change |
          {error, encryption_service:stored_key_error() | bad_encrypt_id()}.
maybe_reencrypt_keks(Keys, #{data := SecretData}, GetKekId) ->
    try
        EncryptBy = maps:get(encrypt_by, SecretData, undefined),
        SecretId = maps:get(encrypt_secret_id, SecretData, undefined),

        RV = lists:mapfoldl(
               fun (#{key := KeyData} = Key, Acc) ->
                   case maybe_reencrypt_data(KeyData, EncryptBy, SecretId,
                                             GetKekId) of
                       no_change -> {Key, Acc};
                       {ok, NewKeyData} -> {Key#{key => NewKeyData}, changed};
                       {error, _} = E -> throw(E)
                   end
               end, no_change, Keys),
        case RV of
            {NewKeyList, changed} -> {ok, NewKeyList};
            {_, no_change} -> no_change
        end
    catch
        throw:{error, _} = Error -> Error
    end.

-spec maybe_reencrypt_data(sensitive_data(),
                           nodeSecretManager | clusterSecret,
                           undefined | secret_id(),
                           fun ((secret_id()) -> key_id())) ->
          {ok, sensitive_data()} |
          no_change |
          {error, encryption_service:stored_key_error() | bad_encrypt_id()}.
maybe_reencrypt_data(Data, EncryptBy, SecretId, GetKekId) ->
    case EncryptBy of
        nodeSecretManager -> maybe_reencrypt_data(Data, undefined);
        clusterSecret ->
            case GetKekId(SecretId) of
                {ok, KekId} ->
                    maybe_reencrypt_data(Data, {SecretId, KekId});
                {error, not_found} ->
                    {error, {encrypt_id, not_found}};
                {error, not_supported} ->
                    {error, {encrypt_id, not_allowed}}
            end
    end.

-spec maybe_reencrypt_data(sensitive_data(),
                           undefined | {secret_id(), key_id()}) ->
          {ok, sensitive_data()} |
          no_change |
          {error, encryption_service:stored_key_error()}.
%% Already encrypted with correct key
maybe_reencrypt_data(#{type := encrypted, data := _Bin,
                       encrypted_by := EncryptedBy},
                     EncryptedBy) ->
    no_change;
%% Encrypted with wrong key, should reencrypt
maybe_reencrypt_data(#{type := encrypted, data := Bin,
                       encrypted_by := {_SecretId, KekId}},
                     {NewSecretId, NewKekId}) ->
    maybe
        {ok, RawBin} ?= encryption_service:decrypt_key(Bin, KekId),
        {ok, NewBin} ?= encryption_service:encrypt_key(RawBin, NewKekId),
        {ok, #{type => encrypted, data => NewBin,
               encrypted_by => {NewSecretId, NewKekId}}}
    end;
%% Encrypted, but we want it to be unencrypted (encrypted by node SM actually)
maybe_reencrypt_data(#{type := encrypted, data := Bin,
                       encrypted_by := {_SecretId, KekId}},
                     undefined) ->
    maybe
        {ok, RawBin} ?= encryption_service:decrypt_key(Bin, KekId),
        {ok, #{type => sensitive, data => RawBin, encrypted_by => undefined}}
    end;
%% Not encrypted but should be
maybe_reencrypt_data(#{type := sensitive, data := Bin,
                       encrypted_by := undefined},
                     {NewSecretId, NewKekId}) ->
    maybe
        {ok, NewBin} ?= encryption_service:encrypt_key(Bin, NewKekId),
        {ok, #{type => encrypted, data => NewBin,
               encrypted_by => {NewSecretId, NewKekId}}}
    end;
%% Not encrypted, and that's right
maybe_reencrypt_data(#{type := sensitive, data := _Bin,
                       encrypted_by := undefined},
                     undefined) ->
    no_change.

-spec add_jobs([node_job()] | [master_job()], #state{}) -> #state{}.
add_jobs(NewJobs, #state{jobs = Jobs} = State) ->
    ensure_timer_started(retry_jobs, ?RETRY_TIME,
                         State#state{jobs = NewJobs ++ (Jobs -- NewJobs)}).

-spec add_and_run_jobs([node_job()] | [master_job()], #state{}) -> #state{}.
add_and_run_jobs(NewJobs, State) ->
    run_jobs(add_jobs(NewJobs, State)).

-spec run_jobs(#state{}) -> #state{}.
run_jobs(#state{jobs = Jobs} = State) ->
    {NewJobsReversed, NewState} =
        lists:foldl(
          fun (J, {JobsAcc, StateAcc}) ->
              ?log_debug("Starting job: ~p", [J]),
              try do(J, StateAcc) of
                  {ok, NewStateAcc} ->
                      ?log_debug("Job complete: ~p", [J]),
                      {JobsAcc, NewStateAcc};
                  ok ->
                      ?log_debug("Job complete: ~p", [J]),
                      {JobsAcc, StateAcc};
                  {error, retry} ->
                      ?log_debug("Job ~p returned 'retry'", [J]),
                      {[J | JobsAcc], StateAcc};
                  {error, NewStateAcc, retry} ->
                      ?log_debug("Job ~p returned 'retry'", [J]),
                      {[J | JobsAcc], NewStateAcc};
                  {error, NewStateAcc, Error} ->
                      ?log_error("Job ~p returned error: ~p", [J, Error]),
                      {[J | JobsAcc], NewStateAcc};
                  BadRes ->
                      ?log_error("Job ~p returned: ~p", [J, BadRes]),
                      {[J | JobsAcc], StateAcc}
              catch
                  C:E:ST ->
                      ?log_error("Job ~p failed: ~p:~p~nStacktrace:~p~n"
                                 "State: ~p", [J, C, E, ST, State]),
                      {[J | JobsAcc], StateAcc}
              end
          end, {[], State#state{jobs = []}}, Jobs),

    UpdatedState = add_jobs(lists:reverse(NewJobsReversed), NewState),
    case UpdatedState#state.jobs of
        [] -> stop_timer(retry_jobs, UpdatedState);
        [_ | _] -> restart_timer(retry_jobs, ?RETRY_TIME, UpdatedState)
    end.

-spec do(node_job() | master_job(), #state{}) ->
          ok | {ok, #state{}} | retry | {error, _} | {error, #state{}, _}.
do(garbage_collect_keks, _) ->
    garbage_collect_keks();
do(ensure_all_keks_on_disk, _) ->
    ensure_all_keks_on_disk();
do(maybe_reencrypt_secrets, _) ->
    maybe_reencrypt_secrets();
do(maybe_reset_deks_counters, _) ->
    maybe_reset_deks_counters();
do({maybe_update_deks, Kind}, State) ->
    maybe_update_deks(Kind, State);
do({garbage_collect_deks, Kind}, State) ->
    garbage_collect_deks(Kind, State);
do({maybe_reencrypt_deks, K}, State) ->
    maybe_reencrypt_deks(K, State).

-spec stop_timer(Name :: atom(), #state{}) -> #state{}.
stop_timer(Name, #state{timers = Timers} = State) ->
    case maps:get(Name, Timers) of
        undefined -> State;
        Ref when is_reference(Ref) ->
            erlang:cancel_timer(Ref),
            State#state{timers = Timers#{Name => undefined}}
    end.

-spec restart_timer(Name :: atom(), Time :: non_neg_integer(), #state{}) ->
          #state{}.
restart_timer(Name, Time, #state{timers = Timers} = State) ->
    NewState = stop_timer(Name, State),
    ?log_debug("Starting ~p timer for ~b...", [Name, Time]),
    Ref = erlang:send_after(Time, self(), {timer, Name}),
    NewState#state{timers = Timers#{Name => Ref}}.

-spec ensure_timer_started(Name :: atom(), Time :: non_neg_integer(),
                           #state{}) ->
          #state{}.
ensure_timer_started(Name, Time, #state{timers = Timers} = State) ->
    case maps:get(Name, Timers) of
        undefined -> restart_timer(Name, Time, State);
        Ref when is_reference(Ref) -> State
    end.

-spec restart_rotation_timer(#state{}) -> #state{}.
restart_rotation_timer(#state{proc_type = ?NODE_PROC} = State) ->
    State;
restart_rotation_timer(#state{proc_type = ?MASTER_PROC} = State) ->
    CurDateTime = calendar:universal_time(),
    Time = calculate_next_rotation_time(CurDateTime, get_all()),
    ?log_debug("Starting rotation timer for ~b...", [Time]),
    restart_timer(rotate_keks, Time, State).

-spec calculate_next_rotation_time(calendar:datetime(), [secret_props()]) ->
                                            TimeInMs :: non_neg_integer().
calculate_next_rotation_time(CurDateTime, Secrets) ->
    Times = [T || S <- Secrets, T <- [get_rotation_time(S)], T =/= undefined],
    time_to_first_event(CurDateTime, Times).

-spec get_rotation_time(secret_props()) -> calendar:datetime() | undefined.
get_rotation_time(#{type := ?GENERATED_KEY_TYPE,
                    data := #{auto_rotation := true,
                              next_rotation_time := Next}}) ->
    Next;
get_rotation_time(#{}) ->
    undefined.

-spec time_to_first_event(calendar:datetime(), [calendar:datetime()]) ->
          non_neg_integer().
time_to_first_event(_CurDateTime, []) -> ?MAX_RECHECK_ROTATION_INTERVAL;
time_to_first_event(CurDateTime, EventTimes) ->
    MinDateTime = lists:min(EventTimes),
    CurSec = calendar:datetime_to_gregorian_seconds(CurDateTime),
    MinSec = calendar:datetime_to_gregorian_seconds(MinDateTime),
    TimeRemains = max(?MIN_RECHECK_ROTATION_INTERVAL, (MinSec - CurSec) * 1000),
    min(?MAX_RECHECK_ROTATION_INTERVAL, TimeRemains).

-spec restart_dek_cleanup_timer(#state{}) -> #state{}.
restart_dek_cleanup_timer(#state{proc_type = ?MASTER_PROC} = State) ->
    State;
restart_dek_cleanup_timer(#state{proc_type = ?NODE_PROC,
                                 deks = DeksInfo} = State) ->
    CurDateTime = calendar:universal_time(),
    Time = calculate_next_dek_cleanup(CurDateTime, DeksInfo),
    restart_timer(dek_cleanup, Time, State).

-spec calculate_next_dek_cleanup(calendar:datetime(), #{}) ->
          TimeInMs :: non_neg_integer().
calculate_next_dek_cleanup(CurDateTime, DeksInfo) ->
    Times =
        maps:fold(
          fun (Kind, KindDeks, Acc) ->
              #{deks_being_dropped := IdsBeingDropped,
                last_drop_timestamp := LastDropTS} = KindDeks,
              DropRetryInterval = ?DEK_DROP_RETRY_TIME_S(Kind),
              case dek_expiration_times(Kind, KindDeks) of
                  {ok, ExpirationTimes} ->
                      ?log_debug("~p DEKs expiration times: ~0p, deks already "
                                 "being dropped: ~0p (last drop time: ~0p)",
                                 [Kind, ExpirationTimes, IdsBeingDropped,
                                  LastDropTS]),
                      lists:map(
                        fun ({DT, Id}) ->
                            case lists:member(Id, IdsBeingDropped) of
                                true ->
                                    LastDropDT =
                                        calendar:gregorian_seconds_to_datetime(
                                          LastDropTS),
                                    misc:datetime_add(LastDropDT,
                                                      DropRetryInterval);
                                false ->
                                    DT
                            end
                        end, ExpirationTimes) ++ Acc;
                  {error, not_found} ->
                      %% Assume there is not such entity anymore, we just
                      %% haven't removed deks yet, ignoring them
                      Acc;
                  {error, _} ->
                      [misc:datetime_add(CurDateTime,
                                         ?DEK_TIMER_RETRY_TIME_S) | Acc]
              end
          end, [], DeksInfo),
    time_to_first_event(CurDateTime, Times).

-spec get_expired_deks(cb_deks:dek_kind(), deks_info()) ->
          [cb_deks:dek_id() | ?NULL_DEK].
get_expired_deks(Kind, DeksInfo) ->
    case dek_expiration_times(Kind, DeksInfo) of
        {ok, DekExpirationTimes} ->
            CurDateTime = calendar:universal_time(),
            lists:filtermap(fun ({ExpirationTime, Id}) ->
                                case CurDateTime >= ExpirationTime of
                                    true -> {true, Id};
                                    false -> false
                                end
                            end, DekExpirationTimes);
        {error, _} -> []
    end.

-spec dek_expiration_times(cb_deks:dek_kind(), deks_info()) ->
          {ok, [{calendar:datetime(), cb_deks:dek_id() | ?NULL_DEK}]} |
          {error, _}.
dek_expiration_times(Kind, #{deks := Deks, is_enabled := IsEnabled,
                             has_unencrypted_data := HasUnencryptedData}) ->
    Snapshot = deks_config_snapshot(Kind),
    maybe
        {succ, {ok, LifeTimeInSec}} ?=
            call_dek_callback(lifetime_callback, Kind, [Snapshot]),
        {succ, {ok, DropKeysTS}} ?=
            call_dek_callback(drop_keys_timestamp_callback, Kind, [Snapshot]),
        RegularKeyTimes =
            lists:filtermap(
              fun (#{id := Id} = Key) ->
                  case dek_expiration_time(LifeTimeInSec, DropKeysTS, Key) of
                      {value, DT} -> {true, {DT, Id}};
                      false -> false
                  end
              end, Deks),
        EmptyKeyTimes =
            case DropKeysTS =/= undefined andalso IsEnabled
                 andalso HasUnencryptedData of
                true -> [{DropKeysTS, ?NULL_DEK}];
                %% This means HasUnencryptedData is undefined. We assume that
                %% bucket has unencrypted data in this case, just in case
                undefined -> [{DropKeysTS, ?NULL_DEK}];
                false -> []
            end,
        {ok, RegularKeyTimes ++ EmptyKeyTimes}
    else
        {succ, {error, not_found}} ->
            {error, not_found};
        {except, Err} ->
            {error, Err}
    end.

dek_expiration_time(undefined, undefined, _) -> false;
dek_expiration_time(undefined, DropKeysTS,
                    #{type := 'raw-aes-gcm',
                      info := #{creation_time := CreationTime}}) ->
    %% Note: We should not treat keys with CreationTime == DropKeysTS as expired
    %% because newly created keys will be treated as expired then
    case CreationTime < DropKeysTS of
        true -> {value, DropKeysTS};
        false -> false
    end;
dek_expiration_time(LifetimeInSec, undefined,
                    #{type := 'raw-aes-gcm',
                      info := #{creation_time := CreationTime}}) ->
    {value, misc:datetime_add(CreationTime, LifetimeInSec)};
dek_expiration_time(LifetimeInSec, DropKeysTS,
                    #{type := 'raw-aes-gcm',
                      info := #{creation_time := CreationTime}}) ->
    ExpDT = misc:datetime_add(CreationTime, LifetimeInSec),
    %% Note: We should not treat keys with CreationTime == DropKeysTS as expired
    %% because newly created keys will be treated as expired then
    case CreationTime < DropKeysTS of
        true -> {value, min(ExpDT, DropKeysTS)};
        false -> {value, ExpDT}
    end.

-spec restart_dek_rotation_timer(#state{}) -> #state{}.
restart_dek_rotation_timer(#state{proc_type = ?MASTER_PROC} = State) ->
    State;
restart_dek_rotation_timer(#state{proc_type = ?NODE_PROC,
                                  deks = Deks} = State) ->
    CurDT = calendar:universal_time(),
    Times =
        maps:fold(fun (Kind, KindDeks, Acc) ->
                      Snapshot = deks_config_snapshot(Kind),
                      case dek_rotation_time(Kind, KindDeks, Snapshot) of
                          {value, ExpDT} -> [ExpDT | Acc];
                          false -> Acc;
                          {error, _} ->
                              [misc:datetime_add(CurDT,
                                                 ?DEK_TIMER_RETRY_TIME_S) | Acc]
                      end
                  end, [], Deks),
    TimerTime = time_to_first_event(CurDT, Times),
    restart_timer(rotate_deks, TimerTime, State).

-spec dek_rotation_needed(cb_deks:dek_kind(), deks_info(), calendar:datetime(),
                          chronicle_snapshot()) -> boolean().
dek_rotation_needed(Kind, KindDeks, CurDT, Snapshot) ->
    case dek_rotation_time(Kind, KindDeks, Snapshot) of
        {value, ExpDT} -> ExpDT =< CurDT;
        false -> false;
        {error, _} -> false
    end.

-spec dek_rotation_time(cb_deks:dek_kind(), deks_info(),
                        chronicle_snapshot()) ->
          {value, calendar:datetime()} | false | {error, _}.
dek_rotation_time(_Kind, #{is_enabled := false}, _Snapshot) ->
    false;
dek_rotation_time(Kind, #{is_enabled := true, active_id := ActiveId,
                          deks := Keys}, Snapshot) ->
    {value, #{type := 'raw-aes-gcm',
              info := #{creation_time := CDT}}} =
        lists:search(fun (#{id := Id}) -> Id == ActiveId end, Keys),
    maybe
        %% We should remove all keys that were created before this date:
        {succ, {ok, DKTS}} ?=
            call_dek_callback(drop_keys_timestamp_callback, Kind, [Snapshot]),
        %% This is how often we should create new deks:
        {succ, {ok, RotationInt}} ?=
            call_dek_callback(rotation_int_callback, Kind, [Snapshot]),

        %% Note: We should not treat keys with CDT == DKTS as expired
        %% because newly created keys will be treated as expired then
        Candidates = [DKTS || DKTS /= undefined, CDT < DKTS] ++
                     [misc:datetime_add(CDT, RotationInt)
                      || RotationInt /= undefined],
        case Candidates of
            [] -> false;
            [_ | _] -> {value, lists:min(Candidates)}
        end
    else
        {succ, {error, not_found}} -> false;
        {succ, {error, R}} ->
            ?log_error("Failed to calculate next rotation time for dek ~p: ~p",
                       [Kind, R]),
            {error, R};
        {except, {_, E, _}} ->
            ?log_error("Failed to calculate next rotation time for dek ~p: ~p",
                       [Kind, E]),
            {error, E}
    end.

validate_for_config_encryption(#{type := T,
                                 data := #{encrypt_by := nodeSecretManager}},
                               Snapshot) when T == ?GENERATED_KEY_TYPE;
                                              T == ?KMIP_KEY_TYPE ->
    case cb_crypto:get_encryption_method(config_encryption, Snapshot) of
        {ok, disabled} -> {error, config_encryption_disabled};
        {ok, _} -> ok
    end;
validate_for_config_encryption(#{}, _Snapshot) ->
    ok.

-spec validate_encryption_secret_id(secret_props(), chronicle_snapshot()) ->
                    ok | {error, bad_encrypt_id()}.
validate_encryption_secret_id(#{type := T,
                                data := #{encrypt_by := clusterSecret,
                                          encrypt_secret_id := Id}},
                              Snapshot) when T == ?GENERATED_KEY_TYPE;
                                             T == ?KMIP_KEY_TYPE ->
    case secret_can_encrypt_secrets(Id, Snapshot) of
        ok -> ok;
        {error, not_found} -> {error, {encrypt_id, not_found}};
        {error, not_allowed} -> {error, {encrypt_id, not_allowed}}
    end;
validate_encryption_secret_id(#{}, _Snapshot) ->
    ok.

-spec secret_can_encrypt_secrets(secret_id(), chronicle_snapshot()) ->
                                        ok | {error, not_found | not_allowed}.
secret_can_encrypt_secrets(SecretId, Snapshot) ->
    case get_secret(SecretId, Snapshot) of
        {ok, #{usage := Usage}} ->
            case lists:member(secrets_encryption, Usage) of
                true -> ok;
                false -> {error, not_allowed}
            end;
        {error, not_found} -> {error, not_found}
    end.

-spec validate_secrets_encryption_usage_change(secret_props(),
                                               #{} | secret_props(),
                                               chronicle_snapshot()) ->
                                            ok | {error, bad_usage_change()}.
validate_secrets_encryption_usage_change(NewProps, PrevProps, Snapshot) ->
    validate_if_usage_removed(
      secrets_encryption, NewProps, PrevProps,
      fun (Id) ->
          case secret_encrypts_other_secrets(Id, Snapshot) of
              true -> {error, {usage, in_use}};
              false -> ok
          end
      end).

validate_dek_related_usage_change(_NewProps, PrevProps, _Snapshot)
                                                        when PrevProps == #{} ->
    ok;
validate_dek_related_usage_change(NewProps, PrevProps, Snapshot) ->
    %% Make sure that all dek users are still allowed to use this secret.
    %% For example, say this secret encrypts bucket "a" and
    %% OldProps contains {bucket_encryption, "a"} in the usage field.
    %% Then the following changes would be allowed:
    %%   1. [{bucket_encryption, "a"}] -> [{bucket_encryption, "*"}].
    %%   2. [{bucket_encryption, "a"}] -> [{bucket_encryption, "a"},
    %%                                     config_encryption].
    %% And the following changes would be disallowed:
    %%   1. [{bucket_encryption, "a"}] -> [{bucket_encryption, "b"}].
    %%   2. [{bucket_encryption, "a"}] -> [config_encryption].
    #{id := Id} = PrevProps,
    %% Check existing deks. If this secret still encrypts any deks, we should
    %% not allow corresponding usage removal
    KindsOfExistingDeks = get_dek_kinds_used_by_secret_id(Id, Snapshot),
    DekKindRequirements =
        fun (Kind) ->
            #{required_usage := Requirement} = cb_deks:dek_config(Kind),
            case lists:member(Kind, KindsOfExistingDeks) of
                true -> {true, Requirement};
                false ->
                    {succ, RV} = call_dek_callback(encryption_method_callback,
                                                   Kind,
                                                   [Snapshot]),
                    case {ok, {secret, Id}} == RV of
                        true -> {true, Requirement};
                        false -> false
                    end
            end
        end,
    InUseList = lists:filtermap(DekKindRequirements,
                                cb_deks:dek_kinds_list(Snapshot)),
    NewUsageList = maps:get(usage, NewProps, []),
    case is_allowed(InUseList, NewUsageList) of
        true -> ok;
        false -> {error, {usage, in_use}}
    end.

is_allowed(Requirements, ListOfAllowedUsages) ->
    lists:all(
      fun (Req) ->
          lists:any(
            fun (Usage) ->
                case Req of
                    Usage -> true;
                    {bucket_encryption, _} -> Usage == {bucket_encryption, "*"};
                    _ -> false
                end
            end,
            ListOfAllowedUsages)
      end, Requirements).

-spec validate_if_usage_removed(secret_usage(), secret_props(),
                                #{} | secret_props(),
                                fun((secret_id()) -> ok | {error, term()})) ->
                                            ok | {error, bad_usage_change()}.
validate_if_usage_removed(Usage, NewProps, PrevProps, Fun) ->
    PrevUsage = maps:get(usage, PrevProps, []),
    NewUsage = maps:get(usage, NewProps, []),
    case (not lists:member(Usage, NewUsage)) andalso
         (lists:member(Usage, PrevUsage)) of
        true ->
            #{id := PrevId} = PrevProps,
            Fun(PrevId);
        false ->
            ok
    end.

-spec secret_encrypts_other_secrets(secret_id(), chronicle_snapshot()) ->
                                                                    boolean().
secret_encrypts_other_secrets(Id, Snapshot) ->
    lists:any(fun (#{type := T,
                     data := #{encrypt_by := clusterSecret,
                               encrypt_secret_id := EncId}})
                                                when T == ?GENERATED_KEY_TYPE;
                                                     T == ?KMIP_KEY_TYPE ->
                      EncId == Id;
                  (#{}) ->
                      false
              end, get_all(Snapshot)).

-spec can_secret_props_encrypt_dek_kind(secret_props(), cb_deks:dek_kind()) ->
          boolean().
can_secret_props_encrypt_dek_kind(#{usage := UsageList}, DekKind) ->
    #{required_usage := Required} = cb_deks:dek_config(DekKind),
    is_allowed([Required], UsageList).

-spec update_secrets(
        fun((secret_props()) -> {value, secret_props()} | false)) ->
                                                    [UpdatedIds :: secret_id()].
update_secrets(Fun) ->
    RV = chronicle_kv:transaction(
           kv, [?CHRONICLE_SECRETS_KEY],
           fun (Snapshot) ->
               {NewList, ChangedIds} =
                   lists:mapfoldl(fun (#{id := Id} = S, Acc) ->
                                      case Fun(S) of
                                          {value, NewS} -> {NewS, [Id | Acc]};
                                          false -> {S, Acc}
                                      end
                                  end, [], get_all(Snapshot)),
               case ChangedIds of
                   [] -> {abort, no_change};
                   _ ->
                       ok = validate_secrets_consistency(NewList),
                       {commit,
                        [{set, ?CHRONICLE_SECRETS_KEY, NewList}],
                        ChangedIds}
               end
           end),
    case RV of
        {ok, _, UpdatedIds} -> UpdatedIds;
        no_change -> []
    end.

-spec update_next_rotation_time(calendar:datetime(), secret_props()) ->
                                                {value, secret_props()} | false.
update_next_rotation_time(CurTime, #{type := ?GENERATED_KEY_TYPE,
                                     data := Data} = Secret) ->
    case Data of
        #{auto_rotation := true,
          next_rotation_time := NextTime,
          rotation_interval_in_days := IntervalInD}
                                                when CurTime >= NextTime ->
            NextTimeS = calendar:datetime_to_gregorian_seconds(NextTime),
            CurTimeS = calendar:datetime_to_gregorian_seconds(CurTime),
            IntervalS = IntervalInD * ?SECS_IN_DAY,
            %% How many intervals to skip
            %% This is needed for the case when the system was down for a long
            %% time, and it's been more than 1 rotation interval since last
            %% rotation. In other words, NewNextTime must be in future.
            N = (CurTimeS - NextTimeS) div IntervalS + 1,
            NewNextTimeS = NextTimeS + N * IntervalS,
            NewNextTime = calendar:gregorian_seconds_to_datetime(NewNextTimeS),
            NewData = Data#{next_rotation_time => NewNextTime},
            {value, Secret#{data => NewData}};
        #{} ->
            false
    end;
update_next_rotation_time(_CurTime, #{}) ->
    false.

-spec set_last_rotation_time_in_props(secret_props(),
                                      calendar:datetime() | undefined) ->
                                                            secret_props().
set_last_rotation_time_in_props(Secret, undefined) ->
    Secret;
set_last_rotation_time_in_props(#{type := T,
                                  data := Data} = Secret, CurUTCTime)
                                            when T == ?GENERATED_KEY_TYPE;
                                                 T == ?AWSKMS_KEY_TYPE ->
    Secret#{data => Data#{last_rotation_time => CurUTCTime}}.

-spec sync_with_all_node_monitors() -> ok | {error, [atom()]}.
sync_with_all_node_monitors() ->
    Nodes = ns_node_disco:nodes_actual(),
    Res = erpc:multicall(Nodes, ?MODULE, sync_with_node_monitor, [],
                         ?SYNC_TIMEOUT),
    BadNodes = lists:filtermap(
                 fun ({_Node, {ok, _}}) ->
                         false;
                     ({Node, {Class, Exception}}) ->
                         ?log_error("Node ~p sync failed: ~p ~p",
                                    [Node, Class, Exception]),
                         {true, Node}
                 end, lists:zip(Nodes, Res)),
    case BadNodes of
        [] -> ok;
        _ ->
            ?log_error("Sync failed, bad nodes: ~p", [BadNodes]),
            {error, BadNodes}
    end.

%% Every time we start using a secret to encrypt a dek, we increment a counter
%% in chronicle. This is needed so we always have an understanding what secrets
%% are used for what (for example we need this information in order to be able
%% to remove KEKs safely).
%%
%% Current those counter look like the following:
%% #{ {secret, 23} => #{ chronicleDek => 14,
%%                       {bucketDek, "beer-sample"} => 2 },
%%    {secret, 26} => #{ {bucketDek, "travel-sample"} => 6 } }
%%
%% This function is supposed to cleanup these counters by basically removing
%% those dek types that don't use the secret anymore.
%% It asks all the nodes for deks information that they have. Then it calculates
%% what secrets are used to encrypt those deks. Then it removes all dek types
%% from the counters map that don't use the secret anymore.
-spec maybe_reset_deks_counters() ->
          ok | {error, retry | node_errors | missing_nodes}.
maybe_reset_deks_counters() ->
    AllNodes = ns_node_disco:nodes_wanted(),
    MissingNodes = AllNodes -- ns_node_disco:nodes_actual(),
    case MissingNodes of
        [] ->
            case chronicle_kv:get(kv, ?CHRONICLE_DEK_COUNTERS_KEY) of
                {ok, {OldMap, _}} when OldMap == #{} ->
                    ok;
                {ok, {OldMap, _}} ->
                    %% Each node returns information about its deks
                    %% So we can calculate which secrets are actually in use
                    %% and update that information in chronicle
                    Res = erpc:multicall(AllNodes, ?MODULE, get_node_deks_info,
                                         [], ?DEK_COUNTERS_UPDATE_TIMEOUT),
                    {NonErrors, Errors} =
                        misc:partitionmap(fun ({N, {ok, R}}) -> {left, {N, R}};
                                              ({N, E}) -> {right, {N, E}}
                                          end, lists:zip(AllNodes, Res)),
                    {SuccRes, Retries} =
                        misc:partitionmap(
                          fun ({N, retry}) -> {right, N};
                              ({_N, R}) -> {left, R}
                          end, NonErrors),
                    case {Errors, Retries} of
                        {[], []} ->
                            %% Merge results from all nodes into one map
                            DekInfo = lists:foldl(
                                        fun (M, Acc) ->
                                            maps:merge_with(fun (_, V1, V2) ->
                                                                V1 ++ V2
                                                            end, M, Acc)
                                        end, #{}, SuccRes),
                            reset_dek_counters(OldMap, DekInfo);
                        {[], _} ->
                            ?log_debug("Some nodes returned retry: ~p~n"
                                       "All responses: ~p", [Retries, Res]),
                            {error, retry};
                        {Errors, []} ->
                            ?log_error("Failed to update deks counters because "
                                       "some nodes returns errors: ~p~n"
                                       "All responses: ~p", [Errors, Res]),
                            {error, node_errors}
                    end;
                {error, not_found} ->
                    %% Nothing to update yet
                    ok
            end;
        _ ->
            ?log_debug("Skipping deks counters update because some nodes "
                       "are missing: ~p", [MissingNodes]),
            {error, missing_nodes}
    end.

-spec reset_dek_counters(
        #{EncryptionMethod := Counters},
        #{cb_deks:dek_kind() => [cb_deks:dek()]}) ->
        ok when EncryptionMethod :: {secret, secret_id()} | encryption_service,
                Counters :: #{cb_deks:dek_kind() := non_neg_integer()}.
reset_dek_counters(OldCountersMap, ActualDeksUsageInfo) ->
    Res =
        chronicle_kv:transaction(
          kv, [?CHRONICLE_SECRETS_KEY, ?CHRONICLE_DEK_COUNTERS_KEY],
          fun (Snapshot) ->
              reset_dek_counters_txn(OldCountersMap, ActualDeksUsageInfo,
                                     Snapshot)
          end),

    case Res of
        nothing_changed -> ok;
        {ok, _} -> ok
    end.

reset_dek_counters_txn(OldCountersMap, ActualDeksUsageInfo, Snapshot) ->
    KeksToSecrets = get_secret_by_kek_id_map(Snapshot),
    GetEncryptionMethod =
        fun (#{type := 'raw-aes-gcm',
               info := #{encryption_key_id := <<"encryptionService">>}}) ->
                {ok, encryption_service};
             (#{type := 'raw-aes-gcm',
               info := #{encryption_key_id := CurKekId}}) ->
                case maps:find(CurKekId, KeksToSecrets) of
                    {ok, SId} -> {ok, {secret, SId}};
                    error -> error
                end
        end,

    %% Turn #{DekKind => [Dek]} map into #{DekKind => [{secret, SecretId}]} map
    %% It represents information about which dek type uses which secret.
    SecretInfo =
        maps:map(fun (_K, Deks) ->
                     lists:filtermap(
                       fun (D) ->
                           case GetEncryptionMethod(D) of
                               {ok, Res} -> {true, Res};
                               error ->
                                   ?log_error("orphaned dek: ~p", [D]),
                                   false
                           end
                       end, Deks)
                 end, ActualDeksUsageInfo),

    DekStillUsesSecretId =
        fun (DekKind, SecretId) ->
            SecretsIdsList = maps:get(DekKind, SecretInfo, []),
            lists:member(SecretId, SecretsIdsList)
        end,

    %% Filter out those dek types that do not use that secretId anymore.
    FilterCountersForSecret =
        fun (SecretId, Map) -> %% The Map variable here represents all
                               %% dek types that still uses that secret
            maybe
                {ok, OldMap} ?= maps:find(SecretId, OldCountersMap),
                NewMap = maps:filter(
                           fun (DekKind, Counter) ->
                               DekStillUsesSecretId(DekKind, SecretId) orelse
                               %% Checking if counter has changed since before
                               %% we started deks info aggregation;
                               %% If so, that means that something started just
                               %% started using it and we should not remove it
                               %% from the map
                               (Counter /= maps:get(DekKind, OldMap, 0))
                           end, Map),
                case maps:size(NewMap) of
                    0 -> false;
                    _ -> {true, NewMap}
                end
            else
                %% This SecretId was missing in the first check, this means
                %% that something just started using that secret
                error -> true
            end
        end,

    Old = chronicle_compat:get(Snapshot,
                               ?CHRONICLE_DEK_COUNTERS_KEY,
                               #{default => #{}}),
    New = maps:filtermap(FilterCountersForSecret, Old),
    case New == Old of
        true -> {abort, nothing_changed};
        false -> {commit, [{set, ?CHRONICLE_DEK_COUNTERS_KEY, New}]}
    end.

%% Fetches a snapshot in transaction with all dek related chronicle keys,
%% and all secrets related chronicle keys.
fetch_snapshot_in_txn(Txn) ->
    BucketListSnapshot = chronicle_compat:txn_get_many(
                           [ns_bucket:root()], Txn),
    DeksRelatedSnapshot =
        lists:foldl(
          fun (Kind, Acc) ->
              L = maps:get(chronicle_txn_keys, cb_deks:dek_config(Kind)),
              New = chronicle_compat:txn_get_many(L, Txn),
              maps:merge(Acc, New)
          end,
          BucketListSnapshot,
          cb_deks:dek_kinds_list(BucketListSnapshot)),
    SecretsSnapshot = chronicle_compat:txn_get_many(
                        [?CHRONICLE_SECRETS_KEY,
                         ?CHRONICLE_DEK_COUNTERS_KEY,
                         ?CHRONICLE_NEXT_ID_KEY],
                        Txn),
    maps:merge(DeksRelatedSnapshot, SecretsSnapshot).

-spec deks_to_drop(cb_deks:dek_kind(), deks_info() | #state{}) ->
          [cb_deks:dek_id() | ?NULL_DEK].
deks_to_drop(Kind, #state{deks = DeksInfo}) ->
    case maps:find(Kind, DeksInfo) of
        {ok, KindDeks} -> deks_to_drop(Kind, KindDeks);
        error -> []
    end;
deks_to_drop(Kind, KindDeks) ->
    CurTime = calendar:universal_time(),
    NowS = calendar:datetime_to_gregorian_seconds(CurTime),
    ExpiredIds = get_expired_deks(Kind, KindDeks),
    #{deks_being_dropped := AlreadyBeingDropped,
      last_drop_timestamp := LastDropS} = KindDeks,
    DropRetryInterval = ?DEK_DROP_RETRY_TIME_S(Kind),
    LastDropTime = case LastDropS of
                       undefined -> undefined;
                       _ -> calendar:gregorian_seconds_to_datetime(LastDropS)
                   end,
    ?log_debug("The following ~p DEKs has expired: ~p~n"
               "Among them DEKs that are already being dropped: ~p~n"
               "Last drop attempt time: ~p",
               [Kind, ExpiredIds, AlreadyBeingDropped, LastDropTime]),
    %% If we have already started dropping something, we should continue
    %% even if it is not "expired" anymore.
    AllExpired = lists:usort(ExpiredIds ++ AlreadyBeingDropped),
    ToDrop =
        maybe
            #{is_enabled := true, active_id := ActiveId} ?= KindDeks,
            true ?= lists:member(ActiveId, AllExpired),
            ?log_error("Active DEK (~p) has expired for "
                       "~p (ignoring attempt to drop it)",
                       [ActiveId, Kind]),
            AllExpired -- [ActiveId]
        else
            #{is_enabled := false} ->
                AllExpired;
            false ->
                AllExpired
        end,
    ShouldAttemptDrop =
        case ToDrop -- AlreadyBeingDropped of
            [_|_] ->
                true; %% there are new deks in the list
            [] when ToDrop == [] ->
                false; %% no deks to drop
            [] when NowS > LastDropS + DropRetryInterval ->
                true; %% no new deks to drop, but it's been a while
                      %% since last drop attempt; will retry
            [] ->
                false %% no new deks to drop
        end,
    case ShouldAttemptDrop of
        true -> ToDrop;
        false -> []
    end.

-spec initiate_deks_drop(cb_deks:dek_kind(), [cb_deks:dek_id() | ?NULL_DEK],
                         #state{}) -> #state{}.
initiate_deks_drop(_Kind, [], #state{} = State) -> State;
initiate_deks_drop(Kind, IdsToDrop0, #state{deks = DeksInfo} = State0) ->
    CurTime = calendar:universal_time(),
    NowS = calendar:datetime_to_gregorian_seconds(CurTime),
    #{Kind := KindDeks} = DeksInfo,
    IdsToDrop =
        case DeksInfo of
            #{Kind := #{is_enabled := true}} ->
                %% We have at least one expired dek, and encryption is enabled,
                %% it is probably time to encrypt data that is not encrypted yet
                %% (if there is such data)
                lists:uniq(IdsToDrop0 ++ [?NULL_DEK]);
            #{Kind := #{is_enabled := false}} ->
                %% If encryption is disabled we should never try dropping empty
                %% dek because it beasically means "encrypt everything", which
                %% doesn't make sense in this case
                lists:uniq(IdsToDrop0) -- [?NULL_DEK]
        end,

    ?log_debug("Trying to drop ~p DEKs: ~0p", [Kind, IdsToDrop]),
    case call_dek_callback(drop_callback, Kind, [IdsToDrop]) of
        {succ, {ok, Res}} ->
            NewKindDeks = KindDeks#{deks_being_dropped => IdsToDrop,
                                    last_drop_timestamp => NowS},
            State = State0#state{deks = DeksInfo#{Kind => NewKindDeks}},
            case Res of
                done ->
                    %% 'done' means that all all ids have been dropped and it is
                    %% safe to remove them
                    AllIds = [Id || #{id := Id} <- maps:get(deks, KindDeks)],
                    IdsInUse = AllIds -- IdsToDrop,
                    case retire_unused_deks(Kind, IdsInUse, State) of
                        {ok, NewState} ->
                            NewState;
                        {error, NewState, Reason} ->
                            ?log_error("Failed to retire ~p deks: ~p. "
                                       "Ignoring. Will garbage collect later",
                                       [Kind, Reason]),
                            NewState
                    end;
                started ->
                    State
            end;
        {succ, {error, not_found}} -> State0;
        {succ, {error, retry}} -> State0; %% compaction daemon not started yet
        {succ, {error, Reason}} ->
            ?log_error("drop_callback for ~p returned error: ~p",
                       [Kind, Reason]),
            State0;
        {except, _} ->
            State0
    end.

-spec validate_name_uniqueness(secret_props(), chronicle_snapshot()) ->
          ok | {error, name_not_unique}.
validate_name_uniqueness(#{id := Id, name := Name}, Snapshot) ->
    case is_name_unique(Id, Name, Snapshot) of
        true -> ok;
        false -> {error, name_not_unique}
    end.

-spec validate_secrets_consistency([secret_props()]) ->
          ok | {error, inconsistent_graph()}.
validate_secrets_consistency(Secrets) ->
    %% Make sure secrets graph has no cycles and all ids that are
    %% mentioned in props are actually present
    G = digraph:new([acyclic]),
    try
        lists:foreach(fun (#{id := Id}) -> digraph:add_vertex(G, Id) end,
                      Secrets),
        Res = lists:foldl(
                fun (#{}, {error, _} = Acc) -> Acc;
                    (#{id := Id} = P, ok) ->
                      lists:foldl(
                        fun (_Id2, {error, _} = Acc2) -> Acc2;
                            (Id2, ok) ->
                            case digraph:add_edge(G, Id2, Id) of
                                ['$e' | _] -> ok;
                                {error, _} = E -> E
                            end
                        end, ok, get_secrets_that_encrypt_props(P))
                end, ok, Secrets),
        case Res of
            ok -> ok;
            {error, {bad_edge, Ids}} -> {error, {cycle, Ids}};
            {error, {bad_vertex, Id}} -> {error, {unknown_id, Id}}
        end
    after
        digraph:delete(G)
    end.

-spec sanitize_secret(secret_props()) -> term().
sanitize_secret(#{type := ?GENERATED_KEY_TYPE, data := Data} = S) ->
    #{keys := Keys} = Data,
    NewKeys = lists:map(fun (#{key := K} = Key) ->
                                Key#{key => sanitize_sensitive_data(K)}
                        end, Keys),
    S#{data => Data#{keys => NewKeys}};
sanitize_secret(#{type := ?KMIP_KEY_TYPE, data := Data} = S) ->
    #{key_passphrase := D} = Data,
    S#{data => Data#{key_passphrase => sanitize_sensitive_data(D)}};
sanitize_secret(#{type := ?AWSKMS_KEY_TYPE} = S) ->
    S.

sanitize_sensitive_data(#{type := sensitive, data := D} = Data) ->
    Data#{data => chronicle_kv_log:sanitize_value(D)};
sanitize_sensitive_data(#{type := encrypted} = Data) ->
    Data.

-ifdef(TEST).
replace_secret_in_list_test() ->
    ?assertEqual(false, replace_secret_in_list(#{id => 3, p => 5}, [])),
    ?assertEqual(false,
                 replace_secret_in_list(#{id => 3, p => 5}, [#{id => 4}])),
    ?assertEqual([#{id => 4, p => 1}, #{id => 3, p => 5}, #{id => 1}],
                 replace_secret_in_list(
                   #{id => 3, p => 5},
                   [#{id => 4, p => 1}, #{id => 3, p => 6}, #{id => 1}])).

test_secret(NextTime, Interval, AutoRotation) ->
     #{type => ?GENERATED_KEY_TYPE,
       data => #{auto_rotation => AutoRotation,
                 rotation_interval_in_days => Interval,
                 next_rotation_time => NextTime}}.

calculate_next_rotation_time_test() ->
    CurTime = {{2016, 09, 30}, {16, 00, 00}},
    Secret = ?cut(test_secret(_1, 1, _2)),
    Calc = fun (List) -> calculate_next_rotation_time(CurTime, List) end,
    Min = ?MIN_RECHECK_ROTATION_INTERVAL,
    MinSec = Min div 1000,
    Max = ?MAX_RECHECK_ROTATION_INTERVAL,
    MaxSec = Max div 1000,
    Future = ?cut(misc:datetime_add(CurTime, _)),
    Past = ?cut(misc:datetime_add(CurTime, -(_))),
    ?assertEqual(Max, Calc([])),
    ?assertEqual(Min, Calc([Secret(CurTime, true)])),
    ?assertEqual(Max, Calc([Secret(CurTime, false)])),
    %% next rotation in future:
    ?assertEqual(Min, Calc([Secret(Future(MinSec - 1), true)])),
    ?assertEqual(Min + 1000, Calc([Secret(Future(MinSec + 1), true)])),
    ?assertEqual(Max, Calc([Secret(Future(MaxSec + 1), true)])),
    ?assertEqual(Max - 1000, Calc([Secret(Future(MaxSec - 1), true)])),
    %% next rotation in the past:
    ?assertEqual(Min, Calc([Secret(Past(1), true)])),
    ?assertEqual(Min, Calc([Secret(Past(?SECS_IN_DAY*5), true)])),

    ?assertEqual(Min + 11000,
                 Calc([Secret(Future(MinSec + 20), true),
                       Secret(Future(MinSec + 3),  false),
                       Secret(Future(MinSec + 12), true),
                       Secret(Future(MinSec + 11), true),
                       Secret(Past(1),             false),
                       Secret(Future(MinSec + 23), true)])).

update_next_rotation_time_test() ->
    CurTime = {{2016, 09, 30}, {16, 00, 00}},
    Calc = fun (NextTime, Interval, AutoRotation) ->
               S = test_secret(NextTime, Interval, AutoRotation),
               case update_next_rotation_time(CurTime, S) of
                   {value, #{data := #{next_rotation_time := NewDate}} = Res} ->
                       #{data := D} = S,
                       %% Making sure nothing but next_rotation_time has changed
                       ?assertEqual(
                         S#{data => D#{next_rotation_time => NewDate}}, Res),
                       NewDate;
                   false -> false
               end
           end,
    D = ?SECS_IN_DAY,
    Future = ?cut(misc:datetime_add(CurTime, _)),
    Past = ?cut(misc:datetime_add(CurTime, -(_))),

    ?assertEqual(false,             Calc(CurTime, 3, false)),
    ?assertEqual(false,             Calc(Past(1), 3, false)),
    ?assertEqual(false,             Calc(Future(1), 3, false)),
    ?assertEqual(Future(3 * D),     Calc(CurTime,   3, true)),
    ?assertEqual(false,             Calc(Future(1), 3, true)),
    ?assertEqual(Future(3 * D - 1), Calc(Past(1), 3, true)),
    ?assertEqual(Future(2 * D),     Calc(Past(D), 3, true)),
    ?assertEqual(Future(D),         Calc(Past(2 * D), 3, true)),
    ?assertEqual(Future(3 * D),     Calc(Past(3 * D), 3, true)),
    ?assertEqual(Future(3 * D - 1), Calc(Past(3 * D + 1), 3, true)),
    ?assertEqual(Future(1),         Calc(Past(3 * D - 1), 3, true)),
    ?assertEqual(Future(3 * D - 1), Calc(Past(12 * D + 1), 3, true)),
    ?assertEqual(Future(1),         Calc(Past(12 * D - 1), 3, true)).

-endif.
