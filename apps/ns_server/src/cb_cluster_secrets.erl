%% @author Couchbase <info@couchbase.com>
%% @copyright 2024-Present Couchbase, Inc.
%%
%% Use of this software is governed by the Business Source License included in
%% the file licenses/BSL-Couchbase.txt.  As of the Change Date specified in that
%% file, in accordance with the Business Source License, use of this software
%% will be governed by the Apache License, Version 2.0, included in the file
%% licenses/APL2.txt.
%%
-module(cb_cluster_secrets).

-behaviour(gen_server).

-include("ns_common.hrl").
-include_lib("ns_common/include/cut.hrl").
-include("cb_cluster_secrets.hrl").
-ifdef(TEST).
-include_lib("eunit/include/eunit.hrl").
-endif.

-define(MASTER_MONITOR_NAME, {via, leader_registry, cb_cluster_secrets_master}).
-define(RETRY_TIME, ?get_param(retry_time, 10000)).
-define(SYNC_TIMEOUT, ?get_timeout(sync, 60000)).
-define(NODE_PROC, node_monitor_process).
-define(MASTER_PROC, master_monitor_process).
-define(DEK_COUNTERS_UPDATE_TIMEOUT, ?get_timeout(counters_update, 30000)).
-define(DEK_TIMER_RETRY_TIME_S, ?get_param(dek_retry_interval, 60)).
-define(DEK_DROP_RETRY_TIME_S(Kind),
        ?get_param({dek_removal_min_interval, Kind}, 60*60*3)).
-define(MAX_DEK_NUM(Kind), ?get_param({max_dek_num, Kind}, 50)).
-define(MIN_DEK_GC_INTERVAL_S, ?get_param(min_dek_gc_interval, 60)).

-ifndef(TEST).
-define(MIN_RECHECK_ROTATION_INTERVAL, ?get_param(min_rotation_recheck_interval,
                                                  1000)).
-define(MAX_RECHECK_ROTATION_INTERVAL, ?get_param(rotation_recheck_interval,
                                                  ?SECS_IN_DAY*1000)).
-else.
-define(MIN_RECHECK_ROTATION_INTERVAL, 1000).
-define(MAX_RECHECK_ROTATION_INTERVAL, ?SECS_IN_DAY*1000).
-endif.

%% API
-export([start_link_node_monitor/0,
         start_link_master_monitor/0,
         add_new_secret/1,
         replace_secret/3,
         delete_secret/2,
         get_all/0,
         get_all/1,
         get_secret/1,
         get_secret/2,
         get_active_key_id/1,
         get_active_key_id/2,
         rotate/1,
         test/1,
         get_secret_by_kek_id_map/1,
         ensure_can_encrypt_dek_kind/3,
         is_allowed_usage_for_secret/3,
         is_encrypted_by_secret_manager/1,
         generate_raw_key/1,
         sync_with_all_node_monitors/0,
         new_key_id/0,
         is_valid_key_id/1,
         dek_drop_complete/1,
         is_name_unique/3,
         sanitize_chronicle_cfg/1,
         merge_dek_infos/2,
         format_dek_issues/1,
         chronicle_transaction/2]).

%% gen_server callbacks
-export([init/1, handle_call/3, handle_cast/2, handle_info/2,
         terminate/2]).

%% Can be called by other nodes:
-export([add_new_secret_internal/1,
         replace_secret_internal/3,
         rotate_internal/1,
         test_internal/1,
         sync_with_node_monitor/0,
         delete_secret_internal/2,
         get_node_deks_info/0]).

-record(state, {proc_type :: ?NODE_PROC | ?MASTER_PROC,
                jobs :: [node_job()] | [master_job()],
                timers = #{retry_jobs => undefined,
                           rotate_keks => undefined,
                           dek_cleanup => undefined,
                           rotate_deks => undefined}
                         :: #{atom() := reference() | undefined},
                deks = undefined :: #{cb_deks:dek_kind() := deks_info()} |
                                    undefined,
                kek_hashes_on_disk = #{} :: #{secret_id() := integer()}}).

-export_type([secret_id/0, key_id/0, chronicle_snapshot/0, secret_usage/0]).

-type secret_props() ::
    #{id := secret_id(),
      name := string(),
      creation_time := calendar:datetime(),
      type := secret_type(),
      usage := [secret_usage()],
      data := autogenerated_key_data() | aws_key_data() | kmip_key_data()}.
-type secret_type() :: ?GENERATED_KEY_TYPE | ?AWSKMS_KEY_TYPE | ?KMIP_KEY_TYPE.
-type secret_usage() :: {bucket_encryption, BucketName :: string()} |
                        secrets_encryption | cb_crypto:encryption_type().
-type autogenerated_key_data() :: #{auto_rotation := boolean(),
                                    rotation_interval_in_days := pos_integer(),
                                    next_rotation_time := calendar:datetime(),
                                    last_rotation_time := calendar:datetime(),
                                    active_key_id := key_id(),
                                    keys := [kek_props()],
                                    encrypt_by := nodeSecretManager |
                                                  clusterSecret,
                                    encrypt_secret_id := secret_id() |
                                                         ?SECRET_ID_NOT_SET}.
-type kek_props() :: #{id := key_id(),
                       creation_time := calendar:datetime(),
                       key_material := sensitive_data()}.
-type sensitive_data() :: #{type := sensitive | encrypted,
                            data := binary(),
                            encrypted_by := undefined | {secret_id(), key_id()}}.
-type aws_key_data() :: #{key_arn := string(),
                          region := string(),
                          profile := string(),
                          config_file := string(),
                          credentials_file := string(),
                          use_imds := boolean(),
                          stored_ids :=
                            [#{id := key_id(),
                               creation_time := calendar:datetime()}],
                          last_rotation_time := calendar:datetime()}.
-type kmip_key_data() :: #{host := string(),
                           port := 1..65535,
                           key_cert_path := string(),
                           key_passphrase := sensitive_data(),
                           encryption_approach := use_get | use_encrypt_decrypt,
                           active_key := kmip_key(),
                           hist_keys := [kmip_key()],
                           encrypt_by := nodeSecretManager |
                                         clusterSecret,
                           encrypt_secret_id := secret_id() |
                                                ?SECRET_ID_NOT_SET}.
-type kmip_key() :: #{id := key_id(),
                      kmip_id := binary(),
                      creation_time := calendar:datetime()}.
-type secret_id() :: non_neg_integer().
-type key_id() :: uuid().
-type chronicle_snapshot() :: direct | map().
-type uuid() :: binary(). %% uuid as binary string
-type node_job() :: garbage_collect_keks |
                    ensure_all_keks_on_disk |
                    {dek_job(), cb_deks:dek_kind()}.

-type dek_job() :: maybe_update_deks | garbage_collect_deks |
                   maybe_reencrypt_deks.

-type master_job() :: maybe_reencrypt_secrets | maybe_reset_deks_counters.

-type bad_encrypt_id() :: {encrypt_id, not_allowed | not_found}.
-type bad_usage_change() :: {usage, in_use}.
-type inconsistent_graph() :: {cycle, [secret_id()]} |
                              {unknown_id, secret_id()}.

-type secret_in_use() :: {used_by, #{by_config := [cb_deks:dek_kind()],
                                     by_secret := [secret_id()],
                                     by_deks := [cb_deks:dek_kind()]}}.

-type deks_info() :: #{active_id := cb_deks:dek_id() | undefined,
                       deks := [cb_deks:dek()],
                       is_enabled := boolean(),
                       deks_being_dropped := [cb_deks:dek_id() | ?NULL_DEK],
                       has_unencrypted_data := undefined | boolean(),
                       last_deks_gc_datetime := undefined | calendar:datetime(),
                       last_drop_timestamp := undefined | non_neg_integer(),
                       statuses := #{node_job() := ok | retry | {error, _}}}.

-type external_dek_info() :: #{data_status := encrypted |
                                              partially_encrypted |
                                              unencrypted | unknown,
                               issues := [{dek_issue(), pending | failed}],
                               deks := [cb_deks:dek()],
                               dek_num := non_neg_integer(),
                               oldest_dek_datetime := calendar:datetime()}.

-type dek_issue() :: dek_job() | proc_communication | node_info.

%%%===================================================================
%%% API
%%%===================================================================

%% Starts on each cluster node
-spec start_link_node_monitor() -> {ok, pid()}.
start_link_node_monitor() ->
    gen_server:start_link({local, ?MODULE}, ?MODULE, [?NODE_PROC], []).

%% Starts on the master node only
-spec start_link_master_monitor() -> {ok, pid()}.
start_link_master_monitor() ->
    misc:start_singleton(gen_server, start_link,
                         [?MASTER_MONITOR_NAME, ?MODULE, [?MASTER_PROC], []]).

-spec get_all() -> [secret_props()].
get_all() -> get_all(direct).

-spec get_all(chronicle_snapshot()) -> [secret_props()].
get_all(Snapshot) ->
    chronicle_compat:get(Snapshot, ?CHRONICLE_SECRETS_KEY, #{default => []}).

-spec get_secret(secret_id()) -> {ok, secret_props()} | {error, not_found}.
get_secret(SecretId) -> get_secret(SecretId, direct).

-spec get_secret(secret_id(), chronicle_snapshot()) ->
                                    {ok, secret_props()} | {error, not_found}.
get_secret(SecretId, Snapshot) when is_integer(SecretId) ->
    SearchFun = fun (#{id := Id}) -> SecretId == Id end,
    case lists:search(SearchFun, get_all(Snapshot)) of
        {value, Props} ->
            {ok, Props};
        false ->
            {error, not_found}
    end.

-spec add_new_secret(secret_props()) ->
          {ok, secret_props()} |
          {error, not_supported |
                  bad_encrypt_id() |
                  bad_usage_change() |
                  inconsistent_graph() |
                  encryption_service:stored_key_error() |
                  no_quorum}.
add_new_secret(Props) ->
    execute_on_master({?MODULE, add_new_secret_internal, [Props]}).

-spec add_new_secret_internal(secret_props()) ->
          {ok, secret_props()} |
          {error, not_supported |
                  bad_encrypt_id() |
                  bad_usage_change() |
                  inconsistent_graph() |
                  encryption_service:stored_key_error() |
                  no_quorum}.
add_new_secret_internal(Props) ->
    CurrentDateTime = erlang:universaltime(),
    PropsWTime = Props#{creation_time => CurrentDateTime},
    RV = chronicle_compat_txn(
           fun (Txn) ->
               Snapshot = fetch_snapshot_in_txn(Txn),
               CurList = get_all(Snapshot),
               NextId = chronicle_compat:get(Snapshot, ?CHRONICLE_NEXT_ID_KEY,
                                             #{default => 0}),
               PropsWId = PropsWTime#{id => NextId},
               maybe
                   Prepared = prepare_new_secret(PropsWId),
                   {ok, FinalProps} ?= ensure_secret_encrypted_txn(Prepared,
                                                                   Snapshot),
                   NewList = [FinalProps | CurList],
                   ok ?= validate_secret_in_txn(FinalProps, #{}, Snapshot),
                   ok ?= validate_secrets_consistency(NewList),
                   {commit, [{set, ?CHRONICLE_SECRETS_KEY, NewList},
                             {set, ?CHRONICLE_NEXT_ID_KEY, NextId + 1}],
                    FinalProps}
               else
                   {error, Reason} -> {abort, {error, Reason}}
               end
            end),
    case RV of
        {ok, Res} ->
            sync_with_all_node_monitors(),
            {ok, Res};
        {error, _} = Error -> Error
    end.

-spec replace_secret(secret_id(), map(), fun((secret_props()) -> boolean())) ->
          {ok, secret_props()} |
          {error, not_found | bad_encrypt_id() | bad_usage_change() |
                  forbidden | inconsistent_graph() |
                  encryption_service:stored_key_error() | bad_encrypt_id() |
                  no_quorum}.
replace_secret(Id, NewProps, IsSecretWritableFun) ->
    execute_on_master({?MODULE, replace_secret_internal,
                       [Id, NewProps, IsSecretWritableFun]}).

-spec replace_secret_internal(secret_id(), map(),
                              fun((secret_props()) -> boolean())) ->
          {ok, secret_props()} |
          {error, not_found | bad_encrypt_id() | bad_usage_change() |
                  forbidden | inconsistent_graph() |
                  encryption_service:stored_key_error() | bad_encrypt_id() |
                  no_quorum}.
replace_secret_internal(Id, NewProps, IsSecretWritableFun) ->
    %% Make sure we have most recent information about which secrets are in use
    %% This is needed for verification of 'usage' modification
    maybe_reset_deks_counters(),
    Res =
        chronicle_compat_txn(
          fun (Txn) ->
              maybe
                  Snapshot = fetch_snapshot_in_txn(Txn),
                  {ok, OldProps} ?= get_secret(Id, Snapshot),
                  true ?= IsSecretWritableFun(OldProps),
                  Props = copy_static_props(OldProps, NewProps),
                  CurList = get_all(Snapshot),
                  {ok, FinalProps} ?= ensure_secret_encrypted_txn(Props,
                                                                  Snapshot),
                  NewList = replace_secret_in_list(FinalProps, CurList),
                  ok ?= validate_secret_in_txn(FinalProps, OldProps, Snapshot),
                  ok ?= validate_secrets_consistency(NewList),
                  {commit, [{set, ?CHRONICLE_SECRETS_KEY, NewList}], FinalProps}
              else
                  false ->
                      {abort, {error, forbidden}};
                  {error, _} = Err ->
                      {abort, Err}
              end
           end),
    case Res of
        {ok, ResProps} ->
            %% In order to make sure all keys are reencrypted by the time when
            %% the call is finished
            sync_with_all_node_monitors(),
            maybe_reencrypt_secrets(),
            {ok, ResProps};
        {error, _} = Error -> Error
    end.

-spec delete_secret(secret_id(), fun((secret_props()) -> boolean())) ->
          ok | {error, not_found | secret_in_use() | forbidden |
                       inconsistent_graph() | no_quorum}.
delete_secret(Id, IsSecretWritableFun) ->
    execute_on_master({?MODULE, delete_secret_internal,
                       [Id, IsSecretWritableFun]}).

-spec delete_secret_internal(secret_id(), fun((secret_props()) -> boolean())) ->
          ok | {error, not_found | secret_in_use() | forbidden |
                       inconsistent_graph() | no_quorum}.
delete_secret_internal(Id, IsSecretWritableFun) ->
    %% Make sure we have most recent information about which secrets are in use
    maybe_reset_deks_counters(),
    RV = chronicle_compat_txn(
           fun (Txn) ->
               maybe
                   Snapshot = fetch_snapshot_in_txn(Txn),
                   {ok, #{id := Id} = Props} ?= get_secret(Id, Snapshot),
                   true ?= IsSecretWritableFun(Props),
                   ok ?= can_delete_secret(Props, Snapshot),
                   CurSecrets = get_all(Snapshot),
                   NewSecrets = lists:filter(
                                  fun (#{id := Id2}) -> Id2 /= Id end,
                                  CurSecrets),
                   true = (length(NewSecrets) + 1 == length(CurSecrets)),
                   ok ?= validate_secrets_consistency(NewSecrets),
                   {commit, [{set, ?CHRONICLE_SECRETS_KEY, NewSecrets}]}
               else
                   false -> {abort, {error, forbidden}};
                   {error, _} = Error -> {abort, Error}
               end
           end),
    case RV of
        ok ->
            sync_with_all_node_monitors(),
            ok;
        {error, Reason} ->
            {error, Reason}
    end.

%% Cipher should have type crypto:cipher() but it is not exported
-spec generate_raw_key(Cipher :: atom()) -> binary().
generate_raw_key(Cipher) ->
    #{key_length := Length} = crypto:cipher_info(Cipher),
    crypto:strong_rand_bytes(Length).

-spec rotate(secret_id()) -> ok | {error, not_found | bad_encrypt_id() |
                                          inconsistent_graph() | not_supported |
                                          no_quorum}.
rotate(Id) ->
    execute_on_master({?MODULE, rotate_internal, [Id]}).

-spec rotate_internal(secret_id()) -> ok | {error, not_found |
                                                   bad_encrypt_id() |
                                                   inconsistent_graph() |
                                                   not_supported |
                                                   no_quorum}.
rotate_internal(Id) ->
    case rotate_secret_by_id(Id) of
        ok ->
            %% In order to make sure all keys are reencrypted by
            %% the time when the call is finished
            sync_with_all_node_monitors(),
            maybe_reencrypt_secrets(),
            ok;
        {error, Reason} ->
            {error, Reason}
    end.

-spec test(secret_props()) -> ok | {error, _}.
test(Params) ->
    execute_on_master({?MODULE, test_internal, [Params]}).

-spec test_internal(secret_props()) -> ok | {error, _}.
test_internal(Props) ->
    PropsWTime = Props#{creation_time => erlang:universaltime()},
    PropsWId = PropsWTime#{id => 999999999},
    Prepared = prepare_new_secret(PropsWId),
    case Prepared of
        #{type := ?AWSKMS_KEY_TYPE} ->
            test_aws_kek(Prepared);
        #{type := ?KMIP_KEY_TYPE} ->
            test_kmip_kek(Prepared);
        #{} ->
            {error, not_supported}
    end.

-spec get_active_key_id(secret_id()) -> {ok, key_id()} |
                                        {error, not_found | not_supported}.
get_active_key_id(SecretId) ->
    get_active_key_id(SecretId, direct).

-spec get_active_key_id(secret_id(), chronicle_snapshot()) ->
                                            {ok, key_id()} |
                                            {error, not_found | not_supported}.
get_active_key_id(SecretId, Snapshot) ->
    maybe
        {ok, SecretProps} ?= get_secret(SecretId, Snapshot),
        {ok, _} ?= get_active_key_id_from_secret(SecretProps)
    else
        {error, _} = Err -> Err
    end.

-spec sync_with_node_monitor() -> ok.
sync_with_node_monitor() ->
    %% Mostly needed to make sure local cb_cluster_secret has pushed all new
    %% keys to disk before we try using them.
    %% chronicle_kv:sync() makes sure we have the latest chronicle data
    %% chronicle_compat_events:sync() makes sure all notifications has been sent
    %% sync([node()]) makes sure local cb_cluster_secret has handled that
    %% notification
    ok = chronicle_kv:sync(kv, ?SYNC_TIMEOUT),
    chronicle_compat_events:sync(),
    gen_server:call(?MODULE, sync, ?SYNC_TIMEOUT).

-spec ensure_can_encrypt_dek_kind(secret_id(), cb_deks:dek_kind(),
                                  chronicle_snapshot()) ->
          ok | {error, not_allowed | not_found}.
ensure_can_encrypt_dek_kind(SecretId, DekKind, Snapshot) ->
    maybe
        {ok, SecretProps} ?= get_secret(SecretId, Snapshot),
        true ?= can_secret_props_encrypt_dek_kind(SecretProps, DekKind),
        ok
    else
        false -> {error, not_allowed};
        {error, not_found} -> {error, not_found}
    end.

-spec is_allowed_usage_for_secret(secret_id(), secret_usage(),
                                  chronicle_snapshot()) ->
          ok | {error, not_allowed | not_found}.
is_allowed_usage_for_secret(SecretId, Usage, Snapshot) ->
    maybe
        {ok, #{usage := AllowedUsages}} ?= get_secret(SecretId, Snapshot),
        true ?= is_allowed([Usage], AllowedUsages),
        ok
    else
        false -> {error, not_allowed};
        {error, not_found} -> {error, not_found}
    end.

-spec is_encrypted_by_secret_manager(secret_props()) -> boolean().
is_encrypted_by_secret_manager(#{type := ?GENERATED_KEY_TYPE,
                                 data := #{encrypt_by := nodeSecretManager}}) ->
    true;
is_encrypted_by_secret_manager(#{type := ?GENERATED_KEY_TYPE,
                                 data := #{keys := Keys}}) ->
    lists:any(fun (#{key_material := #{encrypted_by := EB}}) ->
                  EB == undefined
              end, Keys);
is_encrypted_by_secret_manager(#{type := ?KMIP_KEY_TYPE,
                                 data := #{encrypt_by := nodeSecretManager}}) ->
    true;
is_encrypted_by_secret_manager(#{}) ->
    false.

-spec get_secret_by_kek_id_map(chronicle_snapshot()) ->
                                                    #{key_id() := secret_id()}.
get_secret_by_kek_id_map(Snapshot) ->
    maps:from_list(lists:flatmap(
                     fun (#{id := Id} = S) ->
                         [{KeyId, Id} ||  KeyId <- get_all_keys_from_props(S)]
                     end, get_all(Snapshot))).

-spec get_node_deks_info() -> #{cb_deks:dek_kind() := external_dek_info()}.
get_node_deks_info() ->
    try
        gen_server:call(?MODULE, get_node_deks_info,
                        ?DEK_COUNTERS_UPDATE_TIMEOUT)
    catch
        _:E ->
            ?log_error("Failed to get node deks_info: ~p", [E]),
            Kinds = cb_deks:dek_kinds_list(),
            maps:from_list(
              lists:map(
                fun (K) ->
                    {K, #{issues => [{proc_communication, failed}]}}
                end, Kinds))
    end.

-spec new_key_id() -> key_id().
new_key_id() ->
    Id = misc:uuid_v4(),
    true = is_valid_key_id(Id),
    Id.

-spec is_valid_key_id(binary()) -> boolean().
is_valid_key_id(Bin) -> misc:is_valid_v4uuid(Bin).

-spec dek_drop_complete(cb_deks:dek_kind()) -> ok.
dek_drop_complete(DekKind) ->
    ?MODULE ! {dek_drop_complete, DekKind},
    ok.

-spec is_name_unique(secret_id(), string(), chronicle_snapshot()) -> boolean().
is_name_unique(Id, Name, Snapshot) ->
    lists:all(fun (#{id := Id2}) when Id == Id2 -> true;
                  (#{name := Name2}) -> Name /= Name2
              end, get_all(Snapshot)).

-spec sanitize_chronicle_cfg([secret_props()]) -> [term()].
sanitize_chronicle_cfg(Value) ->
    lists:map(fun sanitize_secret/1, Value).

-spec merge_dek_infos(external_dek_info(), external_dek_info()) ->
          external_dek_info().
merge_dek_infos(M1, M2) ->
    MergeIssues = fun (Issues1, Issues2) ->
                      maps:to_list(
                        maps:merge_with(fun (_, failed, _) -> failed;
                                            (_, _, failed) -> failed;
                                            (_, pending, pending) -> pending
                                        end,
                                        maps:from_list(Issues1),
                                        maps:from_list(Issues2)))
                  end,
    maps:merge_with(
      fun (data_status, unknown, _) -> unknown;
          (data_status, _, unknown) -> unknown;
          (data_status, encrypted, encrypted) -> encrypted;
          (data_status, unencrypted, unencrypted) -> unencrypted;
          (data_status, _, _) -> partially_encrypted;
          (issues, A, B) -> MergeIssues(A, B);
          (dek_num, A, B) -> A + B;
          (deks, A, B) -> A ++ B;
          (oldest_dek_datetime, A, B) -> min(A, B)
      end, M1, M2).

-spec format_dek_issues([{dek_issue(), pending | failed}]) -> [binary()].
format_dek_issues(List) ->
    lists:map(fun ({maybe_update_deks, pending}) ->
                      <<"keys update pending">>;
                  ({maybe_update_deks, failed}) ->
                      <<"keys update failed">>;
                  ({garbage_collect_deks, pending}) ->
                      <<"keys garbage collection pending">>;
                  ({garbage_collect_deks, failed}) ->
                      <<"keys garbage collection failed">>;
                  ({maybe_reencrypt_deks, pending}) ->
                      <<"keys reencryption pending">>;
                  ({maybe_reencrypt_deks, failed}) ->
                      <<"keys reencryption failed">>;
                  ({node_info, pending}) ->
                      <<"information missing for some nodes">>;
                  ({proc_communication, failed}) ->
                      <<"encryption manager does not respond">>
              end, List).

%%%===================================================================
%%% gen_server callbacks
%%%===================================================================

init([Type]) ->
    Self = self(),
    EventFilter =
        fun (?CHRONICLE_SECRETS_KEY = K) -> {true, {config_change, K}};
            (Key) ->
                case Type == ?NODE_PROC andalso
                     cb_deks:dek_chronicle_keys_filter(Key) of
                    false -> false;
                    List -> {true, {dek_settings_updated, List}}
                end
        end,
    chronicle_compat_events:subscribe(
      fun (Key) ->
          case EventFilter(Key) of
              false -> ok;
              {true, M} -> Self ! M
          end
      end),
    Jobs = case Type of
               ?MASTER_PROC ->
                   [maybe_reencrypt_secrets,
                    maybe_reset_deks_counters];
               ?NODE_PROC ->
                    Kinds = cb_deks:dek_kinds_list(),
                    lists:flatmap(fun (K) ->
                                      [{maybe_update_deks, K},
                                       {garbage_collect_deks, K}]
                                  end, Kinds) ++
                   [garbage_collect_keks,
                    ensure_all_keks_on_disk] ++
                   [{maybe_reencrypt_deks, K} || K <- Kinds]
           end,

    %% If we are starting after joininig the cluster (or after leaving cluster),
    %% it means that secrets configuration in chronicle has magically changed
    %% while this process was down.
    %% For example, KEKs on disk do not exist in configuration any more,
    %% and they will be garbage collected by the garbage_collect_keks job.
    %% This can be a problem because there could be DEKs that are encrypted with
    %% those KEKs. In order to smoothly migrate from old configuration, it is
    %% important to run reencryption of DEKs before garbage collecting KEKs.
    %% It is also important to not garbage collect KEKs until reencryption of
    %% DEKs finishes successfully.
    %% Note that this means that this process can't start until the reecnryption
    %% is finished.

    {ok, functools:chain(#state{proc_type = Type, jobs = Jobs},
                         [maybe_read_deks(_),
                          run_jobs(_),
                          restart_dek_cleanup_timer(_),
                          restart_rotation_timer(_)])}.

handle_call({call, {M, F, A} = MFA}, _From,
            #state{proc_type = ?MASTER_PROC} = State) ->
    try
        ?log_debug("Calling ~p", [MFA]),
        {reply, {succ, erlang:apply(M, F, A)}, restart_rotation_timer(State)}
    catch
        C:E:ST ->
            ?log_warning("Call ~p failed: ~p:~p~n~p", [MFA, C, E, ST]),
            {reply, {exception, {C, E, ST}}, restart_rotation_timer(State)}
    end;

handle_call(sync, _From, #state{proc_type = ?NODE_PROC} = State) ->
    {reply, ok, State};

handle_call(get_node_deks_info, _From,
            #state{proc_type = ?NODE_PROC} = State) ->
    #state{deks = Deks} = State,
    Kinds = maps:keys(Deks),
    {Res, NewState} =
        lists:foldl(
          fun (Kind, {ResAcc, StateAcc}) ->
               %% Run gc for deks; it is usefull in case if a compaction
               %% has been run recently
               NewStateAcc = maybe_garbage_collect_deks(Kind, false, StateAcc),
               case extract_dek_info(Kind, NewStateAcc) of
                   {ok, I} -> {ResAcc#{Kind => I}, NewStateAcc};
                   {error, not_found} -> {ResAcc, NewStateAcc}
               end
          end, {#{}, State}, Kinds),

    {reply, Res, NewState};

handle_call(Request, _From, State) ->
    ?log_warning("Unhandled call: ~p", [Request]),
    {noreply, State}.

handle_cast(Msg, State) ->
    ?log_warning("Unhandled cast: ~p", [Msg]),
    {noreply, State}.

handle_info({config_change, ?CHRONICLE_SECRETS_KEY} = Msg,
            #state{proc_type = ?NODE_PROC, deks = Deks} = State) ->
    ?log_debug("Secrets in chronicle have changed..."),
    misc:flush(Msg),
    Kinds = maps:keys(Deks),
    NewJobs = [garbage_collect_keks,       %% Removal of generated keks and AWS
               ensure_all_keks_on_disk] ++ %% Adding keks + AWS key change
              [{maybe_reencrypt_deks, K} || K <- Kinds], %% Keks rotation
    {noreply, add_and_run_jobs(NewJobs, State)};

handle_info({config_change, ?CHRONICLE_SECRETS_KEY} = Msg,
            #state{proc_type = ?MASTER_PROC} = State) ->
    ?log_debug("Secrets in chronicle have changed..."),
    misc:flush(Msg),
    NewJobs = [maybe_reencrypt_secrets], %% Modififcation of encryptBy or
                                         %% rotation of secret that encrypts
                                         %% other secrets
    {noreply, add_and_run_jobs(NewJobs, State)};

handle_info({config_change, _}, State) ->
    {noreply, State};

handle_info({dek_settings_updated, KindList},
            #state{proc_type = ?NODE_PROC} = State) ->
    ?log_debug("Dek settings updated for ~p", [KindList]),
    NewState = functools:chain(
                 State,
                 [add_and_run_jobs(
                    [{maybe_update_deks, Kind} || Kind <- KindList] ++
                    [{maybe_reencrypt_deks, Kind} || Kind <- KindList],
                    _),
                  %% We should restart these timers because rotation settings
                  %% can change
                  restart_dek_rotation_timer(_),
                  restart_dek_cleanup_timer(_)]),
    {noreply, NewState};

handle_info({timer, retry_jobs}, #state{proc_type = ProcType} = State) ->
    ?log_debug("[~p] Retrying jobs", [ProcType]),
    {noreply, run_jobs(State)};

handle_info({timer, rotate_keks}, #state{proc_type = ?MASTER_PROC} = State) ->
    ?log_debug("Rotate keks timer"),
    misc:flush({timer, rotate_keks}),
    CurTime = calendar:universal_time(),
    %% Intentionally update next_rotation time first, and run rotations after.
    %% Reason: in case of a crash during rotation we don't want to retry.
    %% Rotation generates keys. If we get stuck in a loop, we can generate
    %% too many keys which can lead to unpredictable results.
    case update_secrets(update_next_rotation_time(CurTime, _)) of
        {ok, IdsToRotate} ->
            lists:foreach(
              fun (Id) ->
                  try
                      ok = rotate_secret_by_id(Id)
                  catch
                      C:E:ST ->
                          ?log_error("Secret #~p rotation crashed: ~p:~p~n~p",
                                     [Id, C, E, ST])
                  end
              end, IdsToRotate);
        {error, _} ->
            %% we will retry
            ok
    end,
    {noreply, restart_rotation_timer(State)};

handle_info({timer, dek_cleanup} = Msg, #state{proc_type = ?NODE_PROC,
                                               deks = DeksInfo} = State) ->
    ?log_debug("DEK cleanup timer"),
    misc:flush(Msg),
    DeksToDropFun =
        fun (Kind, StateAcc) ->
            case deks_to_drop(Kind, StateAcc) of
                [] -> {[], StateAcc};
                [_|_] ->
                    %% It is possible that these deks are already not being used
                    %% so try garbage collecting them first (as it is a
                    %% cheaper thing to do), and only if it doesn't help,
                    %% perform the drop keys precedure (which is expensive for
                    %% buckets)
                    NewStateAcc = maybe_garbage_collect_deks(Kind, false,
                                                             StateAcc),
                    {deks_to_drop(Kind, NewStateAcc), NewStateAcc}
            end
        end,
    NewState =
        maps:fold(
          fun (Kind, _KindDeks, StateAcc) ->
              {ToDrop, NewStateAcc} = DeksToDropFun(Kind, StateAcc),
              initiate_deks_drop(Kind, ToDrop, NewStateAcc)
          end, State, DeksInfo),
    {noreply, restart_dek_cleanup_timer(NewState)};

handle_info({dek_drop_complete, Kind} = Msg,
            #state{proc_type = ?NODE_PROC} = State) ->
    ?log_debug("Dek drop complete: ~p", [Kind]),
    misc:flush(Msg),
    {noreply, add_and_run_jobs([{garbage_collect_deks, Kind}], State)};

handle_info({timer, rotate_deks} = Msg, #state{proc_type = ?NODE_PROC,
                                               deks = Deks} = State) ->
    ?log_debug("Rotate DEKs timer"),
    misc:flush(Msg),
    CurDT = calendar:universal_time(),
    NewJobs = maps:fold(fun (Kind, KindDeks, Acc) ->
                            Snapshot = deks_config_snapshot(Kind),
                            case dek_rotation_needed(Kind, KindDeks, CurDT,
                                                     Snapshot) of
                                true ->
                                    ?log_debug("Dek rotation needed for ~p",
                                               [Kind]),
                                    [{maybe_update_deks, Kind} | Acc];
                                false -> Acc
                            end
                        end, [], Deks),
    {noreply, restart_dek_rotation_timer(add_and_run_jobs(NewJobs, State))};

handle_info(Info, State) ->
    ?log_warning("Unhandled info: ~p", [Info]),
    {noreply, State}.

terminate(_Reason, _State) ->
    ok.

%%%===================================================================
%%% Internal functions
%%%===================================================================

-spec rotate_secret_by_id(secret_id()) -> ok | {error, not_found |
                                                       bad_encrypt_id() |
                                                       inconsistent_graph() |
                                                       not_supported |
                                                       no_quorum}.
rotate_secret_by_id(Id) ->
    ?log_info("Rotating secret #~b", [Id]),
    case get_secret(Id) of
        {ok, SecretProps} ->
            rotate_secret(SecretProps);
        {error, Reason} ->
            ?log_error("Secret #~p rotation failed: ~p", [Id, Reason]),
            {error, Reason}
    end.

-spec rotate_secret(secret_props()) -> ok | {error, not_found |
                                                    bad_encrypt_id() |
                                                    inconsistent_graph() |
                                                    not_supported |
                                                    no_quorum}.
rotate_secret(#{id := Id, type := ?GENERATED_KEY_TYPE}) ->
    maybe
        NewKey = generate_key(erlang:universaltime()),
        ok ?= add_active_key(Id, NewKey, _UpdateRotationTime = true),
        ok
    else
        {ok, #{}} ->
            ?log_info("Secret #~p rotation failed: not_supported", [Id]),
            {error, not_supported};
        {error, Reason} ->
            ?log_error("Secret #~p rotation failed: ~p", [Id, Reason]),
            {error, Reason}
    end;
rotate_secret(#{id := Id, type := ?AWSKMS_KEY_TYPE}) ->
    chronicle_transaction(
      [?CHRONICLE_SECRETS_KEY],
      fun (Snapshot) ->
          maybe
              {ok, #{type := ?AWSKMS_KEY_TYPE,
                     data := #{stored_ids := StoredIds} = Data} = Props} ?=
                  get_secret(Id, Snapshot),

              Time = calendar:universal_time(),
              NewStoredIds = [#{id => new_key_id(),
                                creation_time => Time} | StoredIds],
              NewData = Data#{stored_ids => NewStoredIds},
              Updated = functools:chain(
                          Props,
                          [_#{data => NewData},
                           set_last_rotation_time_in_props(_, Time),
                           replace_secret_in_list(_,
                                                  get_all(Snapshot))]),
              true = is_list(Updated),
              ok ?= validate_secrets_consistency(Updated),
              {commit, [{set, ?CHRONICLE_SECRETS_KEY, Updated}]}
          else
              {error, _} = Error ->
                  {abort, Error}
          end
      end);
rotate_secret(#{type := ?KMIP_KEY_TYPE}) ->
    {error, not_supported}.

-spec generate_key(Creation :: calendar:datetime()) -> kek_props().
generate_key(CreationDateTime) ->
    Key = generate_raw_key(?ENVELOP_CIPHER),
    ns_server_stats:notify_counter({<<"key_manager_generate_key">>,
                                    [{kind, kek}]}),
    #{id => new_key_id(),
      creation_time => CreationDateTime,
      key_material => #{type => sensitive,
                        data => Key,
                        encrypted_by => undefined}}.

-spec set_active_key_in_props(secret_props(), key_id()) -> secret_props().
set_active_key_in_props(#{type := ?GENERATED_KEY_TYPE,
                          data := Data} = SecretProps,
                        KeyId) ->
    SecretProps#{data => Data#{active_key_id => KeyId}}.

-spec set_keys_in_props(secret_props(), [kek_props()]) -> secret_props().
set_keys_in_props(#{type := ?GENERATED_KEY_TYPE, data := Data} = SecretProps,
                  Keys) ->
    SecretProps#{data => Data#{keys => Keys}}.

-spec copy_static_props(secret_props(), secret_props()) -> secret_props().
%% Copies properties that secret can never change
copy_static_props(#{type := Type, id := Id,
                    creation_time := CreationDT} = OldSecretProps,
                  #{type := Type} = NewSecretProps) ->
    NewSecretProps2 = NewSecretProps#{id => Id, creation_time => CreationDT},
    case NewSecretProps2 of
        #{type := ?GENERATED_KEY_TYPE} ->
            #{data := #{active_key_id := OldActiveId, keys := Keys} = OldData} =
                OldSecretProps,
            LastRotationTime = maps:get(last_rotation_time, OldData, undefined),
            functools:chain(
              NewSecretProps2,
              [set_keys_in_props(_, Keys),
               set_active_key_in_props(_, OldActiveId),
               set_last_rotation_time_in_props(_, LastRotationTime)]);
        #{type := ?AWSKMS_KEY_TYPE} ->
            #{data := #{stored_ids := StoredIds} = OldData} = OldSecretProps,
            LastRotationTime = maps:get(last_rotation_time, OldData, undefined),
            #{data := NewData} = NewSecretProps2,
            set_last_rotation_time_in_props(
              NewSecretProps2#{data => NewData#{stored_ids => StoredIds}},
              LastRotationTime);
        #{type := ?KMIP_KEY_TYPE} ->
            #{data := #{active_key := OldActive, hist_keys := HistKeys}} =
                OldSecretProps,
            #{data := #{active_key := Active} = NewData} = NewSecretProps2,
            #{id := OldActiveId,
              kmip_id := OldKmipId,
              creation_time := OldCT} = OldActive,
            #{kmip_id := NewKmipId} = Active,
            {NewFound, HistKeysCleaned} =
                misc:partitionmap(fun (#{kmip_id := I} = E)
                                                      when I == NewKmipId ->
                                          {left, E};
                                      (#{} = E) ->
                                          {right, E}
                                  end, HistKeys),

            {NewActive, NewHistKeys} =
                case {NewKmipId == OldKmipId, NewFound} of
                    {true, _} ->
                        %% New active is not actually new
                        %% Copy id and creation date from existing active key
                        {Active#{id => OldActiveId, creation_time => OldCT},
                         HistKeys};
                    {false, []} ->
                        %% We have absolutely new active key
                        %% Generate new uuid for it and set now as its creation
                        %% time
                        {Active#{id => new_key_id(),
                                 creation_time => erlang:universaltime()},
                         [OldActive | HistKeys]};
                    {false, [PrevNew]} ->
                        %% New active key doesn't match current active key,
                        %% but it is present in history keys.
                        %% Restore the existing key as active by copying its id
                        %% and creation date and remove it from the list of
                        %% history keys)
                        ExistingKeyId = maps:get(id, PrevNew),
                        ExistingKeyCT = maps:get(creation_time, PrevNew),
                        {Active#{id => ExistingKeyId,
                                 creation_time => ExistingKeyCT},
                         [OldActive | HistKeysCleaned]}
                end,
            #{key_passphrase := HiddenKP} = NewData,
            KP = #{type => sensitive,
                   data => ?UNHIDE(HiddenKP),
                   encrypted_by => undefined},
            NewSecretProps2#{data => NewData#{active_key => NewActive,
                                              hist_keys => NewHistKeys,
                                              key_passphrase => KP}};
        _ ->
            NewSecretProps2
    end.

-spec replace_secret_in_list(secret_props(), [secret_props()]) ->
                                                      [secret_props()] | false.
replace_secret_in_list(NewProps, List) ->
    Id = maps:get(id, NewProps),
    ReplaceFun = fun Replace([], _Acc) -> false;
                     Replace([Next | Rest], Acc) ->
                         case maps:get(id, Next) of
                             Id -> lists:reverse([NewProps | Acc], Rest);
                             _ -> Replace(Rest, [Next | Acc])
                         end
                 end,
    ReplaceFun(List, []).

-spec add_active_key(secret_id(), kek_props(), boolean()) ->
                        ok | {error, not_found | inconsistent_graph() |
                                     encryption_service:stored_key_error() |
                                     bad_encrypt_id() | no_quorum}.
add_active_key(Id, #{id := KekId} = Kek,
               true = _UpdateRotationTime) ->
    chronicle_transaction(
      [?CHRONICLE_SECRETS_KEY],
      fun (Snapshot) ->
          maybe
              {ok, #{type := ?GENERATED_KEY_TYPE,
                     data := SecretData} = SecretProps} ?=
                  get_secret(Id, Snapshot),
              #{keys := CurKeks} = SecretData,
              Time = calendar:universal_time(),
              Updated = functools:chain(
                          SecretProps,
                          [set_keys_in_props(_, [Kek | CurKeks]),
                           set_active_key_in_props(_, KekId),
                           set_last_rotation_time_in_props(_, Time)]),
              {ok, FinalProps} ?= ensure_secret_encrypted_txn(Updated,
                                                              Snapshot),
              NewList = replace_secret_in_list(FinalProps,
                                               get_all(Snapshot)),
              true = is_list(NewList),
              ok ?= validate_secrets_consistency(NewList),
              {commit, [{set, ?CHRONICLE_SECRETS_KEY, NewList}]}
          else
              {error, _} = Error ->
                  {abort, Error}
          end
      end).

-spec ensure_all_keks_on_disk(#state{}) ->
          {ok, #state{}} | {error, #state{}, list()}.
ensure_all_keks_on_disk(#state{kek_hashes_on_disk = Vsns} = State) ->
    Write = fun (#{type := ?GENERATED_KEY_TYPE} = SecretProps)  ->
                    ensure_generated_keks_on_disk(SecretProps);
                (#{type := ?AWSKMS_KEY_TYPE} = SecretProps) ->
                    ensure_aws_kek_on_disk(SecretProps, false);
                (#{type := ?KMIP_KEY_TYPE} = SecretProps) ->
                    ensure_kmip_kek_on_disk(SecretProps, false);
                (#{}) ->
                    ok
            end,

    {RV, NewVsns} = lists:mapfoldl(
                      fun (#{id := Id} = S, Acc) ->
                          Old = maps:get(Id, Acc, undefined),
                          case erlang:phash2(S, ?MAX_PHASH2_RANGE) of
                              Old -> {{Id, ok}, Acc};
                              New ->
                                 case Write(S) of
                                     ok -> {{Id, ok}, Acc#{Id => New}};
                                     {error, _} = E -> {{Id, E}, Acc}
                                 end
                          end
                      end, Vsns, get_all()),

    IdsDoNotExist = maps:keys(NewVsns) -- proplists:get_keys(RV),
    NewState = State#state{kek_hashes_on_disk = maps:without(IdsDoNotExist,
                                                             NewVsns)},
    case misc:many_to_one_result(RV) of
        ok -> {ok, NewState};
        {error, Reason} -> {error, NewState, Reason}
    end.

-spec ensure_generated_keks_on_disk(secret_props()) -> ok | {error, list()}.
ensure_generated_keks_on_disk(#{type := ?GENERATED_KEY_TYPE, id := SecretId,
                                data := #{keys := Keys}} = Secret) ->
    ?log_debug("Ensure all keys are on disk for secret ~p "
               "(number of keys to check: ~b)", [SecretId, length(Keys)]),
    Res = lists:map(fun (#{id := Id} = K) ->
                        {Id, ensure_kek_on_disk(K, secret_ad(Secret))}
                    end, Keys),
    misc:many_to_one_result(Res).

-spec ensure_kek_on_disk(kek_props(), binary()) -> ok | {error, _}.
ensure_kek_on_disk(#{id := Id,
                     key_material := #{type := sensitive, data := Key,
                                       encrypted_by := undefined},
                     creation_time := CreationTime}, _) ->
    encryption_service:store_kek(Id, Key, undefined, CreationTime);
ensure_kek_on_disk(#{id := Id,
                     key_material := #{type := encrypted, data := EncryptedKey,
                                       encrypted_by := {_ESecretId, EKekId}},
                     creation_time := CreationTime} = KeyProps, SecretAD) ->
    AD = auto_generated_key_ad(SecretAD, KeyProps),
    maybe
        {ok, Key} ?= encryption_service:decrypt_key(EncryptedKey, AD, EKekId),
        encryption_service:store_kek(Id, Key, EKekId, CreationTime)
    end.

-spec test_aws_kek(secret_props()) -> ok | {error, _}.
test_aws_kek(#{data := #{stored_ids := [StoredId | _]} = Data} = Secret) ->
    %% We don't want to test all stored ids
    SecretWithoutHistKeys = Secret#{data => Data#{stored_ids => [StoredId]}},
    case ensure_aws_kek_on_disk(SecretWithoutHistKeys, true) of
        ok -> ok;
        {error, [{_, Reason}]} -> {error, Reason};
        {error, _} = E -> E
    end.

-spec ensure_aws_kek_on_disk(secret_props(), boolean()) -> ok | {error, _}.
ensure_aws_kek_on_disk(#{data := #{stored_ids := StoredIds} = Data},
                       TestOnly) ->
    Params = maps:with([key_arn, region, profile, config_file,
                        credentials_file, use_imds], Data),
    Res = lists:map(
            fun (#{id := Id, creation_time := CreationTime}) ->
                {Id, encryption_service:store_aws_key(Id, Params, CreationTime,
                                                      TestOnly)}
            end, StoredIds),
    misc:many_to_one_result(Res).

-spec test_kmip_kek(secret_props()) -> ok | {error, _}.
test_kmip_kek(#{data := Data} = Secret) ->
    %% Only testing active kmip id (the one that is being set basically)
    SecretWithoutHistKeys = Secret#{data => Data#{hist_keys => []}},
    case ensure_kmip_kek_on_disk(SecretWithoutHistKeys, true) of
        ok -> ok;
        {error, [{_, Reason}]} -> {error, Reason};
        {error, _} = E -> E
    end.

-spec ensure_kmip_kek_on_disk(secret_props(), boolean()) -> ok | {error, _}.
ensure_kmip_kek_on_disk(#{data := #{active_key := ActiveKey,
                                    hist_keys := OtherKeys,
                                    key_passphrase := Pass} = Data} = Secret,
                        TestOnly) ->
    {DecryptRes, KekId} =
        case Pass of
            #{type := sensitive, data := D, encrypted_by := undefined} ->
                {{ok, D}, undefined};
            #{type := encrypted, data := ED, encrypted_by := {_, KId}} ->
                AD = secret_ad(Secret),
                R = encryption_service:decrypt_key(ED, AD, KId),
                {R, KId}
        end,
    case DecryptRes of
        {ok, PassData} ->
            Common = maps:with([host, port, key_cert_path, encryption_approach],
                               Data),
            Res = lists:map(
                    fun (#{id := Id, kmip_id := KmipId,
                           creation_time := CreationTime}) ->
                        Params = Common#{kmip_id => KmipId,
                                         key_passphrase => PassData},
                        {Id, encryption_service:store_kmip_key(
                               Id, Params, KekId, CreationTime, TestOnly)}
                    end, [ActiveKey | OtherKeys]),
            misc:many_to_one_result(Res);
        {error, _} = E ->
            E
    end.

-spec garbage_collect_keks() -> ok.
garbage_collect_keks() ->
    AllKekIds = all_kek_ids(),
    ?log_debug("keks gc: All existing keks: ~p", [AllKekIds]),
    encryption_service:garbage_collect_keks(AllKekIds).

-spec all_kek_ids() -> [key_id()].
all_kek_ids() ->
    lists:flatmap(get_all_keys_from_props(_), get_all()).

-spec prepare_new_secret(secret_props()) -> secret_props().
prepare_new_secret(#{type := ?GENERATED_KEY_TYPE,
                     creation_time := CurrentTime} = Props) ->
    %% Creating new auto-generated key
    #{id := KekId} = KeyProps = generate_key(CurrentTime),
    functools:chain(Props, [set_keys_in_props(_, [KeyProps]),
                            set_active_key_in_props(_, KekId)]);
prepare_new_secret(#{type := ?AWSKMS_KEY_TYPE, data := Data,
                     creation_time := CT} = Props) ->
    Props#{data => Data#{stored_ids => [#{id => new_key_id(),
                                          creation_time => CT}]}};
prepare_new_secret(#{type := ?KMIP_KEY_TYPE, data := Data,
                     creation_time := CT} = Props) ->
    #{active_key := AK, key_passphrase := HiddenKP} = Data,
    KP = #{type => sensitive,
           data => ?UNHIDE(HiddenKP),
           encrypted_by => undefined},
    Props#{data => Data#{active_key => AK#{id => new_key_id(),
                                           creation_time => CT},
                         key_passphrase => KP,
                         hist_keys => []}}.

-spec maybe_update_deks(cb_deks:dek_kind(), #state{}) ->
          {ok, #state{}} | {error, #state{}, term()}.
maybe_update_deks(Kind, #state{deks = CurDeks} = OldState) ->
    Snapshot = deks_config_snapshot(Kind),
    case call_dek_callback(encryption_method_callback, Kind, [Snapshot]) of
        {succ, {ok, EncrMethod}} ->
            %% Read DEKs if we don't have them yet
            State = #state{deks = AllDeks} =
                case maps:find(Kind, CurDeks) of
                    {ok, _} -> OldState;
                    error ->
                        EmptyDeks = new_dek_info(undefined, [], false),
                        OldState#state{deks = CurDeks#{Kind => EmptyDeks}}
                end,

            #{Kind := #{active_id := ActiveId,
                        is_enabled := WasEnabled,
                        deks := Deks} = KindDeks} = AllDeks,

            CurDT = calendar:universal_time(),
            ShouldRotate = dek_rotation_needed(Kind, KindDeks, CurDT, Snapshot),

            %% Check current encryption settings and push actual active key to
            %% dek users
            case WasEnabled of

                %% On disk it is enabled but in config it is disabled:
                true when EncrMethod == disabled ->
                    NewState = set_active(Kind, ActiveId, false, State),
                    call_set_active_cb(Kind, NewState);

                %% It is enabled on disk and in config:
                true when not ShouldRotate ->
                    %% We should push it even when nothing changes in order to
                    %% handle the scenario when we crash between
                    %% set_active and SetActiveCB
                    call_set_active_cb(Kind, State);

                %% It is disabled on disk and in config:
                false when EncrMethod == disabled ->
                    %% We should push it even when nothing changes in order to
                    %% handle the scenario when we crash between
                    %% set_active and SetActiveCB
                    call_set_active_cb(Kind, State);

                %% On disk it is disabled but in config it is enabled
                %% and we already have a dek
                false when is_binary(ActiveId) and not ShouldRotate ->
                    NewState = set_active(Kind, ActiveId, true, State),
                    call_set_active_cb(Kind, NewState);

                %% On disk it is disabled but in config it is enabled
                %% or rotation is needed
                V when (V == false) orelse ShouldRotate ->
                    %% There is no active dek currently, but encryption is on,
                    %% we should generate a new dek
                    case generate_new_dek(Kind, Deks, EncrMethod, Snapshot) of
                        {ok, DekId} ->
                            NewState = set_active(Kind, DekId, true, State),
                            call_set_active_cb(Kind, NewState);
                        %% Too many DEKs and encryption is being enabled
                        %% We could not create new DEK, but should still
                        %% enable the encryption
                        %% Note that ActiveId can't be undefined because
                        %% we know there are too many deks.
                        %% It should be ok to return ok if set_active_cb
                        %% succeeds.
                        {error, too_many_deks} when V == false ->
                            true = is_binary(ActiveId),
                            NewState = set_active(Kind, ActiveId, true, State),
                            call_set_active_cb(Kind, NewState);
                        %% This just a dek rotation attempt. No need to call
                        %% set_active because nothing changes.
                        {error, too_many_deks} ->
                            NewState = maybe_garbage_collect_deks(Kind, false,
                                                                  State),
                            %% We will retry anyway because of rotate_deks timer
                            {ok, NewState};
                        {error, Reason} ->
                            {error, State, Reason}
                    end
            end;
        {succ, {error, not_found}} ->
            %% This entity doesn't exist anymore, nothing to do here
            %% We assume that DEKs are removed before that (for example, for
            %% buckets they are removed when the bucket dir is removed)
            %% Just make sure we don't monitor those DEKs anymore.
            %% Note that bucket can exist globally, but can be missing at this
            %% specific node.
            ?log_debug("DEK ~p doesn't seem to exist. Forgetting about it"),
            State = OldState#state{deks = maps:remove(Kind, CurDeks)},
            write_deks_cfg_file(State),
            {ok, on_deks_update(Kind, State)}
    end.

-spec maybe_garbage_collect_deks(cb_deks:dek_kind(), boolean(), #state{}) ->
          #state{}.
maybe_garbage_collect_deks(Kind, Force, #state{deks = DeksInfo} = State) ->
    ShouldRun =
        case maps:find(Kind, DeksInfo) of
            {ok, #{last_deks_gc_datetime := undefined}} ->
                true;
            {ok, #{last_deks_gc_datetime := DT}} ->
                %% The goal is to not call it too often
                Deadline = misc:datetime_add(DT, ?MIN_DEK_GC_INTERVAL_S),
                calendar:universal_time() > Deadline;
            error ->
                false
        end,
    case ShouldRun orelse Force of
        true ->
            case garbage_collect_deks(Kind, Force, State) of
                {ok, NewState} -> NewState;
                {error, NewState, Error} ->
                    case Error of
                        retry ->
                            ?log_debug("~p DEK garbage collection returned "
                                       "retry", [Kind]);
                        _ ->
                            ?log_error("~p DEK garbage collection failed: ~p",
                                       [Kind, Error])
                    end,
                    add_jobs([{garbage_collect_deks, Kind}], NewState)
            end;
        false ->
            State
    end.

%% Remove DEKs that are not being used anymore
%% Also update has_unencrypted_data in state
-spec garbage_collect_deks(cb_deks:dek_kind(), boolean(), #state{}) ->
          {ok, #state{}} | {error, #state{}, term()}.
garbage_collect_deks(Kind, Force, #state{deks = DeksInfo} = State) ->
    ?log_debug("Garbage collecting ~p DEKs", [Kind]),
    case maps:find(Kind, DeksInfo) of
        %% Note: we can't skip this phase even when we don't have deks
        %% (or have only one dek), because we need to update
        %% "has_unencrypted_data" info anyway
        {ok, #{statuses := Statuses} = KindDeks} ->
            UpdateStatus = maps:get(maybe_update_deks, Statuses, undefined),
            NotifyCounter = fun (L) ->
                                ns_server_stats:notify_gauge(
                                  {<<"key_manager_deks_in_use">>,
                                   [{kind, cb_deks:kind2bin(Kind)}]},
                                   length(L),
                                   #{expiration_s => infinity})
                            end,
            case call_dek_callback(get_ids_in_use_callback, Kind, []) of
                {succ, {ok, IdList}} when (UpdateStatus == ok) orelse Force ->
                    NotifyCounter(IdList),
                    UniqIdList = lists:uniq(IdList),
                    NewKindDeks = KindDeks#{has_unencrypted_data =>
                                            lists:member(?NULL_DEK, UniqIdList),
                                            last_deks_gc_datetime =>
                                            calendar:universal_time()},
                    NewState = State#state{deks = DeksInfo#{
                                                    Kind => NewKindDeks}},
                    CleanedIdList = lists:delete(?NULL_DEK, UniqIdList),
                    {ok, retire_unused_deks(Kind, CleanedIdList, NewState)};
                {succ, {ok, IdList}} ->
                    NotifyCounter(IdList),
                    %% UpdateStatus is not ok. This means update of deks
                    %% finished unsuccesfully, so we don't really know if
                    %% set_active_key_callback has actually finished.
                    %% It is hypothetically possible that we receive error,
                    %% but set_active_key_callback is still working (e.g. in
                    %% memcached). In this case it is possible that we remove
                    %% the keys that are being pushed.
                    NewKindDeks = KindDeks#{has_unencrypted_data =>
                                            lists:member(?NULL_DEK, IdList)},
                    NewState = State#state{deks = DeksInfo#{
                                                    Kind => NewKindDeks}},
                    ?log_debug("Skipping ~p deks retiring because update "
                               "status is ~p", [Kind, UpdateStatus]),
                    {error, NewState, retry};
                {succ, {error, not_found}} ->
                    %% The entity that uses deks does not exist.
                    %% Ignoring it here because we assume that deks will
                    %% be removed by maybe_update_deks
                    {ok, State};
                {succ, {error, Reason}} ->
                    {error, State, Reason};
                {except, {_, E, _}} ->
                    {error, State, E}
            end;
        error ->
            {ok, State}
    end.

-spec retire_unused_deks(cb_deks:dek_kind(), [cb_deks:dek_id()], #state{}) ->
          #state{}.
retire_unused_deks(Kind, DekIdsInUse, #state{deks = DeksInfo} = State) ->
    #{Kind := #{active_id := ActiveId,
                is_enabled := IsEnabled,
                deks := Deks} = KindDeks} = DeksInfo,
    NewDeks =
        lists:filter(
          fun (#{id := Id}) ->
              case lists:member(Id, DekIdsInUse) of
                  true ->
                      true;
                  false when Id == ActiveId, IsEnabled ->
                      %% We should not remove active key
                      ?log_error("Attempt to remove active dek ~p for ~p "
                                 "while encryption is on", [ActiveId, Kind]),
                      true;
                  false ->
                      false
              end
          end, Deks),

    case length(NewDeks) == length(Deks) of
        true -> State;
        false ->
            NewKindDeks =
                case lists:member(ActiveId, DekIdsInUse) of
                    false ->
                        false = IsEnabled,
                        KindDeks#{deks => NewDeks, active_id => undefined};
                    true ->
                        KindDeks#{deks => NewDeks}
                end,
            NewState = State#state{deks = DeksInfo#{Kind => NewKindDeks}},
            write_deks_cfg_file(NewState),
            %% It doesn't make sense to fail this job if file removal fails
            %% because when retried the job will do nothing anyway (because
            %% state doesn't have those deks)
            encryption_service:garbage_collect_keys(Kind, DekIdsInUse),
            {ok, _} = cb_crypto:reset_dek_cache(Kind, cleanup),
            on_deks_update(Kind, NewState)
    end.

-spec call_set_active_cb(cb_deks:dek_kind(), #state{}) ->
          {ok, #state{}} | {error, #state{}, term()}.
call_set_active_cb(Kind, #state{deks = AllDeks} = State) ->
    #{Kind := #{active_id := ActiveId,
                deks := Keys,
                is_enabled := IsEnabled}} = AllDeks,
    NewActiveKey =
        case IsEnabled of
            true ->
                {value, ActiveKey} = lists:search(fun (#{id := Id}) ->
                                                        Id == ActiveId
                                                  end, Keys),
                ActiveKey;
            false -> undefined
        end,
    case cb_crypto:reset_dek_cache(Kind, {new_active, NewActiveKey}) of
        {ok, _} ->
            case call_dek_callback(set_active_key_callback, Kind,
                                   [NewActiveKey]) of
                {succ, ok} ->
                    {ok, maybe_garbage_collect_deks(Kind, true, State)};
                {succ, {error, Reason}} ->
                    {error, State, Reason};
                {except, {_, E, _}} ->
                    {error, State, E}
            end;
        {error, Reason} ->
            {error, State, Reason}
    end.

call_dek_callback(CallbackName, Kind, Args) ->
    #{CallbackName := CB} = cb_deks:dek_config(Kind),
    try erlang:apply(CB, Args) of
        RV ->
            ?log_debug("~p for ~p returned: ~0p", [CallbackName, Kind, RV]),
            {succ, RV}
    catch
        C:E:ST ->
            ?log_error("~p for ~p crash ~p:~p~n~p",
                       [CallbackName, Kind, C, E, ST]),
            {except, {C, E, ST}}
    end.

-spec on_deks_update(cb_deks:dek_kind(), #state{}) -> #state{}.
on_deks_update(Kind, #state{deks = AllDeks} = State) ->
    case maps:find(Kind, AllDeks) of
        {ok, #{deks_being_dropped := CurDeksDropped,
               deks := CurDeks,
               is_enabled := IsEnabled} = CurKindDeks} ->
            DekIds = lists:map(fun (#{id := Id}) -> Id end, CurDeks),
            NewDeksDropped = (CurDeksDropped -- (CurDeksDropped -- DekIds))
                             -- [?NULL_DEK || not IsEnabled],
            NewKindDeks = CurKindDeks#{deks_being_dropped => NewDeksDropped},
            functools:chain(State#state{deks = AllDeks#{Kind => NewKindDeks}},
                            [restart_dek_cleanup_timer(_),
                             restart_dek_rotation_timer(_)]);
        error ->
            State
    end.

-spec set_active(cb_deks:dek_kind(), undefined | cb_deks:dek_id(), boolean(),
                 #state{}) -> #state{}.
set_active(Kind, ActiveId, IsEnabled, #state{deks = DeksInfo} = State) ->
    #{Kind := #{active_id := CurActiveId, deks := CurDeks} = D} = DeksInfo,
    NewDeks =
        case ActiveId of
            undefined -> CurDeks;
            CurActiveId -> CurDeks;
            _ ->
                {ok, NewDek} = encryption_service:read_dek(Kind, ActiveId),
                %% We assume that we never add old keys, only newly generated ones
                false = lists:search(fun (#{id := Id}) ->
                                         Id == ActiveId
                                     end, CurDeks),
                [NewDek | CurDeks]
        end,
    NewD = D#{active_id => ActiveId, is_enabled => IsEnabled, deks => NewDeks},
    NewState = State#state{deks = DeksInfo#{Kind => NewD}},
    write_deks_cfg_file(NewState),
    on_deks_update(Kind, NewState).

-spec write_deks_cfg_file(#state{}) -> ok.
write_deks_cfg_file(#state{deks = DeksInfo}) ->
    Path = deks_file_path(),
    Term = maps:map(
             fun (_Kind, #{is_enabled := IsEnabled,
                           active_id := ActiveId,
                           deks := Deks}) ->
                 cb_deks_raw_utils:new_deks_file_record(
                   ActiveId, IsEnabled, [Id || #{id := Id} <- Deks])
             end, DeksInfo),
    Bin = term_to_binary(Term),

    ConfigDekInfo = case maps:find(configDek, DeksInfo) of
                        {ok, C} -> C;
                        error ->
                            #{is_enabled => false,
                              active_id => undefined,
                              deks => []}
                    end,

    case ConfigDekInfo of
        #{is_enabled := false} ->
            ok = file:write_file(Path, Bin);
        #{is_enabled := true, active_id := CfgActiveId, deks := CfgDeks} ->
            {value, CfgActiveKey} = lists:search(fun (#{id := Id}) ->
                                                         Id == CfgActiveId
                                                 end, CfgDeks),
            DS = cb_crypto:create_deks_snapshot(CfgActiveKey, [CfgActiveKey],
                                                undefined),
            ok = cb_crypto:atomic_write_file(Path, Bin, DS)
    end,
    ok.

-spec deks_file_path() -> string().
deks_file_path() ->
    filename:join(path_config:component_path(data, "config"),
                  ?DEK_CFG_FILENAME).

-spec maybe_read_deks(#state{}) -> #state{}.
maybe_read_deks(#state{proc_type = ?NODE_PROC, deks = undefined} = State) ->
    #state{deks = Deks} = NewState = read_all_deks(State),
    Kinds = maps:keys(Deks),

    {ok, NewState2} = ensure_all_keks_on_disk(NewState),
    NewState3 = lists:foldl(
                  fun (K, Acc) ->
                      {ok, NewAcc} = maybe_reencrypt_deks(K, Acc),
                      NewAcc
                  end, NewState2, Kinds),
    ok = garbage_collect_keks(),
    add_jobs([{maybe_update_deks, K} || K <- Kinds], NewState3);
maybe_read_deks(#state{} = State) ->
    State.

-spec read_all_deks(#state{}) -> #state{}.
read_all_deks(#state{} = State) ->
    GetCfgDek = encryption_service:read_dek(configDek, _),
    {ok, Term} = cb_deks_raw_utils:read_deks_file(deks_file_path(), GetCfgDek),
    Deks = maps:filtermap(
             fun (Kind, #{is_enabled := IsEnabled,
                          active_id := ActiveId,
                          dek_ids := DekIds}) ->
                 {Keys, Errors} = cb_deks:read(Kind, DekIds),
                 case Errors of
                    #{ActiveId := Reason} when IsEnabled ->
                        ?log_warning("Failed to read active ~p DEK: ~p",
                                     [Kind, Reason]),
                        %% Not creating that DEK in configuration
                        %% We can't start using undefined as an active key
                        %% because this can lead to data being decrypted
                        %% which is probably not what we want here. We should
                        %% rather show an error or crash instead of silently
                        %% decrypting the data.
                        %% It is also possible that all deks were removed
                        %% intentinally (with the data). In this case we should
                        %% not crash but rather ignore these deks at all.
                        false;
                    #{} ->
                        %% Ignoring other key errors and hoping that those keys
                        %% will not be needed for data decryption.
                        {true, new_dek_info(ActiveId, Keys, IsEnabled)}
                 end
             end, Term),
    State#state{deks = Deks}.

-spec reread_deks(cb_deks:dek_kind(), #state{}) -> #state{}.
reread_deks(Kind, #state{deks = DeksInfo} = State) ->
    #{Kind := #{deks := CurDeks} = KindDeks} = DeksInfo,
    NewDeks =
        lists:map(
          fun (#{id := DekId}) ->
              {ok, K} = encryption_service:read_dek(Kind, DekId),
              K
          end, CurDeks),
    State#state{deks = DeksInfo#{Kind => KindDeks#{deks => NewDeks}}}.

-spec new_dek_info(undefined | cb_deks:dek_id(), [cb_deks:dek()],
                     boolean()) -> deks_info().
new_dek_info(ActiveId, Keys, IsEnabled) ->
    #{active_id => ActiveId,
      deks => Keys,
      is_enabled => IsEnabled,
      deks_being_dropped => [],
      last_drop_timestamp => undefined,
      has_unencrypted_data => undefined,
      last_deks_gc_datetime => undefined,
      statuses => #{}}.

-spec generate_new_dek(cb_deks:dek_kind(),
                       [cb_deks:dek()],
                       cb_deks:encryption_method(),
                       chronicle_snapshot()) ->
          {ok, cb_deks:dek_id()} | {error, _}.
generate_new_dek(Kind, CurrentDeks, EncryptionMethod, Snapshot) ->
    %% Rotation is needed but if there are too many deks already
    %% we should not generate new deks (something is wrong)
    CurrentDekNum = length(CurrentDeks),
    case CurrentDekNum < ?MAX_DEK_NUM(Kind) of
        true ->
            ?log_debug("Generating new ~p dek, encryption is ~p...",
                       [Kind, EncryptionMethod]),
            ns_server_stats:notify_counter({<<"key_manager_generate_key">>,
                                            [{kind, cb_deks:kind2bin(Kind)}]}),
            cb_deks:generate_new(Kind, EncryptionMethod, Snapshot);
        false ->
            ?log_error("Skip ~p DEK creation/rotation: "
                       "too many DEKs (~p)", [Kind, CurrentDekNum]),
            {error, too_many_deks}
    end.

-spec maybe_reencrypt_deks(cb_deks:dek_kind(), #state{}) ->
          {ok, #state{}} | {error, #state{}, term()}.
maybe_reencrypt_deks(Kind, #state{deks = Deks} = State) ->
    maybe
        {ok, #{deks := Keys}} ?= maps:find(Kind, Deks),
        Snapshot = deks_config_snapshot(Kind),
        {succ, {ok, EncrMethod}} ?= call_dek_callback(
                                      encryption_method_callback,
                                      Kind,
                                      [Snapshot]),
        RV = cb_deks:maybe_reencrypt_deks(Kind, Keys, EncrMethod, Snapshot),
        ?log_debug("Maybe reencrypt dek for ~p ~p ~p. Result: ~p",
                   [Kind, Keys, EncrMethod, RV]),
        case RV of
            no_change ->
                {ok, State};
            {changed, Errors} ->
                NewState = on_deks_update(Kind, reread_deks(Kind, State)),
                case Errors of
                    [] -> {ok, NewState};
                    _ -> {error, NewState, Errors}
                end;
            {error, Error} ->
                {error, State, Error}
        end
    else
        error ->
            {ok, State};
        {succ, {error, not_found}} ->
            {ok, State}
    end.

-spec deks_config_snapshot(cb_deks:dek_kind()) -> chronicle_snapshot().
deks_config_snapshot(Kind) ->
    DekKeys = maps:get(chronicle_txn_keys, cb_deks:dek_config(Kind)),
    {ok, {Snapshot, _}} = chronicle_kv:get_snapshot(kv,
                                                    [?CHRONICLE_SECRETS_KEY |
                                                     DekKeys]),
    Snapshot.

-spec get_all_keys_from_props(secret_props()) -> [key_id()].
get_all_keys_from_props(#{type := ?GENERATED_KEY_TYPE,
                          data := #{keys := Keys}}) ->
    lists:map(fun (#{id := Id}) -> Id end, Keys);
get_all_keys_from_props(#{type := ?AWSKMS_KEY_TYPE,
                          data := #{stored_ids := StoredIds}}) ->
    lists:map(fun (#{id := Id}) -> Id end, StoredIds);
get_all_keys_from_props(#{type := ?KMIP_KEY_TYPE,
                          data := #{active_key := AK, hist_keys := Keys}}) ->
    lists:map(fun (#{id := Id}) -> Id end, [AK | Keys]).

-spec validate_secret_in_txn(secret_props(), #{} | secret_props(),
                             chronicle_snapshot()) ->
                                            ok | {error, bad_encrypt_id() |
                                                         bad_usage_change()}.
validate_secret_in_txn(NewProps, PrevProps, Snapshot) ->
    maybe
        ok ?= validate_secrets_encryption_usage_change(NewProps, PrevProps,
                                                       Snapshot),
        ok ?= validate_dek_related_usage_change(NewProps, PrevProps, Snapshot),
        ok ?= validate_encryption_secret_id(NewProps, Snapshot),
        ok ?= validate_for_config_encryption(NewProps, Snapshot),
        ok ?= validate_name_uniqueness(NewProps, Snapshot)
    end.

-spec execute_on_master({module(), atom(), [term()]}) -> term().
execute_on_master({_, _, _} = MFA) ->
    misc:wait_for_global_name(cb_cluster_secrets_master),
    case gen_server:call(?MASTER_MONITOR_NAME, {call, MFA}, 60000) of
        {succ, Res} -> Res;
        {exception, {C, E, ST}} -> erlang:raise(C, E, ST)
    end.

-spec can_delete_secret(secret_props(), chronicle_snapshot()) ->
                                            ok | {error, secret_in_use()}.
can_delete_secret(#{id := Id}, Snapshot) ->
    %% Places where this secret is used directly in encryption configuration
    EncryptionConfigUsages =
        lists:filtermap(
          fun (Kind) ->
               case call_dek_callback(encryption_method_callback, Kind,
                                      [Snapshot]) of
                  {succ, {ok, {secret, Id}}} ->
                      {true, Kind};
                  {succ, {ok, _}} ->
                      false;
                  {succ, {error, not_found}} ->
                      false
              end
          end, cb_deks:dek_kinds_list(Snapshot)),
    %% Places where this secret is used for encryption of another secrets
    Secrets = get_secrets_used_by_secret_id(Id, Snapshot),
    %% Places where this secret is used to encrypt deks (such deks can exist
    %% even if encryption is disabled for this entity)
    Deks = get_dek_kinds_used_by_secret_id(Id, Snapshot),
    SecretNames =
        lists:map(fun (SId) ->
                      {ok, #{name := SName}} = get_secret(SId, Snapshot),
                      SName
                  end, Secrets),

    case length(EncryptionConfigUsages) + length(SecretNames) + length(Deks) of
        0 -> ok;
        _ ->
            M = #{by_config => EncryptionConfigUsages,
                  by_secrets => SecretNames,
                  by_deks => Deks},
            {error, {used_by, M}}
    end.

-spec get_secrets_used_by_secret_id(secret_id(), chronicle_snapshot()) ->
                                                                [secret_id()].
get_secrets_used_by_secret_id(SecretId, Snapshot) ->
    lists:filtermap(
      fun (#{id := Id} = Props) ->
          case lists:member(SecretId, get_secrets_that_encrypt_props(Props)) of
              true -> {true, Id};
              false -> false
          end
      end, get_all(Snapshot)).

-spec get_secrets_that_encrypt_props(secret_props()) -> [secret_id()].
get_secrets_that_encrypt_props(#{type := ?GENERATED_KEY_TYPE,
                                 data := #{keys := Keys} = Data}) ->
    L = case Data of
            #{encrypt_by := clusterSecret, encrypt_secret_id := Id} -> [Id];
            #{} -> []
        end ++
        lists:filtermap(
          fun (#{key_material := #{encrypted_by := {Id, _}}}) -> {true, Id};
              (#{key_material := #{encrypted_by := undefined}}) -> false
          end, Keys),
    lists:uniq(L);
get_secrets_that_encrypt_props(#{type := ?AWSKMS_KEY_TYPE}) ->
    [];
get_secrets_that_encrypt_props(#{type := ?KMIP_KEY_TYPE,
                                 data := #{key_passphrase := KP} = Data}) ->
    L = case Data of
            #{encrypt_by := clusterSecret, encrypt_secret_id := Id} -> [Id];
            #{} -> []
        end ++
        case KP of
            #{encrypted_by := {Id, _}} -> [Id];
            #{encrypted_by := undefined} -> []
        end,
    lists:uniq(L).

-spec get_dek_kinds_used_by_secret_id(secret_id(), chronicle_snapshot()) ->
                                                        [cb_deks:dek_kind()].
get_dek_kinds_used_by_secret_id(Id, Snapshot) ->
    Map = chronicle_compat:get(Snapshot,
                               ?CHRONICLE_DEK_COUNTERS_KEY,
                               #{default => #{}}),
    maps:keys(maps:get({secret, Id}, Map, #{})).

-spec get_active_key_id_from_secret(secret_props()) -> {ok, key_id()} |
                                                       {error, not_supported}.
get_active_key_id_from_secret(#{type := ?GENERATED_KEY_TYPE,
                                data := #{active_key_id := Id}}) ->
    {ok, Id};
get_active_key_id_from_secret(#{type := ?AWSKMS_KEY_TYPE,
                                data := #{stored_ids := [#{id := Id} | _]}}) ->
    {ok, Id};
get_active_key_id_from_secret(#{type := ?KMIP_KEY_TYPE,
                                data := #{active_key := #{id := Id}}}) ->
    {ok, Id};
get_active_key_id_from_secret(#{}) ->
    {error, not_supported}.

-spec maybe_reencrypt_secrets() -> ok | {error, no_quorum}.
maybe_reencrypt_secrets() ->
    RV = chronicle_transaction(
           [?CHRONICLE_SECRETS_KEY],
           fun (Snapshot) ->
               All = get_all(Snapshot),
               KeksMap =
                   maps:from_list(
                     lists:filtermap(
                       fun (#{id := Id} = P) ->
                           maybe
                               {ok, KekId} ?= get_active_key_id_from_secret(P),
                               {true, {Id, KekId}}
                           else
                               {error, not_supported} ->
                                   false
                           end
                       end, All)),
               GetActiveId = fun (SId) -> {ok, maps:get(SId, KeksMap)} end,
               {NewSecretsList, {IsChanged, AllErrors}} =
                   lists:mapfoldl(
                     fun (Secret, {ChangedAcc, ErrorsAcc}) ->
                         case maybe_reencrypt_secret_txn(Secret, GetActiveId) of
                             {true, NewSecret} -> {NewSecret, {true, ErrorsAcc}};
                             false -> {Secret, {ChangedAcc, ErrorsAcc}};
                             {error, E} -> {Secret, {ChangedAcc, [E|ErrorsAcc]}}
                         end
                     end, {false, []}, All),
               case {IsChanged, AllErrors} of
                   {false, [_ | _]} -> {abort, {error, AllErrors}};
                   {false, []} -> {abort, no_change};
                   {true, _} ->
                       %% In theory reencryption should never lead to any
                       %% cycles in graph, but we still should check it
                       ok = validate_secrets_consistency(NewSecretsList),
                       {commit, [{set, ?CHRONICLE_SECRETS_KEY, NewSecretsList}],
                        AllErrors}
               end
           end),
    case RV of
        {ok, []} ->
            sync_with_node_monitor(),
            ok;
        {ok, Errors} ->
            %% Some secrets were reencrypted, but some of them returned errors
            {error, Errors};
        no_change -> ok;
        {error, _} = Error -> Error
    end.

-spec ensure_secret_encrypted_txn(secret_props(), chronicle_snapshot()) ->
          {ok, secret_props()} |
          {error, encryption_service:stored_key_error() | bad_encrypt_id()}.
ensure_secret_encrypted_txn(Props, Snapshot) ->
    GetActiveId = get_active_key_id(_, Snapshot),
    case maybe_reencrypt_secret_txn(Props, GetActiveId) of
        {true, NewProps} -> {ok, NewProps};
        false -> {ok, Props};
        {error, _} = Error -> Error
    end.

-spec maybe_reencrypt_secret_txn(secret_props(),
                                 fun ((secret_id()) -> key_id())) ->
          false | {true, secret_props()} |
          {error, encryption_service:stored_key_error() | bad_encrypt_id()}.
maybe_reencrypt_secret_txn(#{type := ?GENERATED_KEY_TYPE} = Secret,
                           GetActiveId) ->
    #{data := #{keys := Keys} = Data} = Secret,
    case maybe_reencrypt_keks(Keys, Secret, GetActiveId) of
        {ok, NewKeks} -> {true, Secret#{data => Data#{keys => NewKeks}}};
        no_change -> false;
        {error, _} = Error -> Error
    end;
maybe_reencrypt_secret_txn(#{type := ?KMIP_KEY_TYPE} = Secret, GetActiveId) ->
    #{data := Data} = Secret,
    Pass = maps:get(key_passphrase, Data),
    EncryptBy = maps:get(encrypt_by, Data, undefined),
    SecretId = maps:get(encrypt_secret_id, Data, undefined),
    AD = secret_ad(Secret),

    case maybe_reencrypt_data(Pass, AD, EncryptBy, SecretId, GetActiveId) of
        {ok, NewPass} ->
            {true, Secret#{data => Data#{key_passphrase => NewPass}}};
        no_change ->
            false;
        {error, E} ->
            {error, E}
    end;
maybe_reencrypt_secret_txn(#{}, _) ->
    false.

-spec maybe_reencrypt_keks([kek_props()], secret_props(),
                           fun ((secret_id()) -> key_id())) ->
          {ok, [kek_props()]} | no_change |
          {error, encryption_service:stored_key_error() | bad_encrypt_id()}.
maybe_reencrypt_keks(Keys, #{data := SecretData} = Secret, GetActiveId) ->
    try
        EncryptBy = maps:get(encrypt_by, SecretData, undefined),
        SecretId = maps:get(encrypt_secret_id, SecretData, undefined),

        RV = lists:mapfoldl(
               fun (#{key_material := KeyData} = Key,Acc) ->
                   SecretAD = secret_ad(Secret),
                   AD = auto_generated_key_ad(SecretAD, Key),
                   case maybe_reencrypt_data(KeyData, AD, EncryptBy, SecretId,
                                             GetActiveId) of
                       no_change ->
                           {Key, Acc};
                       {ok, NewKeyData} ->
                           {Key#{key_material => NewKeyData}, changed};
                       {error, _} = E ->
                           throw(E)
                   end
               end, no_change, Keys),
        case RV of
            {NewKeyList, changed} -> {ok, NewKeyList};
            {_, no_change} -> no_change
        end
    catch
        throw:{error, _} = Error -> Error
    end.

-spec secret_ad(secret_props()) -> binary().
secret_ad(#{id := Id, type := T, creation_time := CT}) ->
    CTISO = iso8601:format(CT),
    iolist_to_binary([integer_to_binary(Id), atom_to_binary(T), CTISO]).

-spec auto_generated_key_ad(binary(), kek_props()) -> binary().
auto_generated_key_ad(SecretAD, #{id := Id, creation_time := CT}) ->
    CTISO = iso8601:format(CT),
    iolist_to_binary([SecretAD, Id, CTISO]).

-spec maybe_reencrypt_data(sensitive_data(),
                           binary(),
                           nodeSecretManager | clusterSecret,
                           undefined | secret_id(),
                           fun ((secret_id()) -> key_id())) ->
          {ok, sensitive_data()} |
          no_change |
          {error, encryption_service:stored_key_error() | bad_encrypt_id()}.
maybe_reencrypt_data(Data, AD, EncryptBy, SecretId, GetActiveId) ->
    case EncryptBy of
        nodeSecretManager -> maybe_reencrypt_data(Data, AD, undefined);
        clusterSecret ->
            case GetActiveId(SecretId) of
                {ok, KekId} ->
                    maybe_reencrypt_data(Data, AD, {SecretId, KekId});
                {error, not_found} ->
                    {error, {encrypt_id, not_found}};
                {error, not_supported} ->
                    {error, {encrypt_id, not_allowed}}
            end
    end.

-spec maybe_reencrypt_data(sensitive_data(), binary(),
                           undefined | {secret_id(), key_id()}) ->
          {ok, sensitive_data()} |
          no_change |
          {error, encryption_service:stored_key_error()}.
%% Already encrypted with correct key
maybe_reencrypt_data(#{type := encrypted, data := _Bin,
                       encrypted_by := EncryptedBy},
                     _AD,
                     EncryptedBy) ->
    no_change;
%% Encrypted with wrong key, should reencrypt
maybe_reencrypt_data(#{type := encrypted, data := Bin,
                       encrypted_by := {_SecretId, KekId}},
                     AD,
                     {NewSecretId, NewKekId}) ->
    maybe
        {ok, RawBin} ?= encryption_service:decrypt_key(Bin, AD, KekId),
        {ok, NewBin} ?= encryption_service:encrypt_key(RawBin, AD, NewKekId),
        {ok, #{type => encrypted, data => NewBin,
               encrypted_by => {NewSecretId, NewKekId}}}
    end;
%% Encrypted, but we want it to be unencrypted (encrypted by node SM actually)
maybe_reencrypt_data(#{type := encrypted, data := Bin,
                       encrypted_by := {_SecretId, KekId}},
                     AD,
                     undefined) ->
    maybe
        {ok, RawBin} ?= encryption_service:decrypt_key(Bin, AD, KekId),
        {ok, #{type => sensitive, data => RawBin, encrypted_by => undefined}}
    end;
%% Not encrypted but should be
maybe_reencrypt_data(#{type := sensitive, data := Bin,
                       encrypted_by := undefined},
                     AD,
                     {NewSecretId, NewKekId}) ->
    maybe
        {ok, NewBin} ?= encryption_service:encrypt_key(Bin, AD, NewKekId),
        {ok, #{type => encrypted, data => NewBin,
               encrypted_by => {NewSecretId, NewKekId}}}
    end;
%% Not encrypted, and that's right
maybe_reencrypt_data(#{type := sensitive, data := _Bin,
                       encrypted_by := undefined},
                     _AD,
                     undefined) ->
    no_change.

-spec add_jobs([node_job()] | [master_job()], #state{}) -> #state{}.
add_jobs(NewJobs, State) ->
    ensure_timer_started(retry_jobs, ?RETRY_TIME,
                         add_jobs_to_state(NewJobs, State)).

add_jobs_to_state(NewJobs, #state{jobs = Jobs} = State) ->
    State#state{jobs = Jobs ++ (NewJobs -- Jobs)}.

-spec add_and_run_jobs([node_job()] | [master_job()], #state{}) -> #state{}.
add_and_run_jobs(NewJobs, State) ->
    run_jobs(add_jobs_to_state(NewJobs, State)).

-spec run_jobs(#state{}) -> #state{}.
run_jobs(#state{jobs = Jobs, proc_type = ProcType} = State) ->
    NewState = lists:foldl(fun run_job/2, State#state{jobs = []}, Jobs),

    misc:flush({timer, retry_jobs}),
    case NewState#state.jobs of
        [] ->
            ?log_debug("[~p] All jobs completed", [ProcType]),
            stop_timer(retry_jobs, NewState);
        [_ | _] ->
            restart_timer(retry_jobs, ?RETRY_TIME, NewState)
    end.

-spec run_job(node_job() | master_job(), #state{}) -> #state{}.
run_job(J, State) ->
    ?log_debug("Starting job: ~p", [J]),
    {Res, NewState} = normalize_job_res(do(J, State), State),
    NewState2 = update_job_status(J, Res, NewState),
    NotifyCounter = ?cut(ns_server_stats:notify_counter(
                         {<<"key_manager_job_results">>,
                          [{job_name, job2bin(J)}, {res, _}]})),
    case Res of
        ok ->
            ?log_debug("Job complete: ~p", [J]),
            NotifyCounter(ok),
            NewState2;
        retry ->
            NotifyCounter(retry),
            ?log_debug("Job ~p returned 'retry'", [J]),
            add_jobs_to_state([J], NewState2);
        {error, Error} ->
            NotifyCounter(error),
            ?log_error("Job ~p returned error: ~p", [J, Error]),
            add_jobs_to_state([J], NewState2)
    end.

-spec normalize_job_res(Res :: term(), #state{}) -> {ok | retry | {error, _}, #state{}}.
normalize_job_res(ok, State) -> {ok, State};
normalize_job_res({ok, State}, _) -> {ok, State};
normalize_job_res({error, State, retry}, _) -> {retry, State};
normalize_job_res({error, retry}, State) -> {retry, State};
normalize_job_res({error, State, Reason}, _) -> {{error, Reason}, State};
normalize_job_res({error, Reason}, State) -> {{error, Reason}, State}.

-spec update_job_status(node_job() | master_job(),
                        ok | retry |{error, _},
                        #state{}) -> #state{}.
update_job_status({Name, Kind}, Res, #state{deks = DeksInfo} = State) ->
    case maps:find(Kind, DeksInfo) of
        {ok, #{statuses := S} = D} ->
            NewDeksInfo = DeksInfo#{Kind => D#{statuses => S#{Name => Res}}},
            State#state{deks = NewDeksInfo};
        error ->
            State
    end;
update_job_status(_, _Res, #state{} = State) ->
    State.

-spec do(node_job() | master_job(), #state{}) ->
          ok | {ok, #state{}} | retry | {error, _} | {error, #state{}, _}.
do(garbage_collect_keks, _) ->
    garbage_collect_keks();
do(ensure_all_keks_on_disk, State) ->
    ensure_all_keks_on_disk(State);
do(maybe_reencrypt_secrets, _) ->
    maybe_reencrypt_secrets();
do(maybe_reset_deks_counters, _) ->
    maybe_reset_deks_counters();
do({maybe_update_deks, Kind}, State) ->
    maybe_update_deks(Kind, State);
do({garbage_collect_deks, Kind}, State) ->
    garbage_collect_deks(Kind, false, State);
do({maybe_reencrypt_deks, K}, State) ->
    maybe_reencrypt_deks(K, State).

-spec stop_timer(Name :: atom(), #state{}) -> #state{}.
stop_timer(Name, #state{timers = Timers} = State) ->
    case maps:get(Name, Timers) of
        undefined -> State;
        Ref when is_reference(Ref) ->
            erlang:cancel_timer(Ref),
            State#state{timers = Timers#{Name => undefined}}
    end.

-spec restart_timer(Name :: atom(), Time :: non_neg_integer(), #state{}) ->
          #state{}.
restart_timer(Name, Time, #state{timers = Timers} = State) ->
    NewState = stop_timer(Name, State),
    ?log_debug("Starting ~p timer for ~b...", [Name, Time]),
    Ref = erlang:send_after(Time, self(), {timer, Name}),
    NewState#state{timers = Timers#{Name => Ref}}.

-spec ensure_timer_started(Name :: atom(), Time :: non_neg_integer(),
                           #state{}) ->
          #state{}.
ensure_timer_started(Name, Time, #state{timers = Timers} = State) ->
    case maps:get(Name, Timers) of
        undefined -> restart_timer(Name, Time, State);
        Ref when is_reference(Ref) -> State
    end.

-spec restart_rotation_timer(#state{}) -> #state{}.
restart_rotation_timer(#state{proc_type = ?NODE_PROC} = State) ->
    State;
restart_rotation_timer(#state{proc_type = ?MASTER_PROC} = State) ->
    CurDateTime = calendar:universal_time(),
    Time = calculate_next_rotation_time(CurDateTime, get_all()),
    ?log_debug("Starting rotation timer for ~b...", [Time]),
    restart_timer(rotate_keks, Time, State).

-spec calculate_next_rotation_time(calendar:datetime(), [secret_props()]) ->
                                            TimeInMs :: non_neg_integer().
calculate_next_rotation_time(CurDateTime, Secrets) ->
    Times = [T || S <- Secrets, T <- [get_rotation_time(S)], T =/= undefined],
    time_to_first_event(CurDateTime, Times).

-spec get_rotation_time(secret_props()) -> calendar:datetime() | undefined.
get_rotation_time(#{type := ?GENERATED_KEY_TYPE,
                    data := #{auto_rotation := true,
                              next_rotation_time := Next}}) ->
    Next;
get_rotation_time(#{}) ->
    undefined.

-spec time_to_first_event(calendar:datetime(), [calendar:datetime()]) ->
          non_neg_integer().
time_to_first_event(_CurDateTime, []) -> ?MAX_RECHECK_ROTATION_INTERVAL;
time_to_first_event(CurDateTime, EventTimes) ->
    MinDateTime = lists:min(EventTimes),
    CurSec = calendar:datetime_to_gregorian_seconds(CurDateTime),
    MinSec = calendar:datetime_to_gregorian_seconds(MinDateTime),
    TimeRemains = max(?MIN_RECHECK_ROTATION_INTERVAL, (MinSec - CurSec) * 1000),
    min(?MAX_RECHECK_ROTATION_INTERVAL, TimeRemains).

-spec restart_dek_cleanup_timer(#state{}) -> #state{}.
restart_dek_cleanup_timer(#state{proc_type = ?MASTER_PROC} = State) ->
    State;
restart_dek_cleanup_timer(#state{proc_type = ?NODE_PROC,
                                 deks = DeksInfo} = State) ->
    CurDateTime = calendar:universal_time(),
    Time = calculate_next_dek_cleanup(CurDateTime, DeksInfo),
    restart_timer(dek_cleanup, Time, State).

-spec calculate_next_dek_cleanup(calendar:datetime(), #{}) ->
          TimeInMs :: non_neg_integer().
calculate_next_dek_cleanup(CurDateTime, DeksInfo) ->
    Times =
        maps:fold(
          fun (Kind, KindDeks, Acc) ->
              #{deks_being_dropped := IdsBeingDropped,
                last_drop_timestamp := LastDropTS} = KindDeks,
              DropRetryInterval = ?DEK_DROP_RETRY_TIME_S(Kind),
              case dek_expiration_times(Kind, KindDeks) of
                  {ok, ExpirationTimes} ->
                      ?log_debug("~p DEKs expiration times: ~0p, deks already "
                                 "being dropped: ~0p (last drop time: ~0p)",
                                 [Kind, ExpirationTimes, IdsBeingDropped,
                                  LastDropTS]),
                      lists:map(
                        fun ({DT, Id}) ->
                            case lists:member(Id, IdsBeingDropped) of
                                true ->
                                    LastDropDT =
                                        calendar:gregorian_seconds_to_datetime(
                                          LastDropTS),
                                    misc:datetime_add(LastDropDT,
                                                      DropRetryInterval);
                                false ->
                                    DT
                            end
                        end, ExpirationTimes) ++ Acc;
                  {error, not_found} ->
                      %% Assume there is not such entity anymore, we just
                      %% haven't removed deks yet, ignoring them
                      Acc;
                  {error, _} ->
                      [misc:datetime_add(CurDateTime,
                                         ?DEK_TIMER_RETRY_TIME_S) | Acc]
              end
          end, [], DeksInfo),
    time_to_first_event(CurDateTime, Times).

-spec get_expired_deks(cb_deks:dek_kind(), deks_info()) ->
          [cb_deks:dek_id() | ?NULL_DEK].
get_expired_deks(Kind, DeksInfo) ->
    case dek_expiration_times(Kind, DeksInfo) of
        {ok, DekExpirationTimes} ->
            CurDateTime = calendar:universal_time(),
            lists:filtermap(fun ({ExpirationTime, Id}) ->
                                case CurDateTime >= ExpirationTime of
                                    true -> {true, Id};
                                    false -> false
                                end
                            end, DekExpirationTimes);
        {error, _} -> []
    end.

-spec dek_expiration_times(cb_deks:dek_kind(), deks_info()) ->
          {ok, [{calendar:datetime(), cb_deks:dek_id() | ?NULL_DEK}]} |
          {error, _}.
dek_expiration_times(Kind, #{deks := Deks, is_enabled := IsEnabled,
                             has_unencrypted_data := HasUnencryptedData}) ->
    Snapshot = deks_config_snapshot(Kind),
    maybe
        {succ, {ok, LifeTimeInSec}} ?=
            call_dek_callback(lifetime_callback, Kind, [Snapshot]),
        {succ, {ok, DropKeysTS}} ?=
            call_dek_callback(drop_keys_timestamp_callback, Kind, [Snapshot]),
        RegularKeyTimes =
            lists:filtermap(
              fun (#{id := Id} = Key) ->
                  case dek_expiration_time(LifeTimeInSec, DropKeysTS, Key) of
                      {value, DT} -> {true, {DT, Id}};
                      false -> false
                  end
              end, Deks),
        EmptyKeyTimes =
            case DropKeysTS =/= undefined andalso IsEnabled
                 andalso HasUnencryptedData of
                true -> [{DropKeysTS, ?NULL_DEK}];
                %% This means HasUnencryptedData is undefined. We assume that
                %% bucket has unencrypted data in this case, just in case
                undefined -> [{DropKeysTS, ?NULL_DEK}];
                false -> []
            end,
        {ok, RegularKeyTimes ++ EmptyKeyTimes}
    else
        {succ, {error, not_found}} ->
            {error, not_found};
        {except, Err} ->
            {error, Err}
    end.

dek_expiration_time(undefined, undefined, _) -> false;
dek_expiration_time(undefined, DropKeysTS,
                    #{type := 'raw-aes-gcm',
                      info := #{creation_time := CreationTime}}) ->
    %% Note: We should not treat keys with CreationTime == DropKeysTS as expired
    %% because newly created keys will be treated as expired then
    case CreationTime < DropKeysTS of
        true -> {value, DropKeysTS};
        false -> false
    end;
dek_expiration_time(LifetimeInSec, undefined,
                    #{type := 'raw-aes-gcm',
                      info := #{creation_time := CreationTime}}) ->
    {value, misc:datetime_add(CreationTime, LifetimeInSec)};
dek_expiration_time(LifetimeInSec, DropKeysTS,
                    #{type := 'raw-aes-gcm',
                      info := #{creation_time := CreationTime}}) ->
    ExpDT = misc:datetime_add(CreationTime, LifetimeInSec),
    %% Note: We should not treat keys with CreationTime == DropKeysTS as expired
    %% because newly created keys will be treated as expired then
    case CreationTime < DropKeysTS of
        true -> {value, min(ExpDT, DropKeysTS)};
        false -> {value, ExpDT}
    end.

-spec restart_dek_rotation_timer(#state{}) -> #state{}.
restart_dek_rotation_timer(#state{proc_type = ?MASTER_PROC} = State) ->
    State;
restart_dek_rotation_timer(#state{proc_type = ?NODE_PROC,
                                  deks = Deks} = State) ->
    CurDT = calendar:universal_time(),
    Times =
        maps:fold(fun (Kind, KindDeks, Acc) ->
                      Snapshot = deks_config_snapshot(Kind),
                      case dek_rotation_time(Kind, KindDeks, Snapshot) of
                          {value, ExpDT} -> [ExpDT | Acc];
                          false -> Acc;
                          {error, _} ->
                              [misc:datetime_add(CurDT,
                                                 ?DEK_TIMER_RETRY_TIME_S) | Acc]
                      end
                  end, [], Deks),
    TimerTime = time_to_first_event(CurDT, Times),
    restart_timer(rotate_deks, TimerTime, State).

-spec dek_rotation_needed(cb_deks:dek_kind(), deks_info(), calendar:datetime(),
                          chronicle_snapshot()) -> boolean().
dek_rotation_needed(Kind, KindDeks, CurDT, Snapshot) ->
    case dek_rotation_time(Kind, KindDeks, Snapshot) of
        {value, ExpDT} -> ExpDT =< CurDT;
        false -> false;
        {error, _} -> false
    end.

-spec dek_rotation_time(cb_deks:dek_kind(), deks_info(),
                        chronicle_snapshot()) ->
          {value, calendar:datetime()} | false | {error, _}.
dek_rotation_time(_Kind, #{is_enabled := false}, _Snapshot) ->
    false;
dek_rotation_time(Kind, #{is_enabled := true, active_id := ActiveId,
                          deks := Keys}, Snapshot) ->
    {value, #{type := 'raw-aes-gcm',
              info := #{creation_time := CDT}}} =
        lists:search(fun (#{id := Id}) -> Id == ActiveId end, Keys),
    maybe
        %% We should remove all keys that were created before this date:
        {succ, {ok, DKTS}} ?=
            call_dek_callback(drop_keys_timestamp_callback, Kind, [Snapshot]),
        %% This is how often we should create new deks:
        {succ, {ok, RotationInt}} ?=
            call_dek_callback(rotation_int_callback, Kind, [Snapshot]),

        %% Note: We should not treat keys with CDT == DKTS as expired
        %% because newly created keys will be treated as expired then
        Candidates = [DKTS || DKTS /= undefined, CDT < DKTS] ++
                     [misc:datetime_add(CDT, RotationInt)
                      || RotationInt /= undefined],
        case Candidates of
            [] -> false;
            [_ | _] -> {value, lists:min(Candidates)}
        end
    else
        {succ, {error, not_found}} -> false;
        {succ, {error, R}} ->
            ?log_error("Failed to calculate next rotation time for dek ~p: ~p",
                       [Kind, R]),
            {error, R};
        {except, {_, E, _}} ->
            ?log_error("Failed to calculate next rotation time for dek ~p: ~p",
                       [Kind, E]),
            {error, E}
    end.

validate_for_config_encryption(#{type := T,
                                 data := #{encrypt_by := nodeSecretManager}},
                               Snapshot) when T == ?GENERATED_KEY_TYPE;
                                              T == ?KMIP_KEY_TYPE ->
    case cb_crypto:get_encryption_method(config_encryption, Snapshot) of
        {ok, disabled} -> {error, config_encryption_disabled};
        {ok, _} -> ok
    end;
validate_for_config_encryption(#{}, _Snapshot) ->
    ok.

-spec validate_encryption_secret_id(secret_props(), chronicle_snapshot()) ->
                    ok | {error, bad_encrypt_id()}.
validate_encryption_secret_id(#{type := T,
                                data := #{encrypt_by := clusterSecret,
                                          encrypt_secret_id := Id}},
                              Snapshot) when T == ?GENERATED_KEY_TYPE;
                                             T == ?KMIP_KEY_TYPE ->
    case secret_can_encrypt_secrets(Id, Snapshot) of
        ok -> ok;
        {error, not_found} -> {error, {encrypt_id, not_found}};
        {error, not_allowed} -> {error, {encrypt_id, not_allowed}}
    end;
validate_encryption_secret_id(#{}, _Snapshot) ->
    ok.

-spec secret_can_encrypt_secrets(secret_id(), chronicle_snapshot()) ->
                                        ok | {error, not_found | not_allowed}.
secret_can_encrypt_secrets(SecretId, Snapshot) ->
    case get_secret(SecretId, Snapshot) of
        {ok, #{usage := Usage}} ->
            case lists:member(secrets_encryption, Usage) of
                true -> ok;
                false -> {error, not_allowed}
            end;
        {error, not_found} -> {error, not_found}
    end.

-spec validate_secrets_encryption_usage_change(secret_props(),
                                               #{} | secret_props(),
                                               chronicle_snapshot()) ->
                                            ok | {error, bad_usage_change()}.
validate_secrets_encryption_usage_change(NewProps, PrevProps, Snapshot) ->
    validate_if_usage_removed(
      secrets_encryption, NewProps, PrevProps,
      fun (Id) ->
          case secret_encrypts_other_secrets(Id, Snapshot) of
              true -> {error, {usage, in_use}};
              false -> ok
          end
      end).

validate_dek_related_usage_change(_NewProps, PrevProps, _Snapshot)
                                                        when PrevProps == #{} ->
    ok;
validate_dek_related_usage_change(NewProps, PrevProps, Snapshot) ->
    %% Make sure that all dek users are still allowed to use this secret.
    %% For example, say this secret encrypts bucket "a" and
    %% OldProps contains {bucket_encryption, "a"} in the usage field.
    %% Then the following changes would be allowed:
    %%   1. [{bucket_encryption, "a"}] -> [{bucket_encryption, "*"}].
    %%   2. [{bucket_encryption, "a"}] -> [{bucket_encryption, "a"},
    %%                                     config_encryption].
    %% And the following changes would be disallowed:
    %%   1. [{bucket_encryption, "a"}] -> [{bucket_encryption, "b"}].
    %%   2. [{bucket_encryption, "a"}] -> [config_encryption].
    #{id := Id} = PrevProps,
    %% Check existing deks. If this secret still encrypts any deks, we should
    %% not allow corresponding usage removal
    KindsOfExistingDeks = get_dek_kinds_used_by_secret_id(Id, Snapshot),
    DekKindRequirements =
        fun (Kind) ->
            #{required_usage := Requirement} = cb_deks:dek_config(Kind),
            case lists:member(Kind, KindsOfExistingDeks) of
                true -> {true, Requirement};
                false ->
                    {succ, RV} = call_dek_callback(encryption_method_callback,
                                                   Kind,
                                                   [Snapshot]),
                    case {ok, {secret, Id}} == RV of
                        true -> {true, Requirement};
                        false -> false
                    end
            end
        end,
    InUseList = lists:filtermap(DekKindRequirements,
                                cb_deks:dek_kinds_list(Snapshot)),
    NewUsageList = maps:get(usage, NewProps, []),
    case is_allowed(InUseList, NewUsageList) of
        true -> ok;
        false -> {error, {usage, in_use}}
    end.

is_allowed(Requirements, ListOfAllowedUsages) ->
    lists:all(
      fun (Req) ->
          lists:any(
            fun (Usage) ->
                case Req of
                    Usage -> true;
                    {bucket_encryption, _} -> Usage == {bucket_encryption, "*"};
                    _ -> false
                end
            end,
            ListOfAllowedUsages)
      end, Requirements).

-spec validate_if_usage_removed(secret_usage(), secret_props(),
                                #{} | secret_props(),
                                fun((secret_id()) -> ok | {error, term()})) ->
                                            ok | {error, bad_usage_change()}.
validate_if_usage_removed(Usage, NewProps, PrevProps, Fun) ->
    PrevUsage = maps:get(usage, PrevProps, []),
    NewUsage = maps:get(usage, NewProps, []),
    case (not lists:member(Usage, NewUsage)) andalso
         (lists:member(Usage, PrevUsage)) of
        true ->
            #{id := PrevId} = PrevProps,
            Fun(PrevId);
        false ->
            ok
    end.

-spec secret_encrypts_other_secrets(secret_id(), chronicle_snapshot()) ->
                                                                    boolean().
secret_encrypts_other_secrets(Id, Snapshot) ->
    lists:any(fun (#{type := T,
                     data := #{encrypt_by := clusterSecret,
                               encrypt_secret_id := EncId}})
                                                when T == ?GENERATED_KEY_TYPE;
                                                     T == ?KMIP_KEY_TYPE ->
                      EncId == Id;
                  (#{}) ->
                      false
              end, get_all(Snapshot)).

-spec can_secret_props_encrypt_dek_kind(secret_props(), cb_deks:dek_kind()) ->
          boolean().
can_secret_props_encrypt_dek_kind(#{usage := UsageList}, DekKind) ->
    #{required_usage := Required} = cb_deks:dek_config(DekKind),
    is_allowed([Required], UsageList).

-spec update_secrets(
        fun((secret_props()) -> {value, secret_props()} | false)) ->
          {ok, [UpdatedIds :: secret_id()]} | {error, no_quorum}.
update_secrets(Fun) ->
    RV = chronicle_transaction(
           [?CHRONICLE_SECRETS_KEY],
           fun (Snapshot) ->
               {NewList, ChangedIds} =
                   lists:mapfoldl(fun (#{id := Id} = S, Acc) ->
                                      case Fun(S) of
                                          {value, NewS} -> {NewS, [Id | Acc]};
                                          false -> {S, Acc}
                                      end
                                  end, [], get_all(Snapshot)),
               case ChangedIds of
                   [] -> {abort, no_change};
                   _ ->
                       ok = validate_secrets_consistency(NewList),
                       {commit,
                        [{set, ?CHRONICLE_SECRETS_KEY, NewList}],
                        ChangedIds}
               end
           end),
    case RV of
        {ok, UpdatedIds} -> {ok, UpdatedIds};
        no_change -> {ok, []};
        {error, _} = Error -> Error
    end.

-spec update_next_rotation_time(calendar:datetime(), secret_props()) ->
                                                {value, secret_props()} | false.
update_next_rotation_time(CurTime, #{type := ?GENERATED_KEY_TYPE,
                                     data := Data} = Secret) ->
    case Data of
        #{auto_rotation := true,
          next_rotation_time := NextTime,
          rotation_interval_in_days := IntervalInD}
                                                when CurTime >= NextTime ->
            NextTimeS = calendar:datetime_to_gregorian_seconds(NextTime),
            CurTimeS = calendar:datetime_to_gregorian_seconds(CurTime),
            IntervalS = IntervalInD * ?SECS_IN_DAY,
            %% How many intervals to skip
            %% This is needed for the case when the system was down for a long
            %% time, and it's been more than 1 rotation interval since last
            %% rotation. In other words, NewNextTime must be in future.
            N = (CurTimeS - NextTimeS) div IntervalS + 1,
            NewNextTimeS = NextTimeS + N * IntervalS,
            NewNextTime = calendar:gregorian_seconds_to_datetime(NewNextTimeS),
            NewData = Data#{next_rotation_time => NewNextTime},
            {value, Secret#{data => NewData}};
        #{} ->
            false
    end;
update_next_rotation_time(_CurTime, #{}) ->
    false.

-spec set_last_rotation_time_in_props(secret_props(),
                                      calendar:datetime() | undefined) ->
                                                            secret_props().
set_last_rotation_time_in_props(Secret, undefined) ->
    Secret;
set_last_rotation_time_in_props(#{type := T,
                                  data := Data} = Secret, CurUTCTime)
                                            when T == ?GENERATED_KEY_TYPE;
                                                 T == ?AWSKMS_KEY_TYPE ->
    Secret#{data => Data#{last_rotation_time => CurUTCTime}}.

-spec sync_with_all_node_monitors() -> ok | {error, [atom()]}.
sync_with_all_node_monitors() ->
    Nodes = ns_node_disco:nodes_actual(),
    Res = erpc:multicall(Nodes, ?MODULE, sync_with_node_monitor, [],
                         ?SYNC_TIMEOUT),
    BadNodes = lists:filtermap(
                 fun ({_Node, {ok, _}}) ->
                         false;
                     ({Node, {Class, Exception}}) ->
                         ?log_error("Node ~p sync failed: ~p ~p",
                                    [Node, Class, Exception]),
                         {true, Node}
                 end, lists:zip(Nodes, Res)),
    case BadNodes of
        [] -> ok;
        _ ->
            ?log_error("Sync failed, bad nodes: ~p", [BadNodes]),
            {error, BadNodes}
    end.

%% Every time we start using a secret to encrypt a dek, we increment a counter
%% in chronicle. This is needed so we always have an understanding what secrets
%% are used for what (for example we need this information in order to be able
%% to remove KEKs safely).
%%
%% Current those counter look like the following:
%% #{ {secret, 23} => #{ configDek => 14,
%%                       {bucketDek, "beer-sample"} => 2 },
%%    {secret, 26} => #{ {bucketDek, "travel-sample"} => 6 } }
%%
%% This function is supposed to cleanup these counters by basically removing
%% those dek types that don't use the secret anymore.
%% It asks all the nodes for deks information that they have. Then it calculates
%% what secrets are used to encrypt those deks. Then it removes all dek types
%% from the counters map that don't use the secret anymore.
-spec maybe_reset_deks_counters() ->
          ok | {error, retry | node_errors | missing_nodes | no_quorum}.
maybe_reset_deks_counters() ->
    AllNodes = ns_node_disco:nodes_wanted(),
    MissingNodes = AllNodes -- ns_node_disco:nodes_actual(),
    case MissingNodes of
        [] ->
            case chronicle_kv:get(kv, ?CHRONICLE_DEK_COUNTERS_KEY) of
                {ok, {OldMap, _}} when OldMap == #{} ->
                    ok;
                {ok, {OldMap, _}} ->
                    %% Each node returns information about its deks
                    %% So we can calculate which secrets are actually in use
                    %% and update that information in chronicle
                    Res = erpc:multicall(AllNodes, ?MODULE, get_node_deks_info,
                                         [], ?DEK_COUNTERS_UPDATE_TIMEOUT),
                    {NonErrors, Errors} =
                        misc:partitionmap(fun ({_N, {ok, R}}) -> {left, R};
                                              ({N, E}) -> {right, {N, E}}
                                          end, lists:zip(AllNodes, Res)),

                    %% If some deks have issues we should not remove anything
                    %% until those issues are resolved
                    ShouldRetry =
                        lists:any(
                          fun (L) ->
                              lists:any(fun (#{issues := I}) -> I /= [] end,
                                        maps:values(L))
                          end, NonErrors),
                    OnlyKeys =
                        lists:map(
                          fun (FullInfo) ->
                              maps:filtermap(fun (_, #{deks := K}) -> {true, K};
                                                 (_, #{}) -> false
                                             end, FullInfo)
                          end, NonErrors),

                    case {Errors, ShouldRetry} of
                        {[], false} ->
                            %% Merge deks from all nodes into one map
                            DekInfo = lists:foldl(
                                        fun (M, Acc) ->
                                            maps:merge_with(fun (_, V1, V2) ->
                                                                V1 ++ V2
                                                            end, M, Acc)
                                        end, #{}, OnlyKeys),
                            reset_dek_counters(OldMap, DekInfo);
                        {[], true} ->
                            ?log_debug("Some deks have issues. "
                                       "All responses: ~p", [Res]),
                            {error, retry};
                        {Errors, _} ->
                            ?log_error("Failed to update deks counters because "
                                       "some nodes returned errors: ~p~n"
                                       "All responses: ~p", [Errors, Res]),
                            {error, node_errors}
                    end;
                {error, not_found} ->
                    %% Nothing to update yet
                    ok
            end;
        _ ->
            ?log_debug("Skipping deks counters update because some nodes "
                       "are missing: ~p", [MissingNodes]),
            {error, missing_nodes}
    end.

-spec reset_dek_counters(
        #{EncryptionMethod := Counters},
        #{cb_deks:dek_kind() => [cb_deks:dek()]}) ->
        ok | {error, no_quorum}
        when EncryptionMethod :: {secret, secret_id()} | encryption_service,
             Counters :: #{cb_deks:dek_kind() := non_neg_integer()}.
reset_dek_counters(OldCountersMap, ActualDeksUsageInfo) ->
    Res =
        chronicle_transaction(
          [?CHRONICLE_SECRETS_KEY, ?CHRONICLE_DEK_COUNTERS_KEY],
          fun (Snapshot) ->
              reset_dek_counters_txn(OldCountersMap, ActualDeksUsageInfo,
                                     Snapshot)
          end),

    case Res of
        nothing_changed -> ok;
        ok -> ok;
        {error, _} = Error -> Error
    end.

reset_dek_counters_txn(OldCountersMap, ActualDeksUsageInfo, Snapshot) ->
    KeksToSecrets = get_secret_by_kek_id_map(Snapshot),
    GetEncryptionMethod =
        fun (#{type := 'raw-aes-gcm',
               info := #{encryption_key_id := <<"encryptionService">>}}) ->
                {ok, encryption_service};
             (#{type := 'raw-aes-gcm',
               info := #{encryption_key_id := CurKekId}}) ->
                case maps:find(CurKekId, KeksToSecrets) of
                    {ok, SId} -> {ok, {secret, SId}};
                    error -> error
                end
        end,

    %% Turn #{DekKind => [Dek]} map into #{DekKind => [{secret, SecretId}]} map
    %% It represents information about which dek type uses which secret.
    SecretInfo =
        maps:map(fun (_K, Deks) ->
                     lists:filtermap(
                       fun (D) ->
                           case GetEncryptionMethod(D) of
                               {ok, Res} -> {true, Res};
                               error ->
                                   ?log_error("orphaned dek: ~p", [D]),
                                   false
                           end
                       end, Deks)
                 end, ActualDeksUsageInfo),

    DekStillUsesSecretId =
        fun (DekKind, SecretId) ->
            SecretsIdsList = maps:get(DekKind, SecretInfo, []),
            lists:member(SecretId, SecretsIdsList)
        end,

    %% Filter out those dek types that do not use that secretId anymore.
    FilterCountersForSecret =
        fun (SecretId, Map) -> %% The Map variable here represents all
                               %% dek types that still uses that secret
            maybe
                {ok, OldMap} ?= maps:find(SecretId, OldCountersMap),
                NewMap = maps:filter(
                           fun (DekKind, Counter) ->
                               DekStillUsesSecretId(DekKind, SecretId) orelse
                               %% Checking if counter has changed since before
                               %% we started deks info aggregation;
                               %% If so, that means that something started just
                               %% started using it and we should not remove it
                               %% from the map
                               (Counter /= maps:get(DekKind, OldMap, 0))
                           end, Map),
                case maps:size(NewMap) of
                    0 -> false;
                    _ -> {true, NewMap}
                end
            else
                %% This SecretId was missing in the first check, this means
                %% that something just started using that secret
                error -> true
            end
        end,

    Old = chronicle_compat:get(Snapshot,
                               ?CHRONICLE_DEK_COUNTERS_KEY,
                               #{default => #{}}),
    New = maps:filtermap(FilterCountersForSecret, Old),
    case New == Old of
        true -> {abort, nothing_changed};
        false -> {commit, [{set, ?CHRONICLE_DEK_COUNTERS_KEY, New}]}
    end.

%% Fetches a snapshot in transaction with all dek related chronicle keys,
%% and all secrets related chronicle keys.
fetch_snapshot_in_txn(Txn) ->
    BucketListSnapshot = chronicle_compat:txn_get_many(
                           [ns_bucket:root()], Txn),
    DeksRelatedSnapshot =
        lists:foldl(
          fun (Kind, Acc) ->
              L = maps:get(chronicle_txn_keys, cb_deks:dek_config(Kind)),
              New = chronicle_compat:txn_get_many(L, Txn),
              maps:merge(Acc, New)
          end,
          BucketListSnapshot,
          cb_deks:dek_kinds_list(BucketListSnapshot)),
    SecretsSnapshot = chronicle_compat:txn_get_many(
                        [?CHRONICLE_SECRETS_KEY,
                         ?CHRONICLE_DEK_COUNTERS_KEY,
                         ?CHRONICLE_NEXT_ID_KEY],
                        Txn),
    maps:merge(DeksRelatedSnapshot, SecretsSnapshot).

-spec deks_to_drop(cb_deks:dek_kind(), deks_info() | #state{}) ->
          [cb_deks:dek_id() | ?NULL_DEK].
deks_to_drop(Kind, #state{deks = DeksInfo}) ->
    case maps:find(Kind, DeksInfo) of
        {ok, KindDeks} -> deks_to_drop(Kind, KindDeks);
        error -> []
    end;
deks_to_drop(Kind, KindDeks) ->
    CurTime = calendar:universal_time(),
    NowS = calendar:datetime_to_gregorian_seconds(CurTime),
    ExpiredIds = get_expired_deks(Kind, KindDeks),
    #{deks_being_dropped := AlreadyBeingDropped,
      last_drop_timestamp := LastDropS} = KindDeks,
    DropRetryInterval = ?DEK_DROP_RETRY_TIME_S(Kind),
    LastDropTime = case LastDropS of
                       undefined -> undefined;
                       _ -> calendar:gregorian_seconds_to_datetime(LastDropS)
                   end,
    ?log_debug("The following ~p DEKs has expired: ~p~n"
               "Among them DEKs that are already being dropped: ~p~n"
               "Last drop attempt time: ~p",
               [Kind, ExpiredIds, AlreadyBeingDropped, LastDropTime]),
    %% If we have already started dropping something, we should continue
    %% even if it is not "expired" anymore.
    AllExpired = lists:usort(ExpiredIds ++ AlreadyBeingDropped),
    ToDrop =
        maybe
            #{is_enabled := true, active_id := ActiveId} ?= KindDeks,
            true ?= lists:member(ActiveId, AllExpired),
            ?log_debug("Active DEK (~p) has expired for "
                       "~p (ignoring attempt to drop it)",
                       [ActiveId, Kind]),
            AllExpired -- [ActiveId]
        else
            #{is_enabled := false} ->
                AllExpired;
            false ->
                AllExpired
        end,
    ShouldAttemptDrop =
        case ToDrop -- AlreadyBeingDropped of
            [_|_] ->
                true; %% there are new deks in the list
            [] when ToDrop == [] ->
                false; %% no deks to drop
            [] when NowS > LastDropS + DropRetryInterval ->
                true; %% no new deks to drop, but it's been a while
                      %% since last drop attempt; will retry
            [] ->
                false %% no new deks to drop
        end,
    case ShouldAttemptDrop of
        true -> ToDrop;
        false -> []
    end.

-spec initiate_deks_drop(cb_deks:dek_kind(), [cb_deks:dek_id() | ?NULL_DEK],
                         #state{}) -> #state{}.
initiate_deks_drop(_Kind, [], #state{} = State) -> State;
initiate_deks_drop(Kind, IdsToDrop0, #state{deks = DeksInfo} = State0) ->
    CurTime = calendar:universal_time(),
    NowS = calendar:datetime_to_gregorian_seconds(CurTime),
    #{Kind := KindDeks} = DeksInfo,
    IdsToDrop =
        case DeksInfo of
            #{Kind := #{is_enabled := true}} ->
                %% We have at least one expired dek, and encryption is enabled,
                %% it is probably time to encrypt data that is not encrypted yet
                %% (if there is such data)
                lists:uniq(IdsToDrop0 ++ [?NULL_DEK]);
            #{Kind := #{is_enabled := false}} ->
                %% If encryption is disabled we should never try dropping empty
                %% dek because it beasically means "encrypt everything", which
                %% doesn't make sense in this case
                lists:uniq(IdsToDrop0) -- [?NULL_DEK]
        end,

    ?log_debug("Trying to drop ~p DEKs: ~0p", [Kind, IdsToDrop]),
    ns_server_stats:notify_counter({<<"key_manager_drop_deks">>,
                                    [{kind, cb_deks:kind2bin(Kind)}]}),
    case call_dek_callback(drop_callback, Kind, [IdsToDrop]) of
        {succ, {ok, Res}} ->
            NewKindDeks = KindDeks#{deks_being_dropped => IdsToDrop,
                                    last_drop_timestamp => NowS},
            State = State0#state{deks = DeksInfo#{Kind => NewKindDeks}},
            case Res of
                done ->
                    %% 'done' means that all all ids have been dropped and it is
                    %% safe to remove them
                    AllIds = [Id || #{id := Id} <- maps:get(deks, KindDeks)],
                    IdsInUse = AllIds -- IdsToDrop,
                    retire_unused_deks(Kind, IdsInUse, State);
                started ->
                    State
            end;
        {succ, {error, not_found}} -> State0;
        {succ, {error, retry}} -> State0; %% compaction daemon not started yet
        {succ, {error, Reason}} ->
            ?log_error("drop_callback for ~p returned error: ~p",
                       [Kind, Reason]),
            State0;
        {except, _} ->
            State0
    end.

-spec validate_name_uniqueness(secret_props(), chronicle_snapshot()) ->
          ok | {error, name_not_unique}.
validate_name_uniqueness(#{id := Id, name := Name}, Snapshot) ->
    case is_name_unique(Id, Name, Snapshot) of
        true -> ok;
        false -> {error, name_not_unique}
    end.

-spec validate_secrets_consistency([secret_props()]) ->
          ok | {error, inconsistent_graph()}.
validate_secrets_consistency(Secrets) ->
    %% Make sure secrets graph has no cycles and all ids that are
    %% mentioned in props are actually present
    G = digraph:new([acyclic]),
    try
        lists:foreach(fun (#{id := Id}) -> digraph:add_vertex(G, Id) end,
                      Secrets),
        Res = lists:foldl(
                fun (#{}, {error, _} = Acc) -> Acc;
                    (#{id := Id} = P, ok) ->
                      lists:foldl(
                        fun (_Id2, {error, _} = Acc2) -> Acc2;
                            (Id2, ok) ->
                            case digraph:add_edge(G, Id2, Id) of
                                ['$e' | _] -> ok;
                                {error, _} = E -> E
                            end
                        end, ok, get_secrets_that_encrypt_props(P))
                end, ok, Secrets),
        case Res of
            ok -> ok;
            {error, {bad_edge, Ids}} -> {error, {cycle, Ids}};
            {error, {bad_vertex, Id}} -> {error, {unknown_id, Id}}
        end
    after
        digraph:delete(G)
    end.

-spec sanitize_secret(secret_props()) -> term().
sanitize_secret(#{type := ?GENERATED_KEY_TYPE, data := Data} = S) ->
    #{keys := Keys} = Data,
    NewKeys = lists:map(fun (#{key_material := K} = Key) ->
                                Key#{key_material => sanitize_sensitive_data(K)}
                        end, Keys),
    S#{data => Data#{keys => NewKeys}};
sanitize_secret(#{type := ?KMIP_KEY_TYPE, data := Data} = S) ->
    #{key_passphrase := D} = Data,
    S#{data => Data#{key_passphrase => sanitize_sensitive_data(D)}};
sanitize_secret(#{type := ?AWSKMS_KEY_TYPE} = S) ->
    S.

sanitize_sensitive_data(#{type := sensitive, data := D} = Data) ->
    Data#{data => chronicle_kv_log:sanitize_value(D)};
sanitize_sensitive_data(#{type := encrypted} = Data) ->
    Data.

-spec extract_dek_info(cb_deks:dek_kind(), #state{}) ->
          {ok, external_dek_info()} | {error, not_found}.
extract_dek_info(Kind, #state{deks = DeksInfo}) ->
    StripKeyMaterial =
        fun (Keys) ->
            lists:map(fun (#{type := 'raw-aes-gcm', info := Info} = K) ->
                          K#{info => maps:remove(key, Info)}
                      end, Keys)
        end,

    maybe
        {ok, #{has_unencrypted_data := HasUnencryptedData,
               statuses := Statuses,
               deks := Keys}} ?= maps:find(Kind, DeksInfo),
        Issues = maps:fold(fun (_J, ok, Acc) -> Acc;
                               (J, retry, Acc) -> [{J, pending} | Acc];
                               (J, {error, _}, Acc) -> [{J, failed} | Acc]
                           end, [], Statuses),
        CreationTime = fun (#{type := 'raw-aes-gcm',
                              info := #{creation_time := CT}}) -> CT
                       end,
        HasEncryptedData = length(Keys) > 0,
        Status = case {HasUnencryptedData, HasEncryptedData} of
                     {undefined, _} -> unknown;
                     {true, false} -> unencrypted;
                     {false, true} -> encrypted;
                     {true, true} -> partially_encrypted;
                     {false, false} -> unknown
                 end,
        Res = #{data_status => Status,
                issues => Issues,
                deks => StripKeyMaterial(Keys),
                dek_num => length(Keys)},
        case Keys of
            [] -> {ok, Res};
            _ ->
                MinCreationTime = lists:min([CreationTime(D) || D <- Keys]),
                {ok, Res#{oldest_dek_datetime => MinCreationTime}}
        end
    else
        error -> {error, not_found}
    end.

chronicle_transaction(Keys, Fun) ->
    try chronicle_kv:transaction(kv, Keys, Fun) of
        {ok, _Rev} -> ok;
        {ok, _Rev, Res} -> {ok, Res};
        Else -> Else
    catch
        exit:timeout ->
            ?log_error("Chronicle transaction failed with reason timeout"),
            {error, no_quorum}
    end.

chronicle_compat_txn(Fun) ->
    try chronicle_compat:txn(Fun) of
        {ok, _Rev} -> ok;
        {ok, _Rev, Res} -> {ok, Res};
        Else -> Else
    catch
        exit:timeout ->
            ?log_error("Chronicle transaction failed with reason timeout"),
            {error, no_quorum}
    end.

-spec job2bin(node_job() | master_job()) -> binary().
job2bin({J, K}) ->
    iolist_to_binary([atom_to_binary(J), "_", cb_deks:kind2bin(K)]);
job2bin(J) when is_atom(J) ->
    atom_to_binary(J).

-ifdef(TEST).
replace_secret_in_list_test() ->
    ?assertEqual(false, replace_secret_in_list(#{id => 3, p => 5}, [])),
    ?assertEqual(false,
                 replace_secret_in_list(#{id => 3, p => 5}, [#{id => 4}])),
    ?assertEqual([#{id => 4, p => 1}, #{id => 3, p => 5}, #{id => 1}],
                 replace_secret_in_list(
                   #{id => 3, p => 5},
                   [#{id => 4, p => 1}, #{id => 3, p => 6}, #{id => 1}])).

test_secret(NextTime, Interval, AutoRotation) ->
     #{type => ?GENERATED_KEY_TYPE,
       data => #{auto_rotation => AutoRotation,
                 rotation_interval_in_days => Interval,
                 next_rotation_time => NextTime}}.

calculate_next_rotation_time_test() ->
    CurTime = {{2016, 09, 30}, {16, 00, 00}},
    Secret = ?cut(test_secret(_1, 1, _2)),
    Calc = fun (List) -> calculate_next_rotation_time(CurTime, List) end,
    Min = ?MIN_RECHECK_ROTATION_INTERVAL,
    MinSec = Min div 1000,
    Max = ?MAX_RECHECK_ROTATION_INTERVAL,
    MaxSec = Max div 1000,
    Future = ?cut(misc:datetime_add(CurTime, _)),
    Past = ?cut(misc:datetime_add(CurTime, -(_))),
    ?assertEqual(Max, Calc([])),
    ?assertEqual(Min, Calc([Secret(CurTime, true)])),
    ?assertEqual(Max, Calc([Secret(CurTime, false)])),
    %% next rotation in future:
    ?assertEqual(Min, Calc([Secret(Future(MinSec - 1), true)])),
    ?assertEqual(Min + 1000, Calc([Secret(Future(MinSec + 1), true)])),
    ?assertEqual(Max, Calc([Secret(Future(MaxSec + 1), true)])),
    ?assertEqual(Max - 1000, Calc([Secret(Future(MaxSec - 1), true)])),
    %% next rotation in the past:
    ?assertEqual(Min, Calc([Secret(Past(1), true)])),
    ?assertEqual(Min, Calc([Secret(Past(?SECS_IN_DAY*5), true)])),

    ?assertEqual(Min + 11000,
                 Calc([Secret(Future(MinSec + 20), true),
                       Secret(Future(MinSec + 3),  false),
                       Secret(Future(MinSec + 12), true),
                       Secret(Future(MinSec + 11), true),
                       Secret(Past(1),             false),
                       Secret(Future(MinSec + 23), true)])).

update_next_rotation_time_test() ->
    CurTime = {{2016, 09, 30}, {16, 00, 00}},
    Calc = fun (NextTime, Interval, AutoRotation) ->
               S = test_secret(NextTime, Interval, AutoRotation),
               case update_next_rotation_time(CurTime, S) of
                   {value, #{data := #{next_rotation_time := NewDate}} = Res} ->
                       #{data := D} = S,
                       %% Making sure nothing but next_rotation_time has changed
                       ?assertEqual(
                         S#{data => D#{next_rotation_time => NewDate}}, Res),
                       NewDate;
                   false -> false
               end
           end,
    D = ?SECS_IN_DAY,
    Future = ?cut(misc:datetime_add(CurTime, _)),
    Past = ?cut(misc:datetime_add(CurTime, -(_))),

    ?assertEqual(false,             Calc(CurTime, 3, false)),
    ?assertEqual(false,             Calc(Past(1), 3, false)),
    ?assertEqual(false,             Calc(Future(1), 3, false)),
    ?assertEqual(Future(3 * D),     Calc(CurTime,   3, true)),
    ?assertEqual(false,             Calc(Future(1), 3, true)),
    ?assertEqual(Future(3 * D - 1), Calc(Past(1), 3, true)),
    ?assertEqual(Future(2 * D),     Calc(Past(D), 3, true)),
    ?assertEqual(Future(D),         Calc(Past(2 * D), 3, true)),
    ?assertEqual(Future(3 * D),     Calc(Past(3 * D), 3, true)),
    ?assertEqual(Future(3 * D - 1), Calc(Past(3 * D + 1), 3, true)),
    ?assertEqual(Future(1),         Calc(Past(3 * D - 1), 3, true)),
    ?assertEqual(Future(3 * D - 1), Calc(Past(12 * D + 1), 3, true)),
    ?assertEqual(Future(1),         Calc(Past(12 * D - 1), 3, true)).

-endif.
