{"version":3,"file":"http.js","sources":["../../../node_modules/@angular/common/fesm5/http.js"],"sourcesContent":["/**\n * @license Angular v8.2.14\n * (c) 2010-2019 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { __spread, __read, __extends, __decorate, __metadata, __param } from 'tslib';\nimport { Injectable, InjectionToken, Inject, PLATFORM_ID, Injector, NgModule } from '@angular/core';\nimport { of, Observable } from 'rxjs';\nimport { concatMap, filter, map } from 'rxjs/operators';\nimport { DOCUMENT, ÉµparseCookieValue } from '@angular/common';\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Transforms an `HttpRequest` into a stream of `HttpEvent`s, one of which will likely be a\n * `HttpResponse`.\n *\n * `HttpHandler` is injectable. When injected, the handler instance dispatches requests to the\n * first interceptor in the chain, which dispatches to the second, etc, eventually reaching the\n * `HttpBackend`.\n *\n * In an `HttpInterceptor`, the `HttpHandler` parameter is the next interceptor in the chain.\n *\n * @publicApi\n */\nvar HttpHandler = /** @class */ (function () {\n    function HttpHandler() {\n    }\n    return HttpHandler;\n}());\n/**\n * A final `HttpHandler` which will dispatch the request via browser HTTP APIs to a backend.\n *\n * Interceptors sit between the `HttpClient` interface and the `HttpBackend`.\n *\n * When injected, `HttpBackend` dispatches requests directly to the backend, without going\n * through the interceptor chain.\n *\n * @publicApi\n */\nvar HttpBackend = /** @class */ (function () {\n    function HttpBackend() {\n    }\n    return HttpBackend;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Represents the header configuration options for an HTTP request.\n * Instances are immutable. Modifying methods return a cloned\n * instance with the change. The original object is never changed.\n *\n * @publicApi\n */\nvar HttpHeaders = /** @class */ (function () {\n    /**  Constructs a new HTTP header object with the given values.*/\n    function HttpHeaders(headers) {\n        var _this = this;\n        /**\n         * Internal map of lowercased header names to the normalized\n         * form of the name (the form seen first).\n         */\n        this.normalizedNames = new Map();\n        /**\n         * Queued updates to be materialized the next initialization.\n         */\n        this.lazyUpdate = null;\n        if (!headers) {\n            this.headers = new Map();\n        }\n        else if (typeof headers === 'string') {\n            this.lazyInit = function () {\n                _this.headers = new Map();\n                headers.split('\\n').forEach(function (line) {\n                    var index = line.indexOf(':');\n                    if (index > 0) {\n                        var name_1 = line.slice(0, index);\n                        var key = name_1.toLowerCase();\n                        var value = line.slice(index + 1).trim();\n                        _this.maybeSetNormalizedName(name_1, key);\n                        if (_this.headers.has(key)) {\n                            _this.headers.get(key).push(value);\n                        }\n                        else {\n                            _this.headers.set(key, [value]);\n                        }\n                    }\n                });\n            };\n        }\n        else {\n            this.lazyInit = function () {\n                _this.headers = new Map();\n                Object.keys(headers).forEach(function (name) {\n                    var values = headers[name];\n                    var key = name.toLowerCase();\n                    if (typeof values === 'string') {\n                        values = [values];\n                    }\n                    if (values.length > 0) {\n                        _this.headers.set(key, values);\n                        _this.maybeSetNormalizedName(name, key);\n                    }\n                });\n            };\n        }\n    }\n    /**\n     * Checks for existence of a given header.\n     *\n     * @param name The header name to check for existence.\n     *\n     * @returns True if the header exists, false otherwise.\n     */\n    HttpHeaders.prototype.has = function (name) {\n        this.init();\n        return this.headers.has(name.toLowerCase());\n    };\n    /**\n     * Retrieves the first value of a given header.\n     *\n     * @param name The header name.\n     *\n     * @returns The value string if the header exists, null otherwise\n     */\n    HttpHeaders.prototype.get = function (name) {\n        this.init();\n        var values = this.headers.get(name.toLowerCase());\n        return values && values.length > 0 ? values[0] : null;\n    };\n    /**\n     * Retrieves the names of the headers.\n     *\n     * @returns A list of header names.\n     */\n    HttpHeaders.prototype.keys = function () {\n        this.init();\n        return Array.from(this.normalizedNames.values());\n    };\n    /**\n     * Retrieves a list of values for a given header.\n     *\n     * @param name The header name from which to retrieve values.\n     *\n     * @returns A string of values if the header exists, null otherwise.\n     */\n    HttpHeaders.prototype.getAll = function (name) {\n        this.init();\n        return this.headers.get(name.toLowerCase()) || null;\n    };\n    /**\n     * Appends a new value to the existing set of values for a header\n     * and returns them in a clone of the original instance.\n     *\n     * @param name The header name for which to append the value or values.\n     * @param value The new value or array of values.\n     *\n     * @returns A clone of the HTTP headers object with the value appended to the given header.\n     */\n    HttpHeaders.prototype.append = function (name, value) {\n        return this.clone({ name: name, value: value, op: 'a' });\n    };\n    /**\n     * Sets or modifies a value for a given header in a clone of the original instance.\n     * If the header already exists, its value is replaced with the given value\n     * in the returned object.\n     *\n     * @param name The header name.\n     * @param value The value or values to set or overide for the given header.\n     *\n     * @returns A clone of the HTTP headers object with the newly set header value.\n     */\n    HttpHeaders.prototype.set = function (name, value) {\n        return this.clone({ name: name, value: value, op: 's' });\n    };\n    /**\n     * Deletes values for a given header in a clone of the original instance.\n     *\n     * @param name The header name.\n     * @param value The value or values to delete for the given header.\n     *\n     * @returns A clone of the HTTP headers object with the given value deleted.\n     */\n    HttpHeaders.prototype.delete = function (name, value) {\n        return this.clone({ name: name, value: value, op: 'd' });\n    };\n    HttpHeaders.prototype.maybeSetNormalizedName = function (name, lcName) {\n        if (!this.normalizedNames.has(lcName)) {\n            this.normalizedNames.set(lcName, name);\n        }\n    };\n    HttpHeaders.prototype.init = function () {\n        var _this = this;\n        if (!!this.lazyInit) {\n            if (this.lazyInit instanceof HttpHeaders) {\n                this.copyFrom(this.lazyInit);\n            }\n            else {\n                this.lazyInit();\n            }\n            this.lazyInit = null;\n            if (!!this.lazyUpdate) {\n                this.lazyUpdate.forEach(function (update) { return _this.applyUpdate(update); });\n                this.lazyUpdate = null;\n            }\n        }\n    };\n    HttpHeaders.prototype.copyFrom = function (other) {\n        var _this = this;\n        other.init();\n        Array.from(other.headers.keys()).forEach(function (key) {\n            _this.headers.set(key, other.headers.get(key));\n            _this.normalizedNames.set(key, other.normalizedNames.get(key));\n        });\n    };\n    HttpHeaders.prototype.clone = function (update) {\n        var clone = new HttpHeaders();\n        clone.lazyInit =\n            (!!this.lazyInit && this.lazyInit instanceof HttpHeaders) ? this.lazyInit : this;\n        clone.lazyUpdate = (this.lazyUpdate || []).concat([update]);\n        return clone;\n    };\n    HttpHeaders.prototype.applyUpdate = function (update) {\n        var key = update.name.toLowerCase();\n        switch (update.op) {\n            case 'a':\n            case 's':\n                var value = update.value;\n                if (typeof value === 'string') {\n                    value = [value];\n                }\n                if (value.length === 0) {\n                    return;\n                }\n                this.maybeSetNormalizedName(update.name, key);\n                var base = (update.op === 'a' ? this.headers.get(key) : undefined) || [];\n                base.push.apply(base, __spread(value));\n                this.headers.set(key, base);\n                break;\n            case 'd':\n                var toDelete_1 = update.value;\n                if (!toDelete_1) {\n                    this.headers.delete(key);\n                    this.normalizedNames.delete(key);\n                }\n                else {\n                    var existing = this.headers.get(key);\n                    if (!existing) {\n                        return;\n                    }\n                    existing = existing.filter(function (value) { return toDelete_1.indexOf(value) === -1; });\n                    if (existing.length === 0) {\n                        this.headers.delete(key);\n                        this.normalizedNames.delete(key);\n                    }\n                    else {\n                        this.headers.set(key, existing);\n                    }\n                }\n                break;\n        }\n    };\n    /**\n     * @internal\n     */\n    HttpHeaders.prototype.forEach = function (fn) {\n        var _this = this;\n        this.init();\n        Array.from(this.normalizedNames.keys())\n            .forEach(function (key) { return fn(_this.normalizedNames.get(key), _this.headers.get(key)); });\n    };\n    return HttpHeaders;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Provides encoding and decoding of URL parameter and query-string values.\n *\n * Serializes and parses URL parameter keys and values to encode and decode them.\n * If you pass URL query parameters without encoding,\n * the query parameters can be misinterpreted at the receiving end.\n *\n *\n * @publicApi\n */\nvar HttpUrlEncodingCodec = /** @class */ (function () {\n    function HttpUrlEncodingCodec() {\n    }\n    /**\n     * Encodes a key name for a URL parameter or query-string.\n     * @param key The key name.\n     * @returns The encoded key name.\n     */\n    HttpUrlEncodingCodec.prototype.encodeKey = function (key) { return standardEncoding(key); };\n    /**\n     * Encodes the value of a URL parameter or query-string.\n     * @param value The value.\n     * @returns The encoded value.\n     */\n    HttpUrlEncodingCodec.prototype.encodeValue = function (value) { return standardEncoding(value); };\n    /**\n     * Decodes an encoded URL parameter or query-string key.\n     * @param key The encoded key name.\n     * @returns The decoded key name.\n     */\n    HttpUrlEncodingCodec.prototype.decodeKey = function (key) { return decodeURIComponent(key); };\n    /**\n     * Decodes an encoded URL parameter or query-string value.\n     * @param value The encoded value.\n     * @returns The decoded value.\n     */\n    HttpUrlEncodingCodec.prototype.decodeValue = function (value) { return decodeURIComponent(value); };\n    return HttpUrlEncodingCodec;\n}());\nfunction paramParser(rawParams, codec) {\n    var map = new Map();\n    if (rawParams.length > 0) {\n        var params = rawParams.split('&');\n        params.forEach(function (param) {\n            var eqIdx = param.indexOf('=');\n            var _a = __read(eqIdx == -1 ?\n                [codec.decodeKey(param), ''] :\n                [codec.decodeKey(param.slice(0, eqIdx)), codec.decodeValue(param.slice(eqIdx + 1))], 2), key = _a[0], val = _a[1];\n            var list = map.get(key) || [];\n            list.push(val);\n            map.set(key, list);\n        });\n    }\n    return map;\n}\nfunction standardEncoding(v) {\n    return encodeURIComponent(v)\n        .replace(/%40/gi, '@')\n        .replace(/%3A/gi, ':')\n        .replace(/%24/gi, '$')\n        .replace(/%2C/gi, ',')\n        .replace(/%3B/gi, ';')\n        .replace(/%2B/gi, '+')\n        .replace(/%3D/gi, '=')\n        .replace(/%3F/gi, '?')\n        .replace(/%2F/gi, '/');\n}\n/**\n * An HTTP request/response body that represents serialized parameters,\n * per the MIME type `application/x-www-form-urlencoded`.\n *\n * This class is immutable; all mutation operations return a new instance.\n *\n * @publicApi\n */\nvar HttpParams = /** @class */ (function () {\n    function HttpParams(options) {\n        var _this = this;\n        if (options === void 0) { options = {}; }\n        this.updates = null;\n        this.cloneFrom = null;\n        this.encoder = options.encoder || new HttpUrlEncodingCodec();\n        if (!!options.fromString) {\n            if (!!options.fromObject) {\n                throw new Error(\"Cannot specify both fromString and fromObject.\");\n            }\n            this.map = paramParser(options.fromString, this.encoder);\n        }\n        else if (!!options.fromObject) {\n            this.map = new Map();\n            Object.keys(options.fromObject).forEach(function (key) {\n                var value = options.fromObject[key];\n                _this.map.set(key, Array.isArray(value) ? value : [value]);\n            });\n        }\n        else {\n            this.map = null;\n        }\n    }\n    /**\n     * Reports whether the body includes one or more values for a given parameter.\n     * @param param The parameter name.\n     * @returns True if the parameter has one or more values,\n     * false if it has no value or is not present.\n     */\n    HttpParams.prototype.has = function (param) {\n        this.init();\n        return this.map.has(param);\n    };\n    /**\n     * Retrieves the first value for a parameter.\n     * @param param The parameter name.\n     * @returns The first value of the given parameter,\n     * or `null` if the parameter is not present.\n     */\n    HttpParams.prototype.get = function (param) {\n        this.init();\n        var res = this.map.get(param);\n        return !!res ? res[0] : null;\n    };\n    /**\n     * Retrieves all values for a  parameter.\n     * @param param The parameter name.\n     * @returns All values in a string array,\n     * or `null` if the parameter not present.\n     */\n    HttpParams.prototype.getAll = function (param) {\n        this.init();\n        return this.map.get(param) || null;\n    };\n    /**\n     * Retrieves all the parameters for this body.\n     * @returns The parameter names in a string array.\n     */\n    HttpParams.prototype.keys = function () {\n        this.init();\n        return Array.from(this.map.keys());\n    };\n    /**\n     * Appends a new value to existing values for a parameter.\n     * @param param The parameter name.\n     * @param value The new value to add.\n     * @return A new body with the appended value.\n     */\n    HttpParams.prototype.append = function (param, value) { return this.clone({ param: param, value: value, op: 'a' }); };\n    /**\n     * Replaces the value for a parameter.\n     * @param param The parameter name.\n     * @param value The new value.\n     * @return A new body with the new value.\n     */\n    HttpParams.prototype.set = function (param, value) { return this.clone({ param: param, value: value, op: 's' }); };\n    /**\n     * Removes a given value or all values from a parameter.\n     * @param param The parameter name.\n     * @param value The value to remove, if provided.\n     * @return A new body with the given value removed, or with all values\n     * removed if no value is specified.\n     */\n    HttpParams.prototype.delete = function (param, value) { return this.clone({ param: param, value: value, op: 'd' }); };\n    /**\n     * Serializes the body to an encoded string, where key-value pairs (separated by `=`) are\n     * separated by `&`s.\n     */\n    HttpParams.prototype.toString = function () {\n        var _this = this;\n        this.init();\n        return this.keys()\n            .map(function (key) {\n            var eKey = _this.encoder.encodeKey(key);\n            return _this.map.get(key).map(function (value) { return eKey + '=' + _this.encoder.encodeValue(value); })\n                .join('&');\n        })\n            .join('&');\n    };\n    HttpParams.prototype.clone = function (update) {\n        var clone = new HttpParams({ encoder: this.encoder });\n        clone.cloneFrom = this.cloneFrom || this;\n        clone.updates = (this.updates || []).concat([update]);\n        return clone;\n    };\n    HttpParams.prototype.init = function () {\n        var _this = this;\n        if (this.map === null) {\n            this.map = new Map();\n        }\n        if (this.cloneFrom !== null) {\n            this.cloneFrom.init();\n            this.cloneFrom.keys().forEach(function (key) { return _this.map.set(key, _this.cloneFrom.map.get(key)); });\n            this.updates.forEach(function (update) {\n                switch (update.op) {\n                    case 'a':\n                    case 's':\n                        var base = (update.op === 'a' ? _this.map.get(update.param) : undefined) || [];\n                        base.push(update.value);\n                        _this.map.set(update.param, base);\n                        break;\n                    case 'd':\n                        if (update.value !== undefined) {\n                            var base_1 = _this.map.get(update.param) || [];\n                            var idx = base_1.indexOf(update.value);\n                            if (idx !== -1) {\n                                base_1.splice(idx, 1);\n                            }\n                            if (base_1.length > 0) {\n                                _this.map.set(update.param, base_1);\n                            }\n                            else {\n                                _this.map.delete(update.param);\n                            }\n                        }\n                        else {\n                            _this.map.delete(update.param);\n                            break;\n                        }\n                }\n            });\n            this.cloneFrom = this.updates = null;\n        }\n    };\n    return HttpParams;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Determine whether the given HTTP method may include a body.\n */\nfunction mightHaveBody(method) {\n    switch (method) {\n        case 'DELETE':\n        case 'GET':\n        case 'HEAD':\n        case 'OPTIONS':\n        case 'JSONP':\n            return false;\n        default:\n            return true;\n    }\n}\n/**\n * Safely assert whether the given value is an ArrayBuffer.\n *\n * In some execution environments ArrayBuffer is not defined.\n */\nfunction isArrayBuffer(value) {\n    return typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer;\n}\n/**\n * Safely assert whether the given value is a Blob.\n *\n * In some execution environments Blob is not defined.\n */\nfunction isBlob(value) {\n    return typeof Blob !== 'undefined' && value instanceof Blob;\n}\n/**\n * Safely assert whether the given value is a FormData instance.\n *\n * In some execution environments FormData is not defined.\n */\nfunction isFormData(value) {\n    return typeof FormData !== 'undefined' && value instanceof FormData;\n}\n/**\n * An outgoing HTTP request with an optional typed body.\n *\n * `HttpRequest` represents an outgoing request, including URL, method,\n * headers, body, and other request configuration options. Instances should be\n * assumed to be immutable. To modify a `HttpRequest`, the `clone`\n * method should be used.\n *\n * @publicApi\n */\nvar HttpRequest = /** @class */ (function () {\n    function HttpRequest(method, url, third, fourth) {\n        this.url = url;\n        /**\n         * The request body, or `null` if one isn't set.\n         *\n         * Bodies are not enforced to be immutable, as they can include a reference to any\n         * user-defined data type. However, interceptors should take care to preserve\n         * idempotence by treating them as such.\n         */\n        this.body = null;\n        /**\n         * Whether this request should be made in a way that exposes progress events.\n         *\n         * Progress events are expensive (change detection runs on each event) and so\n         * they should only be requested if the consumer intends to monitor them.\n         */\n        this.reportProgress = false;\n        /**\n         * Whether this request should be sent with outgoing credentials (cookies).\n         */\n        this.withCredentials = false;\n        /**\n         * The expected response type of the server.\n         *\n         * This is used to parse the response appropriately before returning it to\n         * the requestee.\n         */\n        this.responseType = 'json';\n        this.method = method.toUpperCase();\n        // Next, need to figure out which argument holds the HttpRequestInit\n        // options, if any.\n        var options;\n        // Check whether a body argument is expected. The only valid way to omit\n        // the body argument is to use a known no-body method like GET.\n        if (mightHaveBody(this.method) || !!fourth) {\n            // Body is the third argument, options are the fourth.\n            this.body = (third !== undefined) ? third : null;\n            options = fourth;\n        }\n        else {\n            // No body required, options are the third argument. The body stays null.\n            options = third;\n        }\n        // If options have been passed, interpret them.\n        if (options) {\n            // Normalize reportProgress and withCredentials.\n            this.reportProgress = !!options.reportProgress;\n            this.withCredentials = !!options.withCredentials;\n            // Override default response type of 'json' if one is provided.\n            if (!!options.responseType) {\n                this.responseType = options.responseType;\n            }\n            // Override headers if they're provided.\n            if (!!options.headers) {\n                this.headers = options.headers;\n            }\n            if (!!options.params) {\n                this.params = options.params;\n            }\n        }\n        // If no headers have been passed in, construct a new HttpHeaders instance.\n        if (!this.headers) {\n            this.headers = new HttpHeaders();\n        }\n        // If no parameters have been passed in, construct a new HttpUrlEncodedParams instance.\n        if (!this.params) {\n            this.params = new HttpParams();\n            this.urlWithParams = url;\n        }\n        else {\n            // Encode the parameters to a string in preparation for inclusion in the URL.\n            var params = this.params.toString();\n            if (params.length === 0) {\n                // No parameters, the visible URL is just the URL given at creation time.\n                this.urlWithParams = url;\n            }\n            else {\n                // Does the URL already have query parameters? Look for '?'.\n                var qIdx = url.indexOf('?');\n                // There are 3 cases to handle:\n                // 1) No existing parameters -> append '?' followed by params.\n                // 2) '?' exists and is followed by existing query string ->\n                //    append '&' followed by params.\n                // 3) '?' exists at the end of the url -> append params directly.\n                // This basically amounts to determining the character, if any, with\n                // which to join the URL and parameters.\n                var sep = qIdx === -1 ? '?' : (qIdx < url.length - 1 ? '&' : '');\n                this.urlWithParams = url + sep + params;\n            }\n        }\n    }\n    /**\n     * Transform the free-form body into a serialized format suitable for\n     * transmission to the server.\n     */\n    HttpRequest.prototype.serializeBody = function () {\n        // If no body is present, no need to serialize it.\n        if (this.body === null) {\n            return null;\n        }\n        // Check whether the body is already in a serialized form. If so,\n        // it can just be returned directly.\n        if (isArrayBuffer(this.body) || isBlob(this.body) || isFormData(this.body) ||\n            typeof this.body === 'string') {\n            return this.body;\n        }\n        // Check whether the body is an instance of HttpUrlEncodedParams.\n        if (this.body instanceof HttpParams) {\n            return this.body.toString();\n        }\n        // Check whether the body is an object or array, and serialize with JSON if so.\n        if (typeof this.body === 'object' || typeof this.body === 'boolean' ||\n            Array.isArray(this.body)) {\n            return JSON.stringify(this.body);\n        }\n        // Fall back on toString() for everything else.\n        return this.body.toString();\n    };\n    /**\n     * Examine the body and attempt to infer an appropriate MIME type\n     * for it.\n     *\n     * If no such type can be inferred, this method will return `null`.\n     */\n    HttpRequest.prototype.detectContentTypeHeader = function () {\n        // An empty body has no content type.\n        if (this.body === null) {\n            return null;\n        }\n        // FormData bodies rely on the browser's content type assignment.\n        if (isFormData(this.body)) {\n            return null;\n        }\n        // Blobs usually have their own content type. If it doesn't, then\n        // no type can be inferred.\n        if (isBlob(this.body)) {\n            return this.body.type || null;\n        }\n        // Array buffers have unknown contents and thus no type can be inferred.\n        if (isArrayBuffer(this.body)) {\n            return null;\n        }\n        // Technically, strings could be a form of JSON data, but it's safe enough\n        // to assume they're plain strings.\n        if (typeof this.body === 'string') {\n            return 'text/plain';\n        }\n        // `HttpUrlEncodedParams` has its own content-type.\n        if (this.body instanceof HttpParams) {\n            return 'application/x-www-form-urlencoded;charset=UTF-8';\n        }\n        // Arrays, objects, and numbers will be encoded as JSON.\n        if (typeof this.body === 'object' || typeof this.body === 'number' ||\n            Array.isArray(this.body)) {\n            return 'application/json';\n        }\n        // No type could be inferred.\n        return null;\n    };\n    HttpRequest.prototype.clone = function (update) {\n        if (update === void 0) { update = {}; }\n        // For method, url, and responseType, take the current value unless\n        // it is overridden in the update hash.\n        var method = update.method || this.method;\n        var url = update.url || this.url;\n        var responseType = update.responseType || this.responseType;\n        // The body is somewhat special - a `null` value in update.body means\n        // whatever current body is present is being overridden with an empty\n        // body, whereas an `undefined` value in update.body implies no\n        // override.\n        var body = (update.body !== undefined) ? update.body : this.body;\n        // Carefully handle the boolean options to differentiate between\n        // `false` and `undefined` in the update args.\n        var withCredentials = (update.withCredentials !== undefined) ? update.withCredentials : this.withCredentials;\n        var reportProgress = (update.reportProgress !== undefined) ? update.reportProgress : this.reportProgress;\n        // Headers and params may be appended to if `setHeaders` or\n        // `setParams` are used.\n        var headers = update.headers || this.headers;\n        var params = update.params || this.params;\n        // Check whether the caller has asked to add headers.\n        if (update.setHeaders !== undefined) {\n            // Set every requested header.\n            headers =\n                Object.keys(update.setHeaders)\n                    .reduce(function (headers, name) { return headers.set(name, update.setHeaders[name]); }, headers);\n        }\n        // Check whether the caller has asked to set params.\n        if (update.setParams) {\n            // Set every requested param.\n            params = Object.keys(update.setParams)\n                .reduce(function (params, param) { return params.set(param, update.setParams[param]); }, params);\n        }\n        // Finally, construct the new HttpRequest using the pieces from above.\n        return new HttpRequest(method, url, body, {\n            params: params, headers: headers, reportProgress: reportProgress, responseType: responseType, withCredentials: withCredentials,\n        });\n    };\n    return HttpRequest;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Type enumeration for the different kinds of `HttpEvent`.\n *\n * @publicApi\n */\nvar HttpEventType;\n(function (HttpEventType) {\n    /**\n     * The request was sent out over the wire.\n     */\n    HttpEventType[HttpEventType[\"Sent\"] = 0] = \"Sent\";\n    /**\n     * An upload progress event was received.\n     */\n    HttpEventType[HttpEventType[\"UploadProgress\"] = 1] = \"UploadProgress\";\n    /**\n     * The response status code and headers were received.\n     */\n    HttpEventType[HttpEventType[\"ResponseHeader\"] = 2] = \"ResponseHeader\";\n    /**\n     * A download progress event was received.\n     */\n    HttpEventType[HttpEventType[\"DownloadProgress\"] = 3] = \"DownloadProgress\";\n    /**\n     * The full response including the body was received.\n     */\n    HttpEventType[HttpEventType[\"Response\"] = 4] = \"Response\";\n    /**\n     * A custom event from an interceptor or a backend.\n     */\n    HttpEventType[HttpEventType[\"User\"] = 5] = \"User\";\n})(HttpEventType || (HttpEventType = {}));\n/**\n * Base class for both `HttpResponse` and `HttpHeaderResponse`.\n *\n * @publicApi\n */\nvar HttpResponseBase = /** @class */ (function () {\n    /**\n     * Super-constructor for all responses.\n     *\n     * The single parameter accepted is an initialization hash. Any properties\n     * of the response passed there will override the default values.\n     */\n    function HttpResponseBase(init, defaultStatus, defaultStatusText) {\n        if (defaultStatus === void 0) { defaultStatus = 200; }\n        if (defaultStatusText === void 0) { defaultStatusText = 'OK'; }\n        // If the hash has values passed, use them to initialize the response.\n        // Otherwise use the default values.\n        this.headers = init.headers || new HttpHeaders();\n        this.status = init.status !== undefined ? init.status : defaultStatus;\n        this.statusText = init.statusText || defaultStatusText;\n        this.url = init.url || null;\n        // Cache the ok value to avoid defining a getter.\n        this.ok = this.status >= 200 && this.status < 300;\n    }\n    return HttpResponseBase;\n}());\n/**\n * A partial HTTP response which only includes the status and header data,\n * but no response body.\n *\n * `HttpHeaderResponse` is a `HttpEvent` available on the response\n * event stream, only when progress events are requested.\n *\n * @publicApi\n */\nvar HttpHeaderResponse = /** @class */ (function (_super) {\n    __extends(HttpHeaderResponse, _super);\n    /**\n     * Create a new `HttpHeaderResponse` with the given parameters.\n     */\n    function HttpHeaderResponse(init) {\n        if (init === void 0) { init = {}; }\n        var _this = _super.call(this, init) || this;\n        _this.type = HttpEventType.ResponseHeader;\n        return _this;\n    }\n    /**\n     * Copy this `HttpHeaderResponse`, overriding its contents with the\n     * given parameter hash.\n     */\n    HttpHeaderResponse.prototype.clone = function (update) {\n        if (update === void 0) { update = {}; }\n        // Perform a straightforward initialization of the new HttpHeaderResponse,\n        // overriding the current parameters with new ones if given.\n        return new HttpHeaderResponse({\n            headers: update.headers || this.headers,\n            status: update.status !== undefined ? update.status : this.status,\n            statusText: update.statusText || this.statusText,\n            url: update.url || this.url || undefined,\n        });\n    };\n    return HttpHeaderResponse;\n}(HttpResponseBase));\n/**\n * A full HTTP response, including a typed response body (which may be `null`\n * if one was not returned).\n *\n * `HttpResponse` is a `HttpEvent` available on the response event\n * stream.\n *\n * @publicApi\n */\nvar HttpResponse = /** @class */ (function (_super) {\n    __extends(HttpResponse, _super);\n    /**\n     * Construct a new `HttpResponse`.\n     */\n    function HttpResponse(init) {\n        if (init === void 0) { init = {}; }\n        var _this = _super.call(this, init) || this;\n        _this.type = HttpEventType.Response;\n        _this.body = init.body !== undefined ? init.body : null;\n        return _this;\n    }\n    HttpResponse.prototype.clone = function (update) {\n        if (update === void 0) { update = {}; }\n        return new HttpResponse({\n            body: (update.body !== undefined) ? update.body : this.body,\n            headers: update.headers || this.headers,\n            status: (update.status !== undefined) ? update.status : this.status,\n            statusText: update.statusText || this.statusText,\n            url: update.url || this.url || undefined,\n        });\n    };\n    return HttpResponse;\n}(HttpResponseBase));\n/**\n * A response that represents an error or failure, either from a\n * non-successful HTTP status, an error while executing the request,\n * or some other failure which occurred during the parsing of the response.\n *\n * Any error returned on the `Observable` response stream will be\n * wrapped in an `HttpErrorResponse` to provide additional context about\n * the state of the HTTP layer when the error occurred. The error property\n * will contain either a wrapped Error object or the error response returned\n * from the server.\n *\n * @publicApi\n */\nvar HttpErrorResponse = /** @class */ (function (_super) {\n    __extends(HttpErrorResponse, _super);\n    function HttpErrorResponse(init) {\n        var _this = \n        // Initialize with a default status of 0 / Unknown Error.\n        _super.call(this, init, 0, 'Unknown Error') || this;\n        _this.name = 'HttpErrorResponse';\n        /**\n         * Errors are never okay, even when the status code is in the 2xx success range.\n         */\n        _this.ok = false;\n        // If the response was successful, then this was a parse error. Otherwise, it was\n        // a protocol-level failure of some sort. Either the request failed in transit\n        // or the server returned an unsuccessful status code.\n        if (_this.status >= 200 && _this.status < 300) {\n            _this.message = \"Http failure during parsing for \" + (init.url || '(unknown url)');\n        }\n        else {\n            _this.message =\n                \"Http failure response for \" + (init.url || '(unknown url)') + \": \" + init.status + \" \" + init.statusText;\n        }\n        _this.error = init.error || null;\n        return _this;\n    }\n    return HttpErrorResponse;\n}(HttpResponseBase));\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Constructs an instance of `HttpRequestOptions<T>` from a source `HttpMethodOptions` and\n * the given `body`. This function clones the object and adds the body.\n *\n * Note that the `responseType` *options* value is a String that identifies the\n * single data type of the response.\n * A single overload version of the method handles each response type.\n * The value of `responseType` cannot be a union, as the combined signature could imply.\n *\n */\nfunction addBody(options, body) {\n    return {\n        body: body,\n        headers: options.headers,\n        observe: options.observe,\n        params: options.params,\n        reportProgress: options.reportProgress,\n        responseType: options.responseType,\n        withCredentials: options.withCredentials,\n    };\n}\n/**\n * Performs HTTP requests.\n * This service is available as an injectable class, with methods to perform HTTP requests.\n * Each request method has multiple signatures, and the return type varies based on\n * the signature that is called (mainly the values of `observe` and `responseType`).\n *\n * Note that the `responseType` *options* value is a String that identifies the\n * single data type of the response.\n * A single overload version of the method handles each response type.\n * The value of `responseType` cannot be a union, as the combined signature could imply.\n\n *\n * @usageNotes\n * Sample HTTP requests for the [Tour of Heroes](/tutorial/toh-pt0) application.\n *\n * ### HTTP Request Example\n *\n * ```\n *  // GET heroes whose name contains search term\n * searchHeroes(term: string): observable<Hero[]>{\n *\n *  const params = new HttpParams({fromString: 'name=term'});\n *    return this.httpClient.request('GET', this.heroesUrl, {responseType:'json', params});\n * }\n * ```\n * ### JSONP Example\n * ```\n * requestJsonp(url, callback = 'callback') {\n *  return this.httpClient.jsonp(this.heroesURL, callback);\n * }\n * ```\n *\n * ### PATCH Example\n * ```\n * // PATCH one of the heroes' name\n * patchHero (id: number, heroName: string): Observable<{}> {\n * const url = `${this.heroesUrl}/${id}`;   // PATCH api/heroes/42\n *  return this.httpClient.patch(url, {name: heroName}, httpOptions)\n *    .pipe(catchError(this.handleError('patchHero')));\n * }\n * ```\n *\n * @see [HTTP Guide](guide/http)\n *\n * @publicApi\n */\nvar HttpClient = /** @class */ (function () {\n    function HttpClient(handler) {\n        this.handler = handler;\n    }\n    /**\n     * Constructs an observable for a generic HTTP request that, when subscribed,\n     * fires the request through the chain of registered interceptors and on to the\n     * server.\n     *\n     * You can pass an `HttpRequest` directly as the only parameter. In this case,\n     * the call returns an observable of the raw `HttpEvent` stream.\n     *\n     * Alternatively you can pass an HTTP method as the first parameter,\n     * a URL string as the second, and an options hash containing the request body as the third.\n     * See `addBody()`. In this case, the specified `responseType` and `observe` options determine the\n     * type of returned observable.\n     *   * The `responseType` value determines how a successful response body is parsed.\n     *   * If `responseType` is the default `json`, you can pass a type interface for the resulting\n     * object as a type parameter to the call.\n     *\n     * The `observe` value determines the return type, according to what you are interested in\n     * observing.\n     *   * An `observe` value of events returns an observable of the raw `HttpEvent` stream, including\n     * progress events by default.\n     *   * An `observe` value of response returns an observable of `HttpResponse<T>`,\n     * where the `T` parameter depends on the `responseType` and any optionally provided type\n     * parameter.\n     *   * An `observe` value of body returns an observable of `<T>` with the same `T` body type.\n     *\n     */\n    HttpClient.prototype.request = function (first, url, options) {\n        var _this = this;\n        if (options === void 0) { options = {}; }\n        var req;\n        // First, check whether the primary argument is an instance of `HttpRequest`.\n        if (first instanceof HttpRequest) {\n            // It is. The other arguments must be undefined (per the signatures) and can be\n            // ignored.\n            req = first;\n        }\n        else {\n            // It's a string, so it represents a URL. Construct a request based on it,\n            // and incorporate the remaining arguments (assuming `GET` unless a method is\n            // provided.\n            // Figure out the headers.\n            var headers = undefined;\n            if (options.headers instanceof HttpHeaders) {\n                headers = options.headers;\n            }\n            else {\n                headers = new HttpHeaders(options.headers);\n            }\n            // Sort out parameters.\n            var params = undefined;\n            if (!!options.params) {\n                if (options.params instanceof HttpParams) {\n                    params = options.params;\n                }\n                else {\n                    params = new HttpParams({ fromObject: options.params });\n                }\n            }\n            // Construct the request.\n            req = new HttpRequest(first, url, (options.body !== undefined ? options.body : null), {\n                headers: headers,\n                params: params,\n                reportProgress: options.reportProgress,\n                // By default, JSON is assumed to be returned for all calls.\n                responseType: options.responseType || 'json',\n                withCredentials: options.withCredentials,\n            });\n        }\n        // Start with an Observable.of() the initial request, and run the handler (which\n        // includes all interceptors) inside a concatMap(). This way, the handler runs\n        // inside an Observable chain, which causes interceptors to be re-run on every\n        // subscription (this also makes retries re-run the handler, including interceptors).\n        var events$ = of(req).pipe(concatMap(function (req) { return _this.handler.handle(req); }));\n        // If coming via the API signature which accepts a previously constructed HttpRequest,\n        // the only option is to get the event stream. Otherwise, return the event stream if\n        // that is what was requested.\n        if (first instanceof HttpRequest || options.observe === 'events') {\n            return events$;\n        }\n        // The requested stream contains either the full response or the body. In either\n        // case, the first step is to filter the event stream to extract a stream of\n        // responses(s).\n        var res$ = events$.pipe(filter(function (event) { return event instanceof HttpResponse; }));\n        // Decide which stream to return.\n        switch (options.observe || 'body') {\n            case 'body':\n                // The requested stream is the body. Map the response stream to the response\n                // body. This could be done more simply, but a misbehaving interceptor might\n                // transform the response body into a different format and ignore the requested\n                // responseType. Guard against this by validating that the response is of the\n                // requested type.\n                switch (req.responseType) {\n                    case 'arraybuffer':\n                        return res$.pipe(map(function (res) {\n                            // Validate that the body is an ArrayBuffer.\n                            if (res.body !== null && !(res.body instanceof ArrayBuffer)) {\n                                throw new Error('Response is not an ArrayBuffer.');\n                            }\n                            return res.body;\n                        }));\n                    case 'blob':\n                        return res$.pipe(map(function (res) {\n                            // Validate that the body is a Blob.\n                            if (res.body !== null && !(res.body instanceof Blob)) {\n                                throw new Error('Response is not a Blob.');\n                            }\n                            return res.body;\n                        }));\n                    case 'text':\n                        return res$.pipe(map(function (res) {\n                            // Validate that the body is a string.\n                            if (res.body !== null && typeof res.body !== 'string') {\n                                throw new Error('Response is not a string.');\n                            }\n                            return res.body;\n                        }));\n                    case 'json':\n                    default:\n                        // No validation needed for JSON responses, as they can be of any type.\n                        return res$.pipe(map(function (res) { return res.body; }));\n                }\n            case 'response':\n                // The response stream was requested directly, so return it.\n                return res$;\n            default:\n                // Guard against new future observe types being added.\n                throw new Error(\"Unreachable: unhandled observe type \" + options.observe + \"}\");\n        }\n    };\n    /**\n     * Constructs an observable that, when subscribed, causes the configured\n     * `DELETE` request to execute on the server. See the individual overloads for\n     * details on the return type.\n     *\n     * @param url     The endpoint URL.\n     * @param options The HTTP options to send with the request.\n     *\n     */\n    HttpClient.prototype.delete = function (url, options) {\n        if (options === void 0) { options = {}; }\n        return this.request('DELETE', url, options);\n    };\n    /**\n     * Constructs an observable that, when subscribed, causes the configured\n     * `GET` request to execute on the server. See the individual overloads for\n     * details on the return type.\n     */\n    HttpClient.prototype.get = function (url, options) {\n        if (options === void 0) { options = {}; }\n        return this.request('GET', url, options);\n    };\n    /**\n     * Constructs an observable that, when subscribed, causes the configured\n     * `HEAD` request to execute on the server. The `HEAD` method returns\n     * meta information about the resource without transferring the\n     * resource itself. See the individual overloads for\n     * details on the return type.\n     */\n    HttpClient.prototype.head = function (url, options) {\n        if (options === void 0) { options = {}; }\n        return this.request('HEAD', url, options);\n    };\n    /**\n     * Constructs an `Observable` that, when subscribed, causes a request with the special method\n     * `JSONP` to be dispatched via the interceptor pipeline.\n     * The [JSONP pattern](https://en.wikipedia.org/wiki/JSONP) works around limitations of certain\n     * API endpoints that don't support newer,\n     * and preferable [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) protocol.\n     * JSONP treats the endpoint API as a JavaScript file and tricks the browser to process the\n     * requests even if the API endpoint is not located on the same domain (origin) as the client-side\n     * application making the request.\n     * The endpoint API must support JSONP callback for JSONP requests to work.\n     * The resource API returns the JSON response wrapped in a callback function.\n     * You can pass the callback function name as one of the query parameters.\n     * Note that JSONP requests can only be used with `GET` requests.\n     *\n     * @param url The resource URL.\n     * @param callbackParam The callback function name.\n     *\n     */\n    HttpClient.prototype.jsonp = function (url, callbackParam) {\n        return this.request('JSONP', url, {\n            params: new HttpParams().append(callbackParam, 'JSONP_CALLBACK'),\n            observe: 'body',\n            responseType: 'json',\n        });\n    };\n    /**\n     * Constructs an `Observable` that, when subscribed, causes the configured\n     * `OPTIONS` request to execute on the server. This method allows the client\n     * to determine the supported HTTP methods and other capabilites of an endpoint,\n     * without implying a resource action. See the individual overloads for\n     * details on the return type.\n     */\n    HttpClient.prototype.options = function (url, options) {\n        if (options === void 0) { options = {}; }\n        return this.request('OPTIONS', url, options);\n    };\n    /**\n     * Constructs an observable that, when subscribed, causes the configured\n     * `PATCH` request to execute on the server. See the individual overloads for\n     * details on the return type.\n     */\n    HttpClient.prototype.patch = function (url, body, options) {\n        if (options === void 0) { options = {}; }\n        return this.request('PATCH', url, addBody(options, body));\n    };\n    /**\n     * Constructs an observable that, when subscribed, causes the configured\n     * `POST` request to execute on the server. The server responds with the location of\n     * the replaced resource. See the individual overloads for\n     * details on the return type.\n     */\n    HttpClient.prototype.post = function (url, body, options) {\n        if (options === void 0) { options = {}; }\n        return this.request('POST', url, addBody(options, body));\n    };\n    /**\n     * Constructs an observable that, when subscribed, causes the configured\n     * `PUT` request to execute on the server. The `PUT` method replaces an existing resource\n     * with a new set of values.\n     * See the individual overloads for details on the return type.\n     */\n    HttpClient.prototype.put = function (url, body, options) {\n        if (options === void 0) { options = {}; }\n        return this.request('PUT', url, addBody(options, body));\n    };\n    HttpClient = __decorate([\n        Injectable(),\n        __metadata(\"design:paramtypes\", [HttpHandler])\n    ], HttpClient);\n    return HttpClient;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * `HttpHandler` which applies an `HttpInterceptor` to an `HttpRequest`.\n *\n *\n */\nvar HttpInterceptorHandler = /** @class */ (function () {\n    function HttpInterceptorHandler(next, interceptor) {\n        this.next = next;\n        this.interceptor = interceptor;\n    }\n    HttpInterceptorHandler.prototype.handle = function (req) {\n        return this.interceptor.intercept(req, this.next);\n    };\n    return HttpInterceptorHandler;\n}());\n/**\n * A multi-provider token that represents the array of registered\n * `HttpInterceptor` objects.\n *\n * @publicApi\n */\nvar HTTP_INTERCEPTORS = new InjectionToken('HTTP_INTERCEPTORS');\nvar NoopInterceptor = /** @class */ (function () {\n    function NoopInterceptor() {\n    }\n    NoopInterceptor.prototype.intercept = function (req, next) {\n        return next.handle(req);\n    };\n    NoopInterceptor = __decorate([\n        Injectable()\n    ], NoopInterceptor);\n    return NoopInterceptor;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Every request made through JSONP needs a callback name that's unique across the\n// whole page. Each request is assigned an id and the callback name is constructed\n// from that. The next id to be assigned is tracked in a global variable here that\n// is shared among all applications on the page.\nvar nextRequestId = 0;\n// Error text given when a JSONP script is injected, but doesn't invoke the callback\n// passed in its URL.\nvar JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.';\n// Error text given when a request is passed to the JsonpClientBackend that doesn't\n// have a request method JSONP.\nvar JSONP_ERR_WRONG_METHOD = 'JSONP requests must use JSONP request method.';\nvar JSONP_ERR_WRONG_RESPONSE_TYPE = 'JSONP requests must use Json response type.';\n/**\n * DI token/abstract type representing a map of JSONP callbacks.\n *\n * In the browser, this should always be the `window` object.\n *\n *\n */\nvar JsonpCallbackContext = /** @class */ (function () {\n    function JsonpCallbackContext() {\n    }\n    return JsonpCallbackContext;\n}());\n/**\n * Processes an `HttpRequest` with the JSONP method,\n * by performing JSONP style requests.\n * @see `HttpHandler`\n * @see `HttpXhrBackend`\n *\n * @publicApi\n */\nvar JsonpClientBackend = /** @class */ (function () {\n    function JsonpClientBackend(callbackMap, document) {\n        this.callbackMap = callbackMap;\n        this.document = document;\n    }\n    /**\n     * Get the name of the next callback method, by incrementing the global `nextRequestId`.\n     */\n    JsonpClientBackend.prototype.nextCallback = function () { return \"ng_jsonp_callback_\" + nextRequestId++; };\n    /**\n     * Processes a JSONP request and returns an event stream of the results.\n     * @param req The request object.\n     * @returns An observable of the response events.\n     *\n     */\n    JsonpClientBackend.prototype.handle = function (req) {\n        var _this = this;\n        // Firstly, check both the method and response type. If either doesn't match\n        // then the request was improperly routed here and cannot be handled.\n        if (req.method !== 'JSONP') {\n            throw new Error(JSONP_ERR_WRONG_METHOD);\n        }\n        else if (req.responseType !== 'json') {\n            throw new Error(JSONP_ERR_WRONG_RESPONSE_TYPE);\n        }\n        // Everything else happens inside the Observable boundary.\n        return new Observable(function (observer) {\n            // The first step to make a request is to generate the callback name, and replace the\n            // callback placeholder in the URL with the name. Care has to be taken here to ensure\n            // a trailing &, if matched, gets inserted back into the URL in the correct place.\n            var callback = _this.nextCallback();\n            var url = req.urlWithParams.replace(/=JSONP_CALLBACK(&|$)/, \"=\" + callback + \"$1\");\n            // Construct the <script> tag and point it at the URL.\n            var node = _this.document.createElement('script');\n            node.src = url;\n            // A JSONP request requires waiting for multiple callbacks. These variables\n            // are closed over and track state across those callbacks.\n            // The response object, if one has been received, or null otherwise.\n            var body = null;\n            // Whether the response callback has been called.\n            var finished = false;\n            // Whether the request has been cancelled (and thus any other callbacks)\n            // should be ignored.\n            var cancelled = false;\n            // Set the response callback in this.callbackMap (which will be the window\n            // object in the browser. The script being loaded via the <script> tag will\n            // eventually call this callback.\n            _this.callbackMap[callback] = function (data) {\n                // Data has been received from the JSONP script. Firstly, delete this callback.\n                delete _this.callbackMap[callback];\n                // Next, make sure the request wasn't cancelled in the meantime.\n                if (cancelled) {\n                    return;\n                }\n                // Set state to indicate data was received.\n                body = data;\n                finished = true;\n            };\n            // cleanup() is a utility closure that removes the <script> from the page and\n            // the response callback from the window. This logic is used in both the\n            // success, error, and cancellation paths, so it's extracted out for convenience.\n            var cleanup = function () {\n                // Remove the <script> tag if it's still on the page.\n                if (node.parentNode) {\n                    node.parentNode.removeChild(node);\n                }\n                // Remove the response callback from the callbackMap (window object in the\n                // browser).\n                delete _this.callbackMap[callback];\n            };\n            // onLoad() is the success callback which runs after the response callback\n            // if the JSONP script loads successfully. The event itself is unimportant.\n            // If something went wrong, onLoad() may run without the response callback\n            // having been invoked.\n            var onLoad = function (event) {\n                // Do nothing if the request has been cancelled.\n                if (cancelled) {\n                    return;\n                }\n                // Cleanup the page.\n                cleanup();\n                // Check whether the response callback has run.\n                if (!finished) {\n                    // It hasn't, something went wrong with the request. Return an error via\n                    // the Observable error path. All JSONP errors have status 0.\n                    observer.error(new HttpErrorResponse({\n                        url: url,\n                        status: 0,\n                        statusText: 'JSONP Error',\n                        error: new Error(JSONP_ERR_NO_CALLBACK),\n                    }));\n                    return;\n                }\n                // Success. body either contains the response body or null if none was\n                // returned.\n                observer.next(new HttpResponse({\n                    body: body,\n                    status: 200,\n                    statusText: 'OK', url: url,\n                }));\n                // Complete the stream, the response is over.\n                observer.complete();\n            };\n            // onError() is the error callback, which runs if the script returned generates\n            // a Javascript error. It emits the error via the Observable error channel as\n            // a HttpErrorResponse.\n            var onError = function (error) {\n                // If the request was already cancelled, no need to emit anything.\n                if (cancelled) {\n                    return;\n                }\n                cleanup();\n                // Wrap the error in a HttpErrorResponse.\n                observer.error(new HttpErrorResponse({\n                    error: error,\n                    status: 0,\n                    statusText: 'JSONP Error', url: url,\n                }));\n            };\n            // Subscribe to both the success (load) and error events on the <script> tag,\n            // and add it to the page.\n            node.addEventListener('load', onLoad);\n            node.addEventListener('error', onError);\n            _this.document.body.appendChild(node);\n            // The request has now been successfully sent.\n            observer.next({ type: HttpEventType.Sent });\n            // Cancellation handler.\n            return function () {\n                // Track the cancellation so event listeners won't do anything even if already scheduled.\n                cancelled = true;\n                // Remove the event listeners so they won't run if the events later fire.\n                node.removeEventListener('load', onLoad);\n                node.removeEventListener('error', onError);\n                // And finally, clean up the page.\n                cleanup();\n            };\n        });\n    };\n    JsonpClientBackend = __decorate([\n        Injectable(),\n        __param(1, Inject(DOCUMENT)),\n        __metadata(\"design:paramtypes\", [JsonpCallbackContext, Object])\n    ], JsonpClientBackend);\n    return JsonpClientBackend;\n}());\n/**\n * Identifies requests with the method JSONP and\n * shifts them to the `JsonpClientBackend`.\n *\n * @see `HttpInterceptor`\n *\n * @publicApi\n */\nvar JsonpInterceptor = /** @class */ (function () {\n    function JsonpInterceptor(jsonp) {\n        this.jsonp = jsonp;\n    }\n    /**\n     * Identifies and handles a given JSONP request.\n     * @param req The outgoing request object to handle.\n     * @param next The next interceptor in the chain, or the backend\n     * if no interceptors remain in the chain.\n     * @returns An observable of the event stream.\n     */\n    JsonpInterceptor.prototype.intercept = function (req, next) {\n        if (req.method === 'JSONP') {\n            return this.jsonp.handle(req);\n        }\n        // Fall through for normal HTTP requests.\n        return next.handle(req);\n    };\n    JsonpInterceptor = __decorate([\n        Injectable(),\n        __metadata(\"design:paramtypes\", [JsonpClientBackend])\n    ], JsonpInterceptor);\n    return JsonpInterceptor;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar XSSI_PREFIX = /^\\)\\]\\}',?\\n/;\n/**\n * Determine an appropriate URL for the response, by checking either\n * XMLHttpRequest.responseURL or the X-Request-URL header.\n */\nfunction getResponseUrl(xhr) {\n    if ('responseURL' in xhr && xhr.responseURL) {\n        return xhr.responseURL;\n    }\n    if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n        return xhr.getResponseHeader('X-Request-URL');\n    }\n    return null;\n}\n/**\n * A wrapper around the `XMLHttpRequest` constructor.\n *\n * @publicApi\n */\nvar XhrFactory = /** @class */ (function () {\n    function XhrFactory() {\n    }\n    return XhrFactory;\n}());\n/**\n * A factory for `HttpXhrBackend` that uses the `XMLHttpRequest` browser API.\n *\n */\nvar BrowserXhr = /** @class */ (function () {\n    function BrowserXhr() {\n    }\n    BrowserXhr.prototype.build = function () { return (new XMLHttpRequest()); };\n    BrowserXhr = __decorate([\n        Injectable(),\n        __metadata(\"design:paramtypes\", [])\n    ], BrowserXhr);\n    return BrowserXhr;\n}());\n/**\n * Uses `XMLHttpRequest` to send requests to a backend server.\n * @see `HttpHandler`\n * @see `JsonpClientBackend`\n *\n * @publicApi\n */\nvar HttpXhrBackend = /** @class */ (function () {\n    function HttpXhrBackend(xhrFactory) {\n        this.xhrFactory = xhrFactory;\n    }\n    /**\n     * Processes a request and returns a stream of response events.\n     * @param req The request object.\n     * @returns An observable of the response events.\n     */\n    HttpXhrBackend.prototype.handle = function (req) {\n        var _this = this;\n        // Quick check to give a better error message when a user attempts to use\n        // HttpClient.jsonp() without installing the JsonpClientModule\n        if (req.method === 'JSONP') {\n            throw new Error(\"Attempted to construct Jsonp request without JsonpClientModule installed.\");\n        }\n        // Everything happens on Observable subscription.\n        return new Observable(function (observer) {\n            // Start by setting up the XHR object with request method, URL, and withCredentials flag.\n            var xhr = _this.xhrFactory.build();\n            xhr.open(req.method, req.urlWithParams);\n            if (!!req.withCredentials) {\n                xhr.withCredentials = true;\n            }\n            // Add all the requested headers.\n            req.headers.forEach(function (name, values) { return xhr.setRequestHeader(name, values.join(',')); });\n            // Add an Accept header if one isn't present already.\n            if (!req.headers.has('Accept')) {\n                xhr.setRequestHeader('Accept', 'application/json, text/plain, */*');\n            }\n            // Auto-detect the Content-Type header if one isn't present already.\n            if (!req.headers.has('Content-Type')) {\n                var detectedType = req.detectContentTypeHeader();\n                // Sometimes Content-Type detection fails.\n                if (detectedType !== null) {\n                    xhr.setRequestHeader('Content-Type', detectedType);\n                }\n            }\n            // Set the responseType if one was requested.\n            if (req.responseType) {\n                var responseType = req.responseType.toLowerCase();\n                // JSON responses need to be processed as text. This is because if the server\n                // returns an XSSI-prefixed JSON response, the browser will fail to parse it,\n                // xhr.response will be null, and xhr.responseText cannot be accessed to\n                // retrieve the prefixed JSON data in order to strip the prefix. Thus, all JSON\n                // is parsed by first requesting text and then applying JSON.parse.\n                xhr.responseType = ((responseType !== 'json') ? responseType : 'text');\n            }\n            // Serialize the request body if one is present. If not, this will be set to null.\n            var reqBody = req.serializeBody();\n            // If progress events are enabled, response headers will be delivered\n            // in two events - the HttpHeaderResponse event and the full HttpResponse\n            // event. However, since response headers don't change in between these\n            // two events, it doesn't make sense to parse them twice. So headerResponse\n            // caches the data extracted from the response whenever it's first parsed,\n            // to ensure parsing isn't duplicated.\n            var headerResponse = null;\n            // partialFromXhr extracts the HttpHeaderResponse from the current XMLHttpRequest\n            // state, and memoizes it into headerResponse.\n            var partialFromXhr = function () {\n                if (headerResponse !== null) {\n                    return headerResponse;\n                }\n                // Read status and normalize an IE9 bug (http://bugs.jquery.com/ticket/1450).\n                var status = xhr.status === 1223 ? 204 : xhr.status;\n                var statusText = xhr.statusText || 'OK';\n                // Parse headers from XMLHttpRequest - this step is lazy.\n                var headers = new HttpHeaders(xhr.getAllResponseHeaders());\n                // Read the response URL from the XMLHttpResponse instance and fall back on the\n                // request URL.\n                var url = getResponseUrl(xhr) || req.url;\n                // Construct the HttpHeaderResponse and memoize it.\n                headerResponse = new HttpHeaderResponse({ headers: headers, status: status, statusText: statusText, url: url });\n                return headerResponse;\n            };\n            // Next, a few closures are defined for the various events which XMLHttpRequest can\n            // emit. This allows them to be unregistered as event listeners later.\n            // First up is the load event, which represents a response being fully available.\n            var onLoad = function () {\n                // Read response state from the memoized partial data.\n                var _a = partialFromXhr(), headers = _a.headers, status = _a.status, statusText = _a.statusText, url = _a.url;\n                // The body will be read out if present.\n                var body = null;\n                if (status !== 204) {\n                    // Use XMLHttpRequest.response if set, responseText otherwise.\n                    body = (typeof xhr.response === 'undefined') ? xhr.responseText : xhr.response;\n                }\n                // Normalize another potential bug (this one comes from CORS).\n                if (status === 0) {\n                    status = !!body ? 200 : 0;\n                }\n                // ok determines whether the response will be transmitted on the event or\n                // error channel. Unsuccessful status codes (not 2xx) will always be errors,\n                // but a successful status code can still result in an error if the user\n                // asked for JSON data and the body cannot be parsed as such.\n                var ok = status >= 200 && status < 300;\n                // Check whether the body needs to be parsed as JSON (in many cases the browser\n                // will have done that already).\n                if (req.responseType === 'json' && typeof body === 'string') {\n                    // Save the original body, before attempting XSSI prefix stripping.\n                    var originalBody = body;\n                    body = body.replace(XSSI_PREFIX, '');\n                    try {\n                        // Attempt the parse. If it fails, a parse error should be delivered to the user.\n                        body = body !== '' ? JSON.parse(body) : null;\n                    }\n                    catch (error) {\n                        // Since the JSON.parse failed, it's reasonable to assume this might not have been a\n                        // JSON response. Restore the original body (including any XSSI prefix) to deliver\n                        // a better error response.\n                        body = originalBody;\n                        // If this was an error request to begin with, leave it as a string, it probably\n                        // just isn't JSON. Otherwise, deliver the parsing error to the user.\n                        if (ok) {\n                            // Even though the response status was 2xx, this is still an error.\n                            ok = false;\n                            // The parse error contains the text of the body that failed to parse.\n                            body = { error: error, text: body };\n                        }\n                    }\n                }\n                if (ok) {\n                    // A successful response is delivered on the event stream.\n                    observer.next(new HttpResponse({\n                        body: body,\n                        headers: headers,\n                        status: status,\n                        statusText: statusText,\n                        url: url || undefined,\n                    }));\n                    // The full body has been received and delivered, no further events\n                    // are possible. This request is complete.\n                    observer.complete();\n                }\n                else {\n                    // An unsuccessful request is delivered on the error channel.\n                    observer.error(new HttpErrorResponse({\n                        // The error in this case is the response body (error from the server).\n                        error: body,\n                        headers: headers,\n                        status: status,\n                        statusText: statusText,\n                        url: url || undefined,\n                    }));\n                }\n            };\n            // The onError callback is called when something goes wrong at the network level.\n            // Connection timeout, DNS error, offline, etc. These are actual errors, and are\n            // transmitted on the error channel.\n            var onError = function (error) {\n                var url = partialFromXhr().url;\n                var res = new HttpErrorResponse({\n                    error: error,\n                    status: xhr.status || 0,\n                    statusText: xhr.statusText || 'Unknown Error',\n                    url: url || undefined,\n                });\n                observer.error(res);\n            };\n            // The sentHeaders flag tracks whether the HttpResponseHeaders event\n            // has been sent on the stream. This is necessary to track if progress\n            // is enabled since the event will be sent on only the first download\n            // progerss event.\n            var sentHeaders = false;\n            // The download progress event handler, which is only registered if\n            // progress events are enabled.\n            var onDownProgress = function (event) {\n                // Send the HttpResponseHeaders event if it hasn't been sent already.\n                if (!sentHeaders) {\n                    observer.next(partialFromXhr());\n                    sentHeaders = true;\n                }\n                // Start building the download progress event to deliver on the response\n                // event stream.\n                var progressEvent = {\n                    type: HttpEventType.DownloadProgress,\n                    loaded: event.loaded,\n                };\n                // Set the total number of bytes in the event if it's available.\n                if (event.lengthComputable) {\n                    progressEvent.total = event.total;\n                }\n                // If the request was for text content and a partial response is\n                // available on XMLHttpRequest, include it in the progress event\n                // to allow for streaming reads.\n                if (req.responseType === 'text' && !!xhr.responseText) {\n                    progressEvent.partialText = xhr.responseText;\n                }\n                // Finally, fire the event.\n                observer.next(progressEvent);\n            };\n            // The upload progress event handler, which is only registered if\n            // progress events are enabled.\n            var onUpProgress = function (event) {\n                // Upload progress events are simpler. Begin building the progress\n                // event.\n                var progress = {\n                    type: HttpEventType.UploadProgress,\n                    loaded: event.loaded,\n                };\n                // If the total number of bytes being uploaded is available, include\n                // it.\n                if (event.lengthComputable) {\n                    progress.total = event.total;\n                }\n                // Send the event.\n                observer.next(progress);\n            };\n            // By default, register for load and error events.\n            xhr.addEventListener('load', onLoad);\n            xhr.addEventListener('error', onError);\n            // Progress events are only enabled if requested.\n            if (req.reportProgress) {\n                // Download progress is always enabled if requested.\n                xhr.addEventListener('progress', onDownProgress);\n                // Upload progress depends on whether there is a body to upload.\n                if (reqBody !== null && xhr.upload) {\n                    xhr.upload.addEventListener('progress', onUpProgress);\n                }\n            }\n            // Fire the request, and notify the event stream that it was fired.\n            xhr.send(reqBody);\n            observer.next({ type: HttpEventType.Sent });\n            // This is the return from the Observable function, which is the\n            // request cancellation handler.\n            return function () {\n                // On a cancellation, remove all registered event listeners.\n                xhr.removeEventListener('error', onError);\n                xhr.removeEventListener('load', onLoad);\n                if (req.reportProgress) {\n                    xhr.removeEventListener('progress', onDownProgress);\n                    if (reqBody !== null && xhr.upload) {\n                        xhr.upload.removeEventListener('progress', onUpProgress);\n                    }\n                }\n                // Finally, abort the in-flight request.\n                xhr.abort();\n            };\n        });\n    };\n    HttpXhrBackend = __decorate([\n        Injectable(),\n        __metadata(\"design:paramtypes\", [XhrFactory])\n    ], HttpXhrBackend);\n    return HttpXhrBackend;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar XSRF_COOKIE_NAME = new InjectionToken('XSRF_COOKIE_NAME');\nvar XSRF_HEADER_NAME = new InjectionToken('XSRF_HEADER_NAME');\n/**\n * Retrieves the current XSRF token to use with the next outgoing request.\n *\n * @publicApi\n */\nvar HttpXsrfTokenExtractor = /** @class */ (function () {\n    function HttpXsrfTokenExtractor() {\n    }\n    return HttpXsrfTokenExtractor;\n}());\n/**\n * `HttpXsrfTokenExtractor` which retrieves the token from a cookie.\n */\nvar HttpXsrfCookieExtractor = /** @class */ (function () {\n    function HttpXsrfCookieExtractor(doc, platform, cookieName) {\n        this.doc = doc;\n        this.platform = platform;\n        this.cookieName = cookieName;\n        this.lastCookieString = '';\n        this.lastToken = null;\n        /**\n         * @internal for testing\n         */\n        this.parseCount = 0;\n    }\n    HttpXsrfCookieExtractor.prototype.getToken = function () {\n        if (this.platform === 'server') {\n            return null;\n        }\n        var cookieString = this.doc.cookie || '';\n        if (cookieString !== this.lastCookieString) {\n            this.parseCount++;\n            this.lastToken = ÉµparseCookieValue(cookieString, this.cookieName);\n            this.lastCookieString = cookieString;\n        }\n        return this.lastToken;\n    };\n    HttpXsrfCookieExtractor = __decorate([\n        Injectable(),\n        __param(0, Inject(DOCUMENT)), __param(1, Inject(PLATFORM_ID)),\n        __param(2, Inject(XSRF_COOKIE_NAME)),\n        __metadata(\"design:paramtypes\", [Object, String, String])\n    ], HttpXsrfCookieExtractor);\n    return HttpXsrfCookieExtractor;\n}());\n/**\n * `HttpInterceptor` which adds an XSRF token to eligible outgoing requests.\n */\nvar HttpXsrfInterceptor = /** @class */ (function () {\n    function HttpXsrfInterceptor(tokenService, headerName) {\n        this.tokenService = tokenService;\n        this.headerName = headerName;\n    }\n    HttpXsrfInterceptor.prototype.intercept = function (req, next) {\n        var lcUrl = req.url.toLowerCase();\n        // Skip both non-mutating requests and absolute URLs.\n        // Non-mutating requests don't require a token, and absolute URLs require special handling\n        // anyway as the cookie set\n        // on our origin is not the same as the token expected by another origin.\n        if (req.method === 'GET' || req.method === 'HEAD' || lcUrl.startsWith('http://') ||\n            lcUrl.startsWith('https://')) {\n            return next.handle(req);\n        }\n        var token = this.tokenService.getToken();\n        // Be careful not to overwrite an existing header of the same name.\n        if (token !== null && !req.headers.has(this.headerName)) {\n            req = req.clone({ headers: req.headers.set(this.headerName, token) });\n        }\n        return next.handle(req);\n    };\n    HttpXsrfInterceptor = __decorate([\n        Injectable(),\n        __param(1, Inject(XSRF_HEADER_NAME)),\n        __metadata(\"design:paramtypes\", [HttpXsrfTokenExtractor, String])\n    ], HttpXsrfInterceptor);\n    return HttpXsrfInterceptor;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * An injectable `HttpHandler` that applies multiple interceptors\n * to a request before passing it to the given `HttpBackend`.\n *\n * The interceptors are loaded lazily from the injector, to allow\n * interceptors to themselves inject classes depending indirectly\n * on `HttpInterceptingHandler` itself.\n * @see `HttpInterceptor`\n */\nvar HttpInterceptingHandler = /** @class */ (function () {\n    function HttpInterceptingHandler(backend, injector) {\n        this.backend = backend;\n        this.injector = injector;\n        this.chain = null;\n    }\n    HttpInterceptingHandler.prototype.handle = function (req) {\n        if (this.chain === null) {\n            var interceptors = this.injector.get(HTTP_INTERCEPTORS, []);\n            this.chain = interceptors.reduceRight(function (next, interceptor) { return new HttpInterceptorHandler(next, interceptor); }, this.backend);\n        }\n        return this.chain.handle(req);\n    };\n    HttpInterceptingHandler = __decorate([\n        Injectable(),\n        __metadata(\"design:paramtypes\", [HttpBackend, Injector])\n    ], HttpInterceptingHandler);\n    return HttpInterceptingHandler;\n}());\n/**\n * Constructs an `HttpHandler` that applies interceptors\n * to a request before passing it to the given `HttpBackend`.\n *\n * Use as a factory function within `HttpClientModule`.\n *\n *\n */\nfunction interceptingHandler(backend, interceptors) {\n    if (interceptors === void 0) { interceptors = []; }\n    if (!interceptors) {\n        return backend;\n    }\n    return interceptors.reduceRight(function (next, interceptor) { return new HttpInterceptorHandler(next, interceptor); }, backend);\n}\n/**\n * Factory function that determines where to store JSONP callbacks.\n *\n * Ordinarily JSONP callbacks are stored on the `window` object, but this may not exist\n * in test environments. In that case, callbacks are stored on an anonymous object instead.\n *\n *\n */\nfunction jsonpCallbackContext() {\n    if (typeof window === 'object') {\n        return window;\n    }\n    return {};\n}\n/**\n * Configures XSRF protection support for outgoing requests.\n *\n * For a server that supports a cookie-based XSRF protection system,\n * use directly to configure XSRF protection with the correct\n * cookie and header names.\n *\n * If no names are supplied, the default cookie name is `XSRF-TOKEN`\n * and the default header name is `X-XSRF-TOKEN`.\n *\n * @publicApi\n */\nvar HttpClientXsrfModule = /** @class */ (function () {\n    function HttpClientXsrfModule() {\n    }\n    HttpClientXsrfModule_1 = HttpClientXsrfModule;\n    /**\n     * Disable the default XSRF protection.\n     */\n    HttpClientXsrfModule.disable = function () {\n        return {\n            ngModule: HttpClientXsrfModule_1,\n            providers: [\n                { provide: HttpXsrfInterceptor, useClass: NoopInterceptor },\n            ],\n        };\n    };\n    /**\n     * Configure XSRF protection.\n     * @param options An object that can specify either or both\n     * cookie name or header name.\n     * - Cookie name default is `XSRF-TOKEN`.\n     * - Header name default is `X-XSRF-TOKEN`.\n     *\n     */\n    HttpClientXsrfModule.withOptions = function (options) {\n        if (options === void 0) { options = {}; }\n        return {\n            ngModule: HttpClientXsrfModule_1,\n            providers: [\n                options.cookieName ? { provide: XSRF_COOKIE_NAME, useValue: options.cookieName } : [],\n                options.headerName ? { provide: XSRF_HEADER_NAME, useValue: options.headerName } : [],\n            ],\n        };\n    };\n    var HttpClientXsrfModule_1;\n    HttpClientXsrfModule = HttpClientXsrfModule_1 = __decorate([\n        NgModule({\n            providers: [\n                HttpXsrfInterceptor,\n                { provide: HTTP_INTERCEPTORS, useExisting: HttpXsrfInterceptor, multi: true },\n                { provide: HttpXsrfTokenExtractor, useClass: HttpXsrfCookieExtractor },\n                { provide: XSRF_COOKIE_NAME, useValue: 'XSRF-TOKEN' },\n                { provide: XSRF_HEADER_NAME, useValue: 'X-XSRF-TOKEN' },\n            ],\n        })\n    ], HttpClientXsrfModule);\n    return HttpClientXsrfModule;\n}());\n/**\n * Configures the [dependency injector](guide/glossary#injector) for `HttpClient`\n * with supporting services for XSRF. Automatically imported by `HttpClientModule`.\n *\n * You can add interceptors to the chain behind `HttpClient` by binding them to the\n * multiprovider for built-in [DI token](guide/glossary#di-token) `HTTP_INTERCEPTORS`.\n *\n * @publicApi\n */\nvar HttpClientModule = /** @class */ (function () {\n    function HttpClientModule() {\n    }\n    HttpClientModule = __decorate([\n        NgModule({\n            /**\n             * Optional configuration for XSRF protection.\n             */\n            imports: [\n                HttpClientXsrfModule.withOptions({\n                    cookieName: 'XSRF-TOKEN',\n                    headerName: 'X-XSRF-TOKEN',\n                }),\n            ],\n            /**\n             * Configures the [dependency injector](guide/glossary#injector) where it is imported\n             * with supporting services for HTTP communications.\n             */\n            providers: [\n                HttpClient,\n                { provide: HttpHandler, useClass: HttpInterceptingHandler },\n                HttpXhrBackend,\n                { provide: HttpBackend, useExisting: HttpXhrBackend },\n                BrowserXhr,\n                { provide: XhrFactory, useExisting: BrowserXhr },\n            ],\n        })\n    ], HttpClientModule);\n    return HttpClientModule;\n}());\n/**\n * Configures the [dependency injector](guide/glossary#injector) for `HttpClient`\n * with supporting services for JSONP.\n * Without this module, Jsonp requests reach the backend\n * with method JSONP, where they are rejected.\n *\n * You can add interceptors to the chain behind `HttpClient` by binding them to the\n * multiprovider for built-in [DI token](guide/glossary#di-token) `HTTP_INTERCEPTORS`.\n *\n * @publicApi\n */\nvar HttpClientJsonpModule = /** @class */ (function () {\n    function HttpClientJsonpModule() {\n    }\n    HttpClientJsonpModule = __decorate([\n        NgModule({\n            providers: [\n                JsonpClientBackend,\n                { provide: JsonpCallbackContext, useFactory: jsonpCallbackContext },\n                { provide: HTTP_INTERCEPTORS, useClass: JsonpInterceptor, multi: true },\n            ],\n        })\n    ], HttpClientJsonpModule);\n    return HttpClientJsonpModule;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NoopInterceptor as Éµangular_packages_common_http_http_a, JsonpCallbackContext as Éµangular_packages_common_http_http_b, jsonpCallbackContext as Éµangular_packages_common_http_http_c, BrowserXhr as Éµangular_packages_common_http_http_d, HttpXsrfCookieExtractor as Éµangular_packages_common_http_http_g, HttpXsrfInterceptor as Éµangular_packages_common_http_http_h, XSRF_COOKIE_NAME as Éµangular_packages_common_http_http_e, XSRF_HEADER_NAME as Éµangular_packages_common_http_http_f, HttpBackend, HttpHandler, HttpClient, HttpHeaders, HTTP_INTERCEPTORS, JsonpClientBackend, JsonpInterceptor, HttpClientJsonpModule, HttpClientModule, HttpClientXsrfModule, HttpInterceptingHandler as ÉµHttpInterceptingHandler, HttpParams, HttpUrlEncodingCodec, HttpRequest, HttpErrorResponse, HttpEventType, HttpHeaderResponse, HttpResponse, HttpResponseBase, HttpXhrBackend, XhrFactory, HttpXsrfTokenExtractor };\n//# sourceMappingURL=http.js.map\n"],"names":["HttpHandler","HttpBackend","HttpHeaders","headers","_this","this","normalizedNames","Map","lazyUpdate","lazyInit","split","forEach","line","index","indexOf","name_1","slice","key","toLowerCase","value","trim","maybeSetNormalizedName","has","get","push","set","Object","keys","name","values","length","prototype","init","Array","from","getAll","append","clone","op","delete","lcName","copyFrom","update","applyUpdate","other","concat","base","undefined","apply","__spread","toDelete_1","existing","filter","fn","HttpUrlEncodingCodec","encodeKey","standardEncoding","encodeValue","decodeKey","decodeURIComponent","decodeValue","v","encodeURIComponent","replace","HttpParams","options","updates","cloneFrom","encoder","fromString","fromObject","Error","map","rawParams","codec","param","eqIdx","_a","__read","val","list","paramParser","isArray","res","toString","eKey","join","base_1","idx","splice","isArrayBuffer","ArrayBuffer","isBlob","Blob","isFormData","FormData","HttpEventType","HttpRequest","method","url","third","fourth","body","reportProgress","withCredentials","responseType","toUpperCase","mightHaveBody","params","urlWithParams","qIdx","sep","serializeBody","JSON","stringify","detectContentTypeHeader","type","setHeaders","reduce","setParams","HttpResponseBase","defaultStatus","defaultStatusText","status","statusText","ok","HttpHeaderResponse","_super","call","ResponseHeader","__extends","HttpResponse","Response","HttpErrorResponse","message","error","addBody","observe","HttpClient","handler","request","first","req","events$","of","pipe","concatMap","handle","res$","event","head","jsonp","callbackParam","patch","post","put","__decorate","Injectable","__metadata","HttpInterceptorHandler","next","interceptor","intercept","HTTP_INTERCEPTORS","InjectionToken","NoopInterceptor","nextRequestId","JsonpCallbackContext","JsonpClientBackend","callbackMap","document","nextCallback","Observable","observer","callback","node","createElement","src","finished","cancelled","data","cleanup","parentNode","removeChild","onLoad","complete","onError","addEventListener","appendChild","Sent","removeEventListener","__param","Inject","DOCUMENT","JsonpInterceptor","XSSI_PREFIX","XhrFactory","BrowserXhr","build","XMLHttpRequest","HttpXhrBackend","xhrFactory","xhr","open","setRequestHeader","detectedType","reqBody","headerResponse","partialFromXhr","getAllResponseHeaders","responseURL","test","getResponseHeader","getResponseUrl","response","responseText","originalBody","parse","text","sentHeaders","onDownProgress","progressEvent","DownloadProgress","loaded","lengthComputable","total","partialText","onUpProgress","progress","UploadProgress","upload","send","abort","XSRF_COOKIE_NAME","XSRF_HEADER_NAME","HttpXsrfTokenExtractor","HttpXsrfCookieExtractor","doc","platform","cookieName","lastCookieString","lastToken","parseCount","getToken","cookieString","cookie","ÉµparseCookieValue","PLATFORM_ID","String","HttpXsrfInterceptor","tokenService","headerName","lcUrl","startsWith","token","HttpInterceptingHandler","backend","injector","chain","interceptors","reduceRight","Injector","jsonpCallbackContext","window","HttpClientXsrfModule","HttpClientXsrfModule_1","disable","ngModule","providers","provide","useClass","withOptions","useValue","NgModule","useExisting","multi","HttpClientModule","imports","HttpClientJsonpModule","useFactory"],"mappings":"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"}